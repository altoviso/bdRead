define(["bd", "bdRead", "com/altoviso/javaScriptApiRef"], function(bd, bdRead) {
// notice the document type is always a prerequisite to the document.

var
  MU= 1,
  MD= 2,
  CASE= 3,
  NOTE= 4,
  WARN= 5,
  CODE= 6,
  TODO= 7,
  TODOC= 8,
  INOTE= 9,
  PRIVATE= 10,
//TODO--these are types
  KWARGS= 11, 
  HASH= 12,
//end TODO
  NOSOURCE= 13,

  Tnamespace= bd.symbol("namespace"),
  Tmodule= bd.symbol("module"),
  Tconst= bd.symbol("const"),
  Tenum= bd.symbol("enum"),
  Ttype= bd.symbol("type"),
  Tvariable= bd.symbol("variable"),
  Tattr= bd.symbol("attribute"),
  Tfunction= bd.symbol("function"),
  Tclass= bd.symbol("class"),
  Tresources= bd.symbol("resources"),
  Tresource= bd.symbol("resource"),

  Fprivate= bd.symbol("private"),
  Ffunction= bd.symbol("function"),
  Fmodule= bd.symbol("module"),
  Fhash= bd.symbol("hash"),
  Froattr= bd.symbol("roAttr"),
  Fattr= bd.symbol("attr"),
  Fclassattr= bd.symbol("classAttr"),
  Fnosource= bd.symbol("noSource"),

  thisDoc= {
    name:"com/altoviso/backdraft/api/ref",
    type:"com/altoviso/javaScriptApiRef",
    displayName:"Backdraft Application Programming Interface Reference Manual",
    sdoc: ["Contains the reference documentation for all namespaces, types, functions, classes, constants, and variables defined by the of the Backdraft browser application framework."]
  };

  if (!bdRead.root.members[thisDoc.name]) {
    new bdRead.doc(thisDoc);
  }

  bdRead.adviseDocSection("com/altoviso/backdraft/api/ref", "default", [
  {
    name:thisDoc.name,
    type:thisDoc.type,
    displayName:thisDoc.displayName,
    sdoc:thisDoc.sdoc,
    urls: [
      "http://dev.altoviso.com:3000/backdraft/doc/generated/com.altoviso.backdraft.api.ref-"],
    sections: {
      "default": []
    },
    using: ["com/altoviso/javascript/api/ref"]
  },{
"resources.bd":{
type:
Tresource,
sdoc:
["Defines the module bd"],
src:
"bd",
modules:
["bd"],
code:
["dojo.def(\"bd\", [",
"  \"bd/kernel\", ",
"  \"bd/lang\",",
"  \"bd/declare\",",
"  \"bd/hash\",",
"  \"bd/clone\",",
"  \"bd/equal\",",
"  \"bd/connect\",",
"  \"bd/collections\",",
"  \"bd/string\",",
"  \"bd/creators\",",
"  \"bd/start\",",
"  \"bd/buildTools\"",
"], function(bd) {",
"///",
"// Creates, initializes, and holds to the bd namespace.",
"///",
"// Creates the bd namespace and several foundational constants, variables, and functions. Use this module",
"// to gain access to the bd namespace. For example,",
"//",
"//code",
"// dojo.def(\"my/module\", [\"bd\"], function(bd) {",
"//   //get the current time...",
"//   bd.getTime();",
"// });",
"/// ",
"// The actual work of creating and the bd object is delegated to the module bd/kernel, and several other modules (bd/lang,",
"// etc.) add foundational content the the bd object. It is an easy matter to redefine the bd namespace to hold more or less than this default",
"// definition. For example, if you a building several applications that all require the Backdraft command",
"// machinery, then you could define your own bd module as...",
"//code",
"//  dojo.def(\"bd\", [",
"//    \"bd/kernel\", ",
"//    \"bd/lang\",",
"//    \"bd/declare\",",
"//    \"bd/hash\",",
"//    \"bd/clone\",",
"//    \"bd/equal\",",
"//    \"bd/connect\",",
"//    \"bd/collections\",",
"//    \"bd/string\",",
"//    \"bd/creators\",",
"//    \"bd/start\"",
"//    \"bd/command/accelerators\",",
"//    \"bd/command/dispatch\",",
"//    \"bd/command/item\"",
"//  ], function(bd) {",
"//    return bd;",
"//  });",
"///",
"// By loading this module (instead of the default bd module), the command framework would",
"// be included without having to explicitly load it.",
"//warn",
"// Refrain from modifying the bd module resource directly. Instead, create a new resource located ",
"// outside the Backdraft tree and adjust dojo.urlMap to resolve the module bd to",
"// the selected location.",
"",
"  return bd;",
"});",
"// Copyright (c) 2008-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"modules.bd":{
type:
Tmodule,
sdoc:
["Creates, initializes, and holds to the bd namespace."],
ldoc:
["Creates the bd namespace and several foundational constants, variables, and functions. Use this module\nto gain access to the bd namespace. For example,",
[CODE,"dojo.def(\"my/module\", [\"bd\"], function(bd) {\n  //get the current time...\n  bd.getTime();\n});"],
"The actual work of creating and the bd object is delegated to the module bd/kernel, and several other modules (bd/lang,\netc.) add foundational content the the bd object. It is an easy matter to redefine the bd namespace to hold more or less than this default\ndefinition. For example, if you a building several applications that all require the Backdraft command\nmachinery, then you could define your own bd module as...",
[CODE,"dojo.def(\"bd\", [\n  \"bd/kernel\",\n  \"bd/lang\",\n  \"bd/declare\",\n  \"bd/hash\",\n  \"bd/clone\",\n  \"bd/equal\",\n  \"bd/connect\",\n  \"bd/collections\",\n  \"bd/string\",\n  \"bd/creators\",\n  \"bd/start\"\n  \"bd/command/accelerators\",\n  \"bd/command/dispatch\",\n  \"bd/command/item\"\n], function(bd) {\n  return bd;\n});"],
"By loading this module (instead of the default bd module), the command framework would\nbe included without having to explicitly load it.",
[WARN,"Refrain from modifying the bd module resource directly. Instead, create a new resource located\noutside the Backdraft tree and adjust dojo.urlMap to resolve the module bd to\nthe selected location."]],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd",
loc: [0,0,58,2]}
,"resources.bd/async":{
type:
Tresource,
sdoc:
["Defines the module bd/async"],
src:
"bd/async",
modules:
["bd/async"],
code:
["dojo.def(\"bd/async\", [",
"  \"bd\",",
"  \"bd/dom\"",
"], function(bd) {",
"///",
"// Augments the bd namespace with asynchronous processing machinery.",
"",
"bd.async=",
"  ///namespace ",
"  // Contains the Backdraft asynchronous processing functions.",
"  bd.async || {};",
"",
"var",
"  timerId= 0,",
"  callbacks= [],",
"  focusTarget= null,",
"  eq= function(target) {",
"    return function(item) {",
"      return item.callback==target.callback && item.context==target.context;",
"    };",
"  },",
"  neq= function(target) {",
"    return function(item) {",
"      return item.callback!==target.callback || item.context!==target.context;",
"    };",
"  };",
"",
"bd.mix(bd.async, {",
"  delay:",
"    ///",
"    // The milliseconds that to wait before executing scheduled functions.",
"    10,",
"",
"  exec: function(){",
"    ///",
"    // Executes all functions scheduled with bd.async.schedule.",
"    // `private",
"    // `warn",
"    // This routine is called internally by bd.async.schedule; it is exposed so that advanced users can override.",
"    var execQueue= callbacks;",
"    callbacks= [];",
"    clearInterval(timerId);",
"    timerId= 0;",
"    for (var i= 0, end= execQueue.length; i<end; i++) {",
"      var item= execQueue[i];",
"      item.callback.apply(item.context || bd.global, item.vargs);",
"    }",
"  },",
"",
"  schedule: function(",
"    flags,    ///(\"first\") Only the first attempt to schedule a callback is executed.",
"              //(\"last\") Only the last attempt to schedule a callback is executed.",
"              //(\"*\") All scheduled callbacks are executed.",
"    callback, ///(function) Function to execute asynchronously.",
"              //(string) Function name in context to execute asynchronously.",
"    context,  ///(object, optional) Context in which to apply callback; falsy implies bd.global.",
"    vargs     ///(variableArgs, optional) Zero or more arguments for application of callback.",
"  ){",
"    ///",
"    // Schedule a function for asynchronous execution.",
"    ///",
"    // If multiple attemps to schedule the same (`callback`, `context`) for asynchronous execution occur before a particular callback is executed,",
"    // flags determines which scheduled execution should occur. Notice that `vargs` do not influence \"sameness\".",
"    // For example,",
"    //",
"    //code",
"    // bd.async.schedule(\"first\", myCallback, 0, \"the first attempt\");",
"    // bd.async.schedule(myOtherCallback);",
"    // bd.async.schedule(\"first\", myCallback, 0, \"the second attempt\");",
"    ///",
"    // Would cause myCallback(\"the first attempt\") to be executed before myOtherCallback(). Whereas,",
"    // ",
"    //code",
"    // bd.async.schedule(\"last\", myCallback, 0, \"the first attempt\");",
"    // bd.async.schedule(myOtherCallback);",
"    // bd.async.schedule(\"last\", myCallback, 0, \"the second attempt\");",
"    ///",
"    // Would cause myOtherCallback() to be executed before myCallback(\"the second attempt\").",
"    //",
"    // Notice that the last flags argument seen for a particular (`callback`, `context`) override all other flags arguments given for that callback.",
"    if (bd.isString(callback)) {",
"      callback= (context ? context[callback] : bd.global[callback]);",
"    }",
"    context= context || 0;",
"    var item= {",
"      callback: callback,",
"      context: context,",
"      vargs: bd.array(arguments, 3)",
"    };",
"",
"    if (!timerId) {",
"      timerId= setInterval(bd.hitch(bd.async, \"exec\"), bd.async.delay);",
"    }",
"    switch (flags) {",
"      case \"first\":",
"        bd.findFirst(callbacks, eq(item))===-1 && callbacks.push(item);",
"        break;",
"      case \"last\":",
"        callbacks= bd.filter(callbacks, neq(item));",
"        callbacks.push(item);",
"        break;",
"      default:",
"        callbacks.push(item);",
"        break;",
"    }",
"  },",
"",
"  setFocus: function(",
"    target ///(object) The object upon which to set focus.",
"  ) {",
"    ///",
"    // Sets the focus to target asynchronously.",
"    setTimeout(function() {",
"      target.focus();",
"    }, 0);",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, ALTOVISO, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.async":{
type:
Tnamespace,
sdoc:
["Contains the Backdraft asynchronous processing functions."],
ldoc:
[],
src:
"bd/async",
loc: [7,0,10,16],
module:"bd/async"}
,"bd.async.delay":{
type:
Tvariable,
sdoc:
["The milliseconds that to wait before executing scheduled functions."],
ldoc:
[],
src:
"bd/async",
loc: [28,2,31,6],
module:"bd/async"}
,"bd.async.exec":{
type:
Tfunction,
sdoc:
["Executes all functions scheduled with bd.async.schedule."],
ldoc:
[[WARN,"This routine is called internally by bd.async.schedule; it is exposed so that advanced users can override."]],
flags:
[Fprivate],
src:
"bd/async",
loc: [33,2,47,3],
module:"bd/async"}
,"bd.async.schedule":{
type:
Tfunction,
sdoc:
["Schedule a function for asynchronous execution."],
ldoc:
["If multiple attemps to schedule the same (`callback`, `context`) for asynchronous execution occur before a particular callback is executed,\nflags determines which scheduled execution should occur. Notice that `vargs` do not influence \"sameness\".\nFor example,",
[CODE,"bd.async.schedule(\"first\", myCallback, 0, \"the first attempt\");\nbd.async.schedule(myOtherCallback);\nbd.async.schedule(\"first\", myCallback, 0, \"the second attempt\");"],
"Would cause myCallback(\"the first attempt\") to be executed before myOtherCallback(). Whereas,",
[CODE,"bd.async.schedule(\"last\", myCallback, 0, \"the first attempt\");\nbd.async.schedule(myOtherCallback);\nbd.async.schedule(\"last\", myCallback, 0, \"the second attempt\");"],
"Would cause myOtherCallback() to be executed before myCallback(\"the second attempt\").\n\nNotice that the last flags argument seen for a particular (`callback`, `context`) override all other flags arguments given for that callback."],
params:
[["flags",[["\"first\"",
["Only the first attempt to schedule a callback is executed."]],
["\"last\"",
["Only the last attempt to schedule a callback is executed."]],
["\"*\"",
["All scheduled callbacks are executed."]]]],
["callback",[["function",
["Function to execute asynchronously."]],
["string",
["Function name in context to execute asynchronously."]]]],
["context",[["object, optional",
["Context in which to apply callback; falsy implies bd.global."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
src:
"bd/async",
loc: [49,2,105,3],
module:"bd/async"}
,"bd.async.setFocus":{
type:
Tfunction,
sdoc:
["Sets the focus to target asynchronously."],
ldoc:
[],
params:
[["target",[["object",
["The object upon which to set focus."]]]]],
src:
"bd/async",
loc: [107,2,115,3],
module:"bd/async"}
,"modules.bd/async":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with asynchronous processing machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/async",
loc: [0,0,118,2]}
,"resources.bd/clone":{
type:
Tresource,
sdoc:
["Defines the module bd/clone"],
src:
"bd/clone",
modules:
["bd/clone"],
code:
["dojo.def(\"bd/clone\", [\"bd/kernel\", \"dojo\", \"bd/declare\"], function(bd, dojo) {",
"///",
"// Defines the function bd.clone.",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load the module bd. See module.bd.",
"",
"bd.clone= function(",
"  source,  ///(any) object to clone",
"  watchdog ///(integer, optional, 10) The maximum nesting depth of structures before a circular structure is assumed.",
"){",
"  ///",
"  // Clones source (deep copy).",
"  //",
"  //return",
"  //(number, boolean, string, null, undefined) by-value copy of source",
"  //> source is a number, boolean, string, null, or undefined",
"  //",
"  //(function) reference to source",
"  //> source is a function",
"  //",
"  //(object) new object with same set of properties as source, with each property, p, initialized to bd.clone(source[p])",
"  //> source is type Object (i.e., object.prototype.constructor===Object)",
"  //",
"  //(any) result of source.constructor.clone",
"  //> source.constructor.clone is function",
"  //",
"  //(any) result of bd.clone.factories.get(source.prototype.constructor)(source)",
"  //> bd.clone.factories.get(source.prototype.constructor)!==bd.notFound",
"  // ",
"  //(object) Object with the same set of properties, with each property, p, initialized to bd.clone(source[p])",
"  //> none of the other conditions above are satisfied.",
"  ///",
"  //warn",
"  //  Will not properly clone structures with cycles; throws an exception when source contains a cycle.",
"  //",
"  //warn",
"  //  Will not properly clone delegated objects.",
"  //",
"  //todo",
"  //  Add support for delegated objects.",
"  //",
"  var objectClone= function(source) {",
"    var clone;",
"    if (source.constructor) {",
"      clone= new source.constructor();",
"      for (var p in source) {",
"        if (source.hasOwnProperty(p)) {",
"          clone[p]= bd.clone(source[p], watchdog-1);",
"        }",
"      }",
"      return clone;",
"    }",
"    clone= {};",
"    for (p in source) {",
"      if (clone[p]!==source[p]) {",
"        clone[p]= bd.clone(source[p], watchdog-1);",
"      }",
"    }",
"    return clone;",
"  };",
"",
"  if (watchdog===0) {",
"    throw new Error(\"bd.clone: cycle detected\");",
"  }",
"  if (!watchdog) {",
"    watchdog= 10;",
"  }",
"",
"  if (typeof source!==\"object\" || source===null || source===undefined || bd.isFunction(source)) {",
"    return source;",
"  }",
"",
"  if (source.constructor===Object) {",
"    return objectClone(source);",
"  }",
"",
"  if (bd.isFunction(source.clone)) {",
"    return source.clone(watchdog);",
"  }",
"",
"  var cloneFunction= bd.clone.factories.get(source.constructor);",
"  if (cloneFunction!==bd.notFound) {",
"    return cloneFunction(source, watchdog);",
"  }",
"",
"  return objectClone(source);",
"};",
"",
"bd.clone.factories=",
"  ///",
"  // An instance of bd.hash that gives a map from constructor function to factory function for use with bd.clone. //",
"  // The factory functions are called assuming the same signature of bd.clone.",
"  //",
"  // bd.clone.factories is initialized to handle Arrays, Dates, Errors, and RegExps. Client",
"  // code can augment the array to handle other, client-defined types.",
"  (new bd.hash()).",
"    set(Array, function(source, watchdog) {",
"        watchdog--;",
"        for (var result= [], i= 0, end= source.length; i<end; result[i]= bd.clone(source[i++], watchdog));",
"        return result; ",
"      }).",
"    set(Date, function(source){",
"        return new Date(source.getTime());",
"      }).",
"    set(Error, function(source){",
"        return new Error(source.message);",
"      }).",
"    set(RegExp, function(source){",
"        return new RegExp(source.source, (source.global ? \"g\" : \"\") + (source.ignoreCase ? \"i\" : \"\") + (source.multiline ? \"m\" : \"\"));",
"      }).",
"    set(String, function(source){",
"        return new String(source.substring(0));",
"      }).",
"    set(Number, function(source){",
"        return new Number(source);",
"      }",
"    );",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.clone":{
type:
Tfunction,
sdoc:
["Clones source (deep copy)."],
ldoc:
[[WARN,"Will not properly clone structures with cycles; throws an exception when source contains a cycle."],
[WARN,"Will not properly clone delegated objects."]],
params:
[["source",[["any",
["object to clone"]]]],
["watchdog",[["integer, optional, 10",
["The maximum nesting depth of structures before a circular structure is assumed."]]]]],
returns:
[["number, boolean, string, null, undefined",
["by-value copy of source",
[CASE,"source is a number, boolean, string, null, or undefined"]]],
["function",
["reference to source",
[CASE,"source is a function"]]],
["object",
["new object with same set of properties as source, with each property, p, initialized to bd.clone(source[p])",
[CASE,"source is type Object (i.e., object.prototype.constructor===Object)"]]],
["any",
["result of source.constructor.clone",
[CASE,"source.constructor.clone is function"]]],
["any",
["result of bd.clone.factories.get(source.prototype.constructor)(source)",
[CASE,"bd.clone.factories.get(source.prototype.constructor)!==bd.notFound"]]],
["object",
["Object with the same set of properties, with each property, p, initialized to bd.clone(source[p])",
[CASE,"none of the other conditions above are satisfied."]]]],
src:
"bd/clone",
loc: [7,0,87,1],
module:"bd/clone"}
,"bd.clone.factories":{
type:
Tvariable,
sdoc:
["An instance of bd.hash that gives a map from constructor function to factory function for use with bd.clone. "],
ldoc:
["An instance of bd.hash that gives a map from constructor function to factory function for use with bd.clone. \nThe factory functions are called assuming the same signature of bd.clone.\n\nbd.clone.factories is initialized to handle Arrays, Dates, Errors, and RegExps. Client\ncode can augment the array to handle other, client-defined types."],
src:
"bd/clone",
loc: [89,0,117,5],
module:"bd/clone"}
,"modules.bd/clone":{
type:
Tmodule,
sdoc:
["Defines the function bd.clone."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load the module bd. See module.bd."]],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/clone",
loc: [0,0,119,2]}
,"resources.bd/collections":{
type:
Tresource,
sdoc:
["Defines the module bd/collections"],
src:
"bd/collections",
modules:
["bd/collections"],
docLocs:
[[841,851],[804,814],[725,737],[677,687],[641,651],[607,617],[451,461],[396,406],[329,339],[198,210],[140,150],[96,106],[7,52]],
code:
["dojo.def(\"bd/collections\", [\"bd/kernel\", \"dojo\", \"bd/lang\"], function(bd, dojo) {",
"///",
"// Augments the bd namespace with several functions that operate on collections.",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load the module bd. See module.bd.",
"",
"bd.docGen(\"bd\", {",
"  collectionCallback: function(",
"    item,      ///(any) The current item in collection",
"    offset,    ///(integer) If collection is an array, the current offset of item in collection.",
"               //(string) If collection is an object, the property name at which item resides.",
"    collection ///(array or hash) The collection.",
"  ){",
"    ///",
"    // Function signature expected by several collection functions that iterate of a collection.",
"    ///",
"    // collection[offset]===item is guaranteed true.",
"    ///",
"    // Side effects and return semantics as given by client-code and the particular collection function.",
"",
"    //as required by semantics of client code",
"  },",
"",
"  collectionPredicate: function(",
"    item,      ///(any) The current item in collection",
"    offset,    ///(integer) If collection is an array, the current offset of item in collection.",
"               //(string) If collection is an object, the property name at which item resides.",
"    collection ///(array or hash) The collection.",
"  ){",
"    ///",
"    // Function signature expected by several collection functions that search for",
"    // an item in a collection. //The function must return true if item is the target item; false otherwise.",
"    ///",
"    // collection[offset]===item is guaranteed true.",
"",
"    //as required by semantics of client code",
"  },",
"",
"  collectionOrder: function(",
"    item ///(any) The item to test.",
"  ) {",
"   ///",
"   // Function signature expected by bd.binarySearch; returns the relative order of an item to a target.",
"   ///",
"   //return",
"   //(-1) item is less than target.",
"   //(0) item is equal to target.",
"   //(1) item is greater than target.",
"",
"   //code to determine order of item relative to some target.",
"  }",
"});",
"",
"var fixCallback= function(args, callbackIndex, useHashArgs) {",
"  var callback= args[callbackIndex];",
"  if (args.length>callbackIndex+1) {",
"    return bd.hitch.apply(bd, bd.array(args, callbackIndex+2, [args[callbackIndex+1], callback]));",
"  } else if (bd.isString(callback)) {",
"    return (useHashArgs ? new Function(\"item\", \"key\", \"hash\", callback) : new Function(\"item\", \"index\", \"array\", callback));",
"  } else {",
"    return callback;",
"  }",
"};",
"",
"bd.hasNative= function(",
"  collection, ///(any) The collection to test.",
"  methodName  ///(string) The method name to test.",
") {",
"  ///",
"  // Returns true iff collection contains the method methodName.",
"  ///",
"  // This can be used to turn off usage of built-in collection functions (e.g. Array.forEach) as",
"  // well as during unit testing of the collections module.",
"  return bd.isFunction(collection[methodName]);",
"};",
"",
"bd.forEach= function(",
"    collection, ///(bd.collection) The collection to iterate.",
"    callback,   ///(bd.collectionCallback) Function to apply to each item in the collection.",
"    context,    ///(object, optional) Context in which to apply callback.",
"    vargs       ///(variableArgs, optional) Zero or more arguments for application of callback.",
"  ) {",
"  ///",
"  // Applies callback to each item in the collection. ",
"  ///",
"  // If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function",
"  // returns without executing any processing.",
"  // ",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
"  // ",
"  // The function delegates to collection.forEach if the collection contains the method forEach. Note in particular",
"  // that Array.forEach will be used in environments that define that function. Otherwise,",
"  // iterate from front to back over each item in the collection.",
"  //note",
"  // See [JavaScript 1.5 Array forEach specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/forEach).",
"  bd.docGen(\"overload\",",
"    function(",
"      collection,",
"      callback   ///(string) Source text of a callback function.",
"    ) {",
"      ///",
"      // As above except that callback is taken as",
"      //code",
"      // new Function(\"item\", \"index\", \"array\", callback)",
"    }",
"  );",
"  if (!collection) {",
"    //short cuircuit return",
"    return;",
"  }",
"  callback= fixCallback(arguments, 1);",
"  if (bd.hasNative(collection, \"forEach\")) {",
"    collection.forEach(callback);",
"  } else {",
"    for (var i= 0, end= collection.length; i<end; i++) {",
"      callback(collection[i], i, collection);",
"    }",
"  }",
"};",
"",
"bd.map= function(",
"  collection, ///(bd.collection) The collection to iterate.",
"  callback,   ///(bd.collectionCallback) Function to apply to each item in the collection.",
"  context,    ///(object, optional) Context in which to apply callback.",
"  vargs       ///(variableArgs, optional) Zero or more arguments for application of callback.",
") {",
"  ///",
"  // Returns the array of results of applying callback to each item in collection.",
"  ///",
"  // If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function",
"  // returns an empty array without executing any processing.",
"  // ",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
"  // ",
"  // The function delegates to collection.map if the collection contains the method map. Note in particular",
"  // that Array.map will be used in environments that define that function. Otherwise,",
"  // iterate from front to back over each item in the collection.",
"  //note",
"  // See [JavaScript 1.5 Array map specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/map).",
"  bd.docGen(\"overload\",",
"    function(",
"      collection,",
"      callback   ///(string) Source text of a callback function.",
"    ) {",
"      ///",
"      // As above except that callback is taken as",
"      //code",
"      // new Function(\"item\", \"index\", \"array\", callback)",
"    }",
"  );",
"  if (!collection) {",
"    //short cuircuit return",
"    return [];",
"  }",
"  callback= fixCallback(arguments, 1);",
"  if (bd.hasNative(collection, \"map\")) {",
"    return collection.map(callback);",
"  }",
"  var result= [];",
"  for (var i= 0, end= collection.length; i<end; i++) {",
"    result.push(callback(collection[i], i, collection));",
"  }",
"  return result;",
"};",
"",
"bd.findFirst= function(",
"  collection, ///(bd.collection) The collection to inspect.",
"  predicate,  ///(bd.collectionPredicate) Returns true when applied to target item.",
"  start,      ///(positive integer, optional, 0) search begining with start; ignored if collection is not an array.",
"  callback,   ///(bd.collectionCallback, optional) The function to apply to found item (if any).",
"  context,    ///(object, optional) Context in which to apply callback.",
"  vargs       ///(variableArgs, optional) Zero or more arguments for application of predicate.",
") {",
"  ///",
"  // Searches for the first item that satisfies predicate.",
"  ///",
"  // Returns the index (if no callback is provided) or the result of the callback (if a callback is provided)",
"  // of the first item in collection that satisfies the predicate (if such an item",
"  // exists); otherwise, when no item satsifies the predicate, the callback (if any) is not called and -1 is returned.",
"  // ",
"  // If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function",
"  // returns -1 immediately without executing any processing.",
"  // ",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
"  // ",
"  // The function delegates to collection.findFirst if the collection contains the method findFirst.",
"  // ",
"  // Seaching starts at index start (if start>0), at index length+start (if start<0),",
"  // or 0 (if start is 0 or missing) and proceeds front-to-back.",
"  // ",
"  //return",
"  //(any) callback(item, index, collection)",
"  //> item matches at index and callback is given.",
"  //(integer) offset of match into collection of match",
"  //> match is found and collection is an array",
"  //(-1)",
"  //> no item satisfies predicate or collection is falsy",
"  bd.docGen(\"overload\",",
"    function(",
"      collection,",
"      predicate,",
"      start,",
"      callback   ///(string) Source text of a callback function.",
"    ) {",
"      ///",
"      // As above except that callback is taken as",
"      //code",
"      // new Function(\"item\", \"index\", \"array\", callback)",
"    }",
"  );",
"  if (!collection) {",
"    //short cuircuit return",
"    return -1;",
"  }",
"  var start_= 0;",
"  if (typeof start==\"number\") {",
"    callback= fixCallback(arguments, 3);",
"    start_= ((start<0 && collection.length) ? (collection.length + start) : start);",
"  } else {",
"    callback= fixCallback(arguments, 2);",
"  }",
"  if (bd.hasNative(collection, \"findFirst\")) {",
"    return start===undefined ? collection.findFirst(predicate, callback) : collection.findFirst(predicate, start, callback);",
"  }",
"  for(var i= Math.min(collection.length, Math.max(start_, 0)), end= collection.length; i<end; i++) {",
"    if (predicate(collection[i], i, collection)) {",
"      return callback ? callback(collection[i], i, collection) : i;",
"    }",
"  }",
"  return -1;",
"};",
"",
"//TODO bd.findLast",
"",
"bd.some= function(",
"  collection, ///(bd.collection) The collection to inspect.",
"  predicate,  ///(bd.collectionPredicate) Returns true when applied to target item.",
"  context,    ///(object, optional) Context in which to apply predicate.",
"  vargs       ///(variableArgs, optional) Zero or more arguments for application of predicate.",
") {",
"  ///",
"  // Returns true if some item in collection satisfies predicate; false otherwise.",
"  ///",
"  // If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function",
"  // returns false immediately without executing any processing.",
"  // ",
"  // If context is given, then the predicate is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
"  // ",
"  // The function delegates to collection.some if the collection contains the method some. Note in particular",
"  // that Array.some will be used in environments that define that function. Otherwise,",
"  // iterate from front to back over each item in the collection until predicate is satisfied or the array is",
"  // exhausted",
"  //note",
"  // See [JavaScript 1.5 Array some specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/some).",
"  if (!collection) {",
"    //short cuircuit return",
"    return false;",
"  }",
"  predicate= fixCallback(arguments, 1);",
"  return ((bd.hasNative(collection, \"some\")) ? collection.some(predicate) : (bd.findFirst(collection, predicate)!==-1));",
"};",
"",
"bd.every= function(",
"  collection, ///(collection) The collection to inspect.",
"  predicate,  ///(bd.collectionPredicate) Returns true when applied to target item.",
"  context,    ///(object, optional) Context in which to apply predicate.",
"  vargs       ///(variableArgs, optional) Zero or more arguments for application of predicate.",
") {",
"  ///",
"  // Returns true if every item in collection satisfies predicate; false otherwise.",
"  ///",
"  // If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function",
"  // returns false immediately without executing any processing.",
"  // ",
"  // If context is given, then the predicate is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
"  //",
"  // The function delegates to collection.every if the collection contains the method every. Note in particular",
"  // that Array.every will be used in environments that define that function. Otherwise,",
"  // iterate from front to back, until predicate is not satisfied or the array is exhausted.",
"  //note",
"  // See [JavaScript 1.5 Array every specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/every).",
"  if (!collection) {",
"    //short cuircuit return",
"    return true;",
"  }",
"  predicate= fixCallback(arguments, 1);",
"  if (bd.hasNative(collection, \"every\")) {",
"    return collection.every(predicate);",
"  }",
"  for(var i= 0, end= collection.length; i<end; i++) {",
"    if (!predicate(collection[i], i, collection)) {",
"      return false;",
"    }",
"  }",
"  return true;",
"};",
"",
"bd.indexOf= function(",
"  collection, ///(bd.collection) The collection to inspect.",
"  target,     ///(any) The target to find via operator ===.",
"  start,      ///(integer, optional, 0) Index to start search at.",
"  callback,   ///(bd.collectionCallback, optional) The function to apply to found item (if any).",
"  context,    ///(object, optional) Context in which to apply callback.",
"  vargs       ///(variableArgs, optional) Zero or more arguments for application of callback.",
") {",
"  ///",
"  // Searches from front to back for the first item===target.",
"  ///",
"  // If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function",
"  // returns -1 immediately without executing any processing.",
"  // ",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
"  // ",
"  // The function delegates to collection.indexOf if the collection contains the method indexOf. Note in particular",
"  // that Array.indexOf will be used in environments that define that function. Otherwise,",
"  // iterate as implied by start to the back of the collection until an item===target or the array is exhausted.",
"  // ",
"  // Seaching starts at index start (if start>0), at index length+start (if start<0),",
"  // or 0 (if start is 0 or missing) and proceeds front-to-back.",
"  //",
"  //return",
"  //(integer) index of first item===target",
"  //> an item is found such that item===target",
"  //(-1)",
"  //> no item is found such that item===target or collection was falsy",
"  ///",
"  //note",
"  // See [JavaScript 1.5 Array indexOf specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/indexOf).",
"  bd.docGen(\"overload\",",
"    function(",
"      collection,",
"      callback   ///(string) Source text of a callback function.",
"    ) {",
"      ///",
"      // As above except that callback is taken as",
"      //code",
"      // new Function(\"item\", \"index\", \"array\", callback)",
"    }",
"  );",
"  if (!collection) {",
"    //short cuircuit return",
"    return -1;",
"  }",
"  var start_= 0;",
"  if (typeof start==\"number\") {",
"    callback= fixCallback(arguments, 3);",
"    start_= (start<0 ? (collection.length + start) : start);",
"  } else {",
"    callback= fixCallback(arguments, 2);",
"    start= undefined;",
"  }",
"  var result, i, end;",
"  if (bd.hasNative(collection, \"indexOf\")) {",
"    result= (start===undefined ? collection.indexOf(target) : collection.indexOf(target, start));",
"    return ((result!=-1 && callback) ? callback(collection[result], result, collection) : result);",
"  }",
"  for(i= Math.min(collection.length, Math.max(start_, 0)), end= collection.length; i<end; i++) {",
"    if (collection[i]===target) {",
"      return callback ? callback(collection[i], i, collection) : i;",
"    }",
"  }",
"  return -1;",
"};",
"",
"bd.lastIndexOf= function(",
"  collection, ///(bd.collection) The collection to iterate.",
"  target,     ///(any) the target to find via operator ===.",
"  start,      ///(integer, optional, 0) Index to start search at.",
"  callback,   ///(bd.collectionCallback, optional)The function to apply to found item (if any).",
"  context,    ///(object, optional) Context in which to apply callback.",
"  vargs       ///(variableArgs, optional) Zero or more arguments for application of callback.",
") {",
"  ///",
"  // Searches from back-to-front for the first item===target.",
"  ///",
"  // If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function",
"  // returns -1 immediately without executing any processing.",
"  // ",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
"  // ",
"  // The function delegates to collection.lastIndexOf if the collection contains the method lastIndexOf. Note in particular",
"  // that Array.lastIndexOf will be used in environments that define that function. Otherwise,",
"  // iterate as implied by start to the front of the collection until an item===target or the array is exhausted.",
"  // ",
"  // Seaching starts at index start (if start>0), at index length+start (if start<0),",
"  // or 0 (if start is 0 or missing) and proceeds front-to-back.",
"  //",
"  //return",
"  //(integer) index of first item===target",
"  //> an item is found such that item===target",
"  //(-1)",
"  //> no item is found such that item===target or collection was falsy",
"  ///",
"  //note",
"  // See [JavaScript 1.5 Array lastIndexOf specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/lastIndexOf).",
"  bd.docGen(\"overload\",",
"    function(",
"      collection,",
"      callback   ///(string) Source text of a callback function.",
"    ) {",
"      ///",
"      // As above except that callback is taken as",
"      //code",
"      // new Function(\"item\", \"index\", \"array\", callback)",
"    }",
"  );",
"  if (!collection) {",
"    //short cuircuit return",
"    return -1;",
"  }",
"  var start_= collection.length;",
"  if (typeof start==\"number\") {",
"    start_= ((start<0) ? collection.length + start : start);",
"    callback= fixCallback(arguments, 3);",
"  } else {",
"    callback= fixCallback(arguments, 2);",
"    start= undefined;",
"  }",
"  var result, i;",
"  if (bd.hasNative(collection, \"lastIndexOf\")) {",
"    result= (start===undefined ? collection.lastIndexOf(target) : collection.lastIndexOf(target, start));",
"    return ((result!=-1 && callback) ? callback(collection[result], result, collection) : result);",
"  }",
"  for(i= Math.min(collection.length-1, start_); i>=0; i--) {",
"    if (collection[i]===target) {",
"      return callback ? callback(collection[i], i, collection) : i;",
"    }",
"  }",
"  return -1;",
"};",
"",
"bd.filter= function(",
"  collection, ///(bd.collection) The collection to iterate.",
"  callback,   ///(bd.collectionCallback) The predicate that filters.",
"  context,    ///(object, optional) Context in which to apply callback.",
"  vargs       ///(variableArgs, optional) Zero or more arguments for application of callback.",
") {",
"  ///",
"  // Creates an array that contains all items in collection that satisfy callback.",
"  ///",
"  // If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function",
"  // returns an empty array immediately without executing any processing.",
"  // ",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
"  // ",
"  // The function delegates to collection.filter if the collection contains the method filter. Note in particular",
"  // that Array.filter will be used in environments that define that function. Otherwise,",
"  // iterate from front to back over each item in the collection.",
"  //note",
"  // See [JavaScript 1.5 Array filter specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter).",
"  bd.docGen(\"overload\",",
"    function(",
"      collection,",
"      callback   ///(string) Source text of a callback function.",
"    ) {",
"      ///",
"      // As above except that callback is taken as",
"      //code",
"      // new Function(\"item\", \"index\", \"array\", callback)",
"    }",
"  );",
"  if (!collection) {",
"    //short cuircuit return",
"    return [];",
"  }",
"  callback= fixCallback(arguments, 1);",
"  if (bd.hasNative(collection, \"filter\")) {",
"    return collection.filter(callback);",
"  }",
"  var result= [];",
"  for (var i= 0,  end=collection.length; i<end; i++) {",
"    if (callback(collection[i], i, collection)) {",
"      result.push(collection[i]); ",
"    }",
"  };",
"  return result;",
"};",
"",
"bd.doTimes= function(",
"  range,    ///(integer) End point of range to apply callback; 0 is implied for start.",
"            //(array [start, end]) Range to apply callback.",
"  callback, ///(function(index)) Function to apply to each integer in range.",
"  context,  ///(object, optional) Context in which to apply callback.",
"  vargs     ///(variableArgs, optional) Zero or more arguments for application of callback.",
") {",
"  ///",
"  // Apply callback to range of integers.",
"  ///",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
"  // ",
"  // If range is an integer, then range is [0..n-1]; otherwise range is [n[0]..n[1]-1]. ",
"  callback= fixCallback(arguments, 1);",
"  var i= 0;",
"  if (bd.isArray(range)) {",
"    i= range[0];",
"    range= range[1];",
"  }",
"  while (i<range) {",
"    callback(i++);",
"  }",
"};",
"",
"bd.back= function(",
"  collection ///(array) The array from which to return the last element.",
") {",
"  ///",
"  // Returns the last element of an array.",
"  ///",
"  //return",
"  //(any) collection[collection.length-1]",
"  //> collection.length > 0",
"  //",
"  //(undefined)",
"  //> collection.length==0",
"  var end= collection && collection.length;",
"  return end ? collection[end-1] : undefined;",
"};",
"",
"bd.binarySearch= function(",
"  collection, ///(array) The array to search.",
"  comp        ///(bd.collectionOrder) Compares an element of collection to the item being sought.",
") {",
"  ///",
"  // Finds a target item in an ordered array using a binary search algorithm. //",
"  // If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function",
"  // returns immediately without executing any processing.",
"  // ",
"  //warn",
"  // The array must be ordered.",
"  ///",
"  //return",
"  //(integer) Index of target item.",
"  //> comp return 0 for some item.",
"  // ",
"  //bd.notFound",
"  //> comp failed to return 0 for any item.",
"",
"  if (!collection || !collection.length) {",
"    return bd.notFound;",
"  }",
"  var",
"    left= 0, right= collection.length-1, current, order;",
"  while (left<=right) {",
"    current= Math.floor((left + right) / 2);",
"    order= comp(collection[current]);",
"    if (order>0) {",
"      right= current - 1;",
"    } else if (order<0) {",
"      left= current + 1;",
"    } else {",
"      return current;",
"    }",
"  }",
"  return bd.notFound;",
"};",
"",
"",
"bd.lengthHash= function(",
"  hash ///(hash) The hash to check.",
"       //(falsy) Return 0",
") {",
"  ///",
"  // Returns the number of elements in hash.",
"  ///",
"  //return ",
"  //(integer) The number of elements contained in hash.",
"  //(0) The hash has no elements or is falsy.",
"  var i= 0;",
"  for (var p in hash) {",
"    ++i;",
"  }",
"  return i;",
"};",
"",
"bd.isEmptyHash= function(",
"  hash ///(hash) The hash to check.",
"       //(falsy) Implies an empty hash.",
") {",
"  ///",
"  // Determines if hash contains any elements.",
"  ///",
"  //return ",
"  //(false) The hash contains at least one element.",
"  //(true) The hash contains elements or is falsy.",
"",
"  for (var p in hash) {",
"    if (hash.hasOwnProperty(p)) {",
"      return false;",
"    }",
"  }",
"  return true;",
"};",
"",
"bd.forEachHash= function(",
"  hash,     ///(hash) The hash to iterate.",
"  callback, ///(bd.hashCallbackFunction) Function to apply to each item in the hash.",
"  context,  ///(object, optional) Context in which to apply callback.",
"  vargs     ///(variableArgs, optional) Zero or more arguments for application of callback.",
") {",
"  ///",
"  // Applies callback to each item in the hash. ",
"  ///",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
"  //warn",
"  // Behavior of the function is undefined if the hash is modified in the callback. If you",
"  // the callback semantics modify the hash, use bd.forEachHashSafe.",
"  bd.docGen(\"overload\",",
"    function(",
"      hash,",
"      callback   ///(string) Source text of a callback function.",
"    ) {",
"      ///",
"      // As above except that callback is taken as",
"      //code",
"      // new Function(\"item\", \"index\", \"array\", callback)",
"    }",
"  );",
"  if (!hash) {",
"    //short cuircuit return",
"    return;",
"  }",
"  callback= fixCallback(arguments, 1, true);",
"  for (var p in hash) {",
"    callback(hash[p], p, hash);",
"  }",
"};",
"",
"//TODO: unit test for bd.forEachHashSafe",
"bd.forEachHashSafe= function(",
"  hash,     ///(hash) The hash to iterate.",
"  callback, ///(bd.hashCallbackFunction) Function to apply to each item in the hash.",
"  context,  ///(object, optional) Context in which to apply callback.",
"  vargs     ///(variableArgs, optional) Zero or more arguments for application of callback.",
") {",
"  ///",
"  // Applies callback to each item in the hash; the hash may be modified in the callback.  //An",
"  // attempt is made to call every key that exists in the hash upon entry. No attempt is made",
"  // to call keys added by callbacks.",
"  ///",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
"  bd.docGen(\"overload\",",
"    function(",
"      hash,",
"      callback   ///(string) Source text of a callback function.",
"    ) {",
"      ///",
"      // As above except that callback is taken as",
"      //code",
"      // new Function(\"item\", \"index\", \"array\", callback)",
"    }",
"  );",
"  if (!hash) {",
"    //short cuircuit return",
"    return;",
"  }",
"  callback= fixCallback(arguments, 1, true);",
"  var keys= [];",
"  for (var p in hash) {",
"    keys.push(p);",
"  }",
"  for (var i= 0, end= keys.length; i<end; i++) {",
"    var key= keys[i];",
"    callback(hash[key], key, hash);",
"  }",
"};",
"",
"bd.mapHash= function(",
"  hash,    ///(hash) The hash to iterate.",
"  callback,///(bd.hashCallbackFunction) Function to apply to each item in the hash.",
"  context, ///(object, optional) Context in which to apply callback.",
"  vargs    ///(variableArgs, optional) Zero or more arguments for application of callback.",
") {",
"  ///",
"  // Returns the array of results of applying callback to each item in hash.",
"  ///",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
"  bd.docGen(\"overload\",",
"    function(",
"      hash,",
"      callback   ///(string) Source text of a callback function.",
"    ) {",
"      ///",
"      // As above except that callback is taken as",
"      //code",
"      // new Function(\"item\", \"index\", \"array\", callback)",
"    }",
"  );",
"  if (!hash) {",
"    //short cuircuit return",
"    return [];",
"  }",
"  callback= fixCallback(arguments, 1, true);",
"  var result= [];",
"  for (var p in hash) {",
"    result.push(callback(hash[p], p, hash));",
"  }",
"  return result;",
"};",
"",
"bd.findHash= function(",
"  hash,     ///(hash) The hash to inspect.",
"  predicate,///(bd.hashTargetPredicate) Returns true when applied to target item.",
"  callback, ///(bd.hashCallbackFunction, optional) The function to apply to found item.",
"  context,  ///(object, optional) Context in which to apply callback.",
"  vargs     ///(variableArgs, optional) Zero or more arguments for application of callback.",
") {",
"  ///",
"  // Searches for the first item that satisfies predicate.",
"  ///",
"  // Returns the key (if no callback is provided) or the result of the callback (if a callback is provided)",
"  // of the first item in hash that satisfies the predicate (if such an item",
"  // exists); otherwise, when no item satsifies the predicate, the callback (if any) is not called and bd.notFound is returned.",
"  // ",
"  // If context and any vargs are given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before proceeding as described next.",
"  // ",
"  //return",
"  //(any) callback(item, key, hash)",
"  //> item matches at key and callback is given.",
"  // ",
"  //(key) the property name of the match",
"  //> match is found at hash[key]",
"  //",
"  //(bd.notFound)",
"  //> no match is found or hash is falsy",
"  bd.docGen(\"overload\",",
"    function(",
"      hash,",
"      predicate,",
"      start,",
"      callback   ///(string) Source text of a callback function.",
"    ) {",
"      ///",
"      // As above except that callback is taken as",
"      //code",
"      // new Function(\"item\", \"index\", \"array\", callback)",
"    }",
"  );",
"  if (!hash) {",
"    //short cuircuit return",
"    return bd.notFound;",
"  }",
"  callback= fixCallback(arguments, 2, true);",
"  for (var p in hash) {",
"    if (predicate(hash[p], p, hash)) {",
"      return callback ? callback(hash[p], p, hash) : p;",
"    }",
"  }",
"  return bd.notFound;",
"};",
"",
"bd.someHash= function(",
"  hash,     ///(hash) The hash to inspect.",
"  predicate,///(bd.hashPredicate) Returns true when applied to target item.",
"  context,  ///(object, optional) Context in which to apply predicate.",
"  vargs     ///(variableArgs, optional) Zero or more arguments for application of predicate.",
") {",
"  ///",
"  // Returns true if some item in hash satisfies predicate; false otherwise.",
"  ///",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before proceeding.",
"  if (!hash) {",
"    //short cuircuit return",
"    return false;",
"  }",
"  return bd.findHash(hash, fixCallback(arguments, 1, true))!==bd.notFound;",
"};",
"",
"bd.everyHash= function(",
"  hash,      ///(hash) The hash to inspect.",
"  predicate,///(bd.hashPredicate) Returns true when applied to target item.",
"  context,  ///(object, optional) Context in which to apply predicate.",
"  vargs     ///(variableArgs, optional) Zero or more arguments for application of predicate.",
") {",
"  ///",
"  // Returns true if every item in hash satisfies predicate; false otherwise.",
"  ///",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before proceeding.",
"  if (!hash) {",
"    //short cuircuit return",
"    return false;",
"  }",
"  predicate= fixCallback(arguments, 1, true);",
"  for (var p in hash) {",
"    if (!predicate(hash[p], p, hash)) {",
"      return false;",
"    }",
"  }",
"  return true;",
"};",
"",
"bd.keysOf= function(",
"  hash,    ///(hash) The hash to inspect.",
"  target,  ///(any) The target to find via operator ===.",
"  callback,///(bd.hashCallbackFunction, optional) The function to apply to found item (if any).",
"  context, ///(object, optional) Context in which to apply callback.",
"  vargs    ///(variableArgs, optional) Zero or more arguments for application of callback.",
") {",
"  ///",
"  // Searches for the hash for all items that satisfies target and returns the associated keys.",
"  ///",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before proceeding.",
"  ///",
"  // If a callback is given, then the callback is applied to each match found.",
"  bd.docGen(\"overload\",",
"    function(",
"      hash,",
"      callback   ///(string) Source text of a callback function.",
"    ) {",
"      ///",
"      // As above except that callback is taken as",
"      //code",
"      // new Function(\"item\", \"index\", \"array\", callback)",
"    }",
"  );",
"  if (!hash) {",
"    //short cuircuit return",
"    return [];",
"  }",
"  callback= fixCallback(arguments, 2, true);",
"  var keys= [];",
"  for (var p in hash) {",
"    if (hash[p]===target) {",
"      keys.push(p);",
"      callback && callback(hash[p], p, hash);",
"    }",
"  }",
"  return keys;",
"};",
"",
"",
"bd.filterHash= function(",
"  hash,    ///(hash) The hash to iterate.",
"  callback,///(bd.hashCallbackFunction) The predicate that filters.",
"  context, ///(object, optional) Context in which to apply callback.",
"  vargs    ///(variableArgs, optional) Zero or more arguments for application of callback.",
") {",
"  ///",
"  // Creates a new hash that contains all items in hash that satisfy callback.",
"  ///",
"  // If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before proceeding.",
"  bd.docGen(\"overload\",",
"    function(",
"      hash,",
"      callback   ///(string) Source text of a callback function.",
"    ) {",
"      ///",
"      // As above except that callback is taken as",
"      //code",
"      // new Function(\"item\", \"index\", \"array\", callback)",
"    }",
"  );",
"  if (!hash) {",
"    //short cuircuit return",
"    return {};",
"  }",
"  callback= fixCallback(arguments, 1, true);",
"  var result= {};",
"  for (var p in hash) {",
"    if (callback(hash[p], p, hash)) {",
"      result[p]= hash[p];",
"    }",
"  };",
"  return result;",
"};",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.collectionCallback":{
type:
Tfunction,
sdoc:
["Function signature expected by several collection functions that iterate of a collection."],
ldoc:
["collection[offset]===item is guaranteed true.",
"Side effects and return semantics as given by client-code and the particular collection function."],
flags:
[Ffunction],
params:
[["item",[["any",
["The current item in collection"]]]],
["offset",[["integer",
["If collection is an array, the current offset of item in collection."]],
["string",
["If collection is an object, the property name at which item resides."]]]],
["collection",[["array or hash",
["The collection."]]]]],
src:
"bd/collections",
loc: [8,2,22,3],
module:"bd/collections"}
,"bd.collectionPredicate":{
type:
Tfunction,
sdoc:
["Function signature expected by several collection functions that search for\nan item in a collection. "],
ldoc:
["Function signature expected by several collection functions that search for\nan item in a collection. The function must return true if item is the target item; false otherwise.",
"collection[offset]===item is guaranteed true."],
flags:
[Ffunction],
params:
[["item",[["any",
["The current item in collection"]]]],
["offset",[["integer",
["If collection is an array, the current offset of item in collection."]],
["string",
["If collection is an object, the property name at which item resides."]]]],
["collection",[["array or hash",
["The collection."]]]]],
src:
"bd/collections",
loc: [24,2,37,3],
module:"bd/collections"}
,"bd.collectionOrder":{
type:
Tfunction,
sdoc:
["Function signature expected by bd.binarySearch; returns the relative order of an item to a target."],
ldoc:
[],
flags:
[Ffunction],
params:
[["item",[["any",
["The item to test."]]]]],
returns:
[["-1",
["item is less than target."]],
["0",
["item is equal to target."]],
["1",
["item is greater than target."]]],
src:
"bd/collections",
loc: [39,2,51,3],
module:"bd/collections"}
,"bd.hasNative":{
type:
Tfunction,
sdoc:
["Returns true iff collection contains the method methodName."],
ldoc:
["This can be used to turn off usage of built-in collection functions (e.g. Array.forEach) as\nwell as during unit testing of the collections module."],
params:
[["collection",[["any",
["The collection to test."]]]],
["methodName",[["string",
["The method name to test."]]]]],
src:
"bd/collections",
loc: [65,0,75,1],
module:"bd/collections"}
,"bd.forEach":{
type:
Tfunction,
sdoc:
["Applies callback to each item in the collection."],
ldoc:
["If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function\nreturns without executing any processing.\n\nIf context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.\n\nThe function delegates to collection.forEach if the collection contains the method forEach. Note in particular\nthat Array.forEach will be used in environments that define that function. Otherwise,\niterate from front to back over each item in the collection.",
[NOTE,"See [JavaScript 1.5 Array forEach specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/forEach)."]],
params:
[["collection",[["bd.collection",
["The collection to iterate."]]]],
["callback",[["bd.collectionCallback",
["Function to apply to each item in the collection."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["As above except that callback is taken as"],
ldoc:
[[CODE,"new Function(\"item\", \"index\", \"array\", callback)"]],
params:
[["collection",[]],
["callback",[["string",
["Source text of a callback function."]]]]],
loc: [97,4,105,5]}
],
src:
"bd/collections",
loc: [77,0,119,1],
module:"bd/collections"}
,"bd.map":{
type:
Tfunction,
sdoc:
["Returns the array of results of applying callback to each item in collection."],
ldoc:
["If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function\nreturns an empty array without executing any processing.\n\nIf context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.\n\nThe function delegates to collection.map if the collection contains the method map. Note in particular\nthat Array.map will be used in environments that define that function. Otherwise,\niterate from front to back over each item in the collection.",
[NOTE,"See [JavaScript 1.5 Array map specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/map)."]],
params:
[["collection",[["bd.collection",
["The collection to iterate."]]]],
["callback",[["bd.collectionCallback",
["Function to apply to each item in the collection."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["As above except that callback is taken as"],
ldoc:
[[CODE,"new Function(\"item\", \"index\", \"array\", callback)"]],
params:
[["collection",[]],
["callback",[["string",
["Source text of a callback function."]]]]],
loc: [141,4,149,5]}
],
src:
"bd/collections",
loc: [121,0,164,1],
module:"bd/collections"}
,"bd.findFirst":{
type:
Tfunction,
sdoc:
["Searches for the first item that satisfies predicate."],
ldoc:
["Returns the index (if no callback is provided) or the result of the callback (if a callback is provided)\nof the first item in collection that satisfies the predicate (if such an item\nexists); otherwise, when no item satsifies the predicate, the callback (if any) is not called and -1 is returned.\n\nIf collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function\nreturns -1 immediately without executing any processing.\n\nIf context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.\n\nThe function delegates to collection.findFirst if the collection contains the method findFirst.\n\nSeaching starts at index start (if start>0), at index length+start (if start<0),\nor 0 (if start is 0 or missing) and proceeds front-to-back."],
params:
[["collection",[["bd.collection",
["The collection to inspect."]]]],
["predicate",[["bd.collectionPredicate",
["Returns true when applied to target item."]]]],
["start",[["positive integer, optional, 0",
["search begining with start; ignored if collection is not an array."]]]],
["callback",[["bd.collectionCallback, optional",
["The function to apply to found item (if any)."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of predicate."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["As above except that callback is taken as"],
ldoc:
[[CODE,"new Function(\"item\", \"index\", \"array\", callback)"]],
params:
[["collection",[]],
["predicate",[]],
["start",[]],
["callback",[["string",
["Source text of a callback function."]]]]],
loc: [199,4,209,5]}
],
returns:
[["any",
["callback(item, index, collection)",
[CASE,"item matches at index and callback is given."]]],
["integer",
["offset of match into collection of match",
[CASE,"match is found and collection is an array"]]],
["-1",
[[CASE,"no item satisfies predicate or collection is falsy"]]]],
src:
"bd/collections",
loc: [166,0,231,1],
module:"bd/collections"}
,"bd.some":{
type:
Tfunction,
sdoc:
["Returns true if some item in collection satisfies predicate; false otherwise."],
ldoc:
["If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function\nreturns false immediately without executing any processing.\n\nIf context is given, then the predicate is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.\n\nThe function delegates to collection.some if the collection contains the method some. Note in particular\nthat Array.some will be used in environments that define that function. Otherwise,\niterate from front to back over each item in the collection until predicate is satisfied or the array is\nexhausted",
[NOTE,"See [JavaScript 1.5 Array some specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/some)."]],
params:
[["collection",[["bd.collection",
["The collection to inspect."]]]],
["predicate",[["bd.collectionPredicate",
["Returns true when applied to target item."]]]],
["context",[["object, optional",
["Context in which to apply predicate."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of predicate."]]]]],
src:
"bd/collections",
loc: [235,0,261,1],
module:"bd/collections"}
,"bd.every":{
type:
Tfunction,
sdoc:
["Returns true if every item in collection satisfies predicate; false otherwise."],
ldoc:
["If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function\nreturns false immediately without executing any processing.\n\nIf context is given, then the predicate is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.\n\nThe function delegates to collection.every if the collection contains the method every. Note in particular\nthat Array.every will be used in environments that define that function. Otherwise,\niterate from front to back, until predicate is not satisfied or the array is exhausted.",
[NOTE,"See [JavaScript 1.5 Array every specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/every)."]],
params:
[["collection",[["collection",
["The collection to inspect."]]]],
["predicate",[["bd.collectionPredicate",
["Returns true when applied to target item."]]]],
["context",[["object, optional",
["Context in which to apply predicate."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of predicate."]]]]],
src:
"bd/collections",
loc: [263,0,296,1],
module:"bd/collections"}
,"bd.indexOf":{
type:
Tfunction,
sdoc:
["Searches from front to back for the first item===target."],
ldoc:
["If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function\nreturns -1 immediately without executing any processing.\n\nIf context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.\n\nThe function delegates to collection.indexOf if the collection contains the method indexOf. Note in particular\nthat Array.indexOf will be used in environments that define that function. Otherwise,\niterate as implied by start to the back of the collection until an item===target or the array is exhausted.\n\nSeaching starts at index start (if start>0), at index length+start (if start<0),\nor 0 (if start is 0 or missing) and proceeds front-to-back.",
[NOTE,"See [JavaScript 1.5 Array indexOf specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/indexOf)."]],
params:
[["collection",[["bd.collection",
["The collection to inspect."]]]],
["target",[["any",
["The target to find via operator ===."]]]],
["start",[["integer, optional, 0",
["Index to start search at."]]]],
["callback",[["bd.collectionCallback, optional",
["The function to apply to found item (if any)."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["As above except that callback is taken as"],
ldoc:
[[CODE,"new Function(\"item\", \"index\", \"array\", callback)"]],
params:
[["collection",[]],
["callback",[["string",
["Source text of a callback function."]]]]],
loc: [330,4,338,5]}
],
returns:
[["integer",
["index of first item===target",
[CASE,"an item is found such that item===target"]]],
["-1",
[[CASE,"no item is found such that item===target or collection was falsy"]]]],
src:
"bd/collections",
loc: [298,0,363,1],
module:"bd/collections"}
,"bd.lastIndexOf":{
type:
Tfunction,
sdoc:
["Searches from back-to-front for the first item===target."],
ldoc:
["If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function\nreturns -1 immediately without executing any processing.\n\nIf context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.\n\nThe function delegates to collection.lastIndexOf if the collection contains the method lastIndexOf. Note in particular\nthat Array.lastIndexOf will be used in environments that define that function. Otherwise,\niterate as implied by start to the front of the collection until an item===target or the array is exhausted.\n\nSeaching starts at index start (if start>0), at index length+start (if start<0),\nor 0 (if start is 0 or missing) and proceeds front-to-back.",
[NOTE,"See [JavaScript 1.5 Array lastIndexOf specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/lastIndexOf)."]],
params:
[["collection",[["bd.collection",
["The collection to iterate."]]]],
["target",[["any",
["the target to find via operator ===."]]]],
["start",[["integer, optional, 0",
["Index to start search at."]]]],
["callback",[["bd.collectionCallback, optional",
["The function to apply to found item (if any)."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["As above except that callback is taken as"],
ldoc:
[[CODE,"new Function(\"item\", \"index\", \"array\", callback)"]],
params:
[["collection",[]],
["callback",[["string",
["Source text of a callback function."]]]]],
loc: [397,4,405,5]}
],
returns:
[["integer",
["index of first item===target",
[CASE,"an item is found such that item===target"]]],
["-1",
[[CASE,"no item is found such that item===target or collection was falsy"]]]],
src:
"bd/collections",
loc: [365,0,430,1],
module:"bd/collections"}
,"bd.filter":{
type:
Tfunction,
sdoc:
["Creates an array that contains all items in collection that satisfy callback."],
ldoc:
["If collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function\nreturns an empty array immediately without executing any processing.\n\nIf context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.\n\nThe function delegates to collection.filter if the collection contains the method filter. Note in particular\nthat Array.filter will be used in environments that define that function. Otherwise,\niterate from front to back over each item in the collection.",
[NOTE,"See [JavaScript 1.5 Array filter specification](https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter)."]],
params:
[["collection",[["bd.collection",
["The collection to iterate."]]]],
["callback",[["bd.collectionCallback",
["The predicate that filters."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["As above except that callback is taken as"],
ldoc:
[[CODE,"new Function(\"item\", \"index\", \"array\", callback)"]],
params:
[["collection",[]],
["callback",[["string",
["Source text of a callback function."]]]]],
loc: [452,4,460,5]}
],
src:
"bd/collections",
loc: [432,0,477,1],
module:"bd/collections"}
,"bd.doTimes":{
type:
Tfunction,
sdoc:
["Apply callback to range of integers."],
ldoc:
["If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.\n\nIf range is an integer, then range is [0..n-1]; otherwise range is [n[0]..n[1]-1]."],
params:
[["range",[["integer",
["End point of range to apply callback; 0 is implied for start."]],
["array [start, end]",
["Range to apply callback."]]]],
["callback",[["function(index)",
["Function to apply to each integer in range."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
src:
"bd/collections",
loc: [479,0,501,1],
module:"bd/collections"}
,"bd.back":{
type:
Tfunction,
sdoc:
["Returns the last element of an array."],
ldoc:
[],
params:
[["collection",[["array",
["The array from which to return the last element."]]]]],
returns:
[["any",
["collection[collection.length-1]",
[CASE,"collection.length > 0"]]],
["undefined",
[[CASE,"collection.length==0"]]]],
src:
"bd/collections",
loc: [503,0,517,1],
module:"bd/collections"}
,"bd.binarySearch":{
type:
Tfunction,
sdoc:
["Finds a target item in an ordered array using a binary search algorithm. "],
ldoc:
["Finds a target item in an ordered array using a binary search algorithm. \nIf collection is falsy (e.g., an undefined variable, 0, false, or null was passed), then the function\nreturns immediately without executing any processing.",
[WARN,"The array must be ordered."]],
params:
[["collection",[["array",
["The array to search."]]]],
["comp",[["bd.collectionOrder",
["Compares an element of collection to the item being sought."]]]]],
returns:
[["integer",
["Index of target item.",
[CASE,"comp return 0 for some item."],
"bd.notFound",
[CASE,"comp failed to return 0 for any item."]]]],
src:
"bd/collections",
loc: [519,0,555,1],
module:"bd/collections"}
,"bd.lengthHash":{
type:
Tfunction,
sdoc:
["Returns the number of elements in hash."],
ldoc:
[],
params:
[["hash",[["hash",
["The hash to check."]],
["falsy",
["Return 0"]]]]],
returns:
[["integer",
["The number of elements contained in hash."]],
["0",
["The hash has no elements or is falsy."]]],
src:
"bd/collections",
loc: [558,0,573,1],
module:"bd/collections"}
,"bd.isEmptyHash":{
type:
Tfunction,
sdoc:
["Determines if hash contains any elements."],
ldoc:
[],
params:
[["hash",[["hash",
["The hash to check."]],
["falsy",
["Implies an empty hash."]]]]],
returns:
[["false",
["The hash contains at least one element."]],
["true",
["The hash contains elements or is falsy."]]],
src:
"bd/collections",
loc: [575,0,592,1],
module:"bd/collections"}
,"bd.forEachHash":{
type:
Tfunction,
sdoc:
["Applies callback to each item in the hash."],
ldoc:
["If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration.",
[WARN,"Behavior of the function is undefined if the hash is modified in the callback. If you\nthe callback semantics modify the hash, use bd.forEachHashSafe."]],
params:
[["hash",[["hash",
["The hash to iterate."]]]],
["callback",[["bd.hashCallbackFunction",
["Function to apply to each item in the hash."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["As above except that callback is taken as"],
ldoc:
[[CODE,"new Function(\"item\", \"index\", \"array\", callback)"]],
params:
[["hash",[]],
["callback",[["string",
["Source text of a callback function."]]]]],
loc: [608,4,616,5]}
],
src:
"bd/collections",
loc: [594,0,626,1],
module:"bd/collections"}
,"bd.forEachHashSafe":{
type:
Tfunction,
sdoc:
["Applies callback to each item in the hash; the hash may be modified in the callback.  "],
ldoc:
["Applies callback to each item in the hash; the hash may be modified in the callback.  An\nattempt is made to call every key that exists in the hash upon entry. No attempt is made\nto call keys added by callbacks.",
"If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration."],
params:
[["hash",[["hash",
["The hash to iterate."]]]],
["callback",[["bd.hashCallbackFunction",
["Function to apply to each item in the hash."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["As above except that callback is taken as"],
ldoc:
[[CODE,"new Function(\"item\", \"index\", \"array\", callback)"]],
params:
[["hash",[]],
["callback",[["string",
["Source text of a callback function."]]]]],
loc: [642,4,650,5]}
],
src:
"bd/collections",
loc: [629,0,665,1],
module:"bd/collections"}
,"bd.mapHash":{
type:
Tfunction,
sdoc:
["Returns the array of results of applying callback to each item in hash."],
ldoc:
["If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before iteration."],
params:
[["hash",[["hash",
["The hash to iterate."]]]],
["callback",[["bd.hashCallbackFunction",
["Function to apply to each item in the hash."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["As above except that callback is taken as"],
ldoc:
[[CODE,"new Function(\"item\", \"index\", \"array\", callback)"]],
params:
[["hash",[]],
["callback",[["string",
["Source text of a callback function."]]]]],
loc: [678,4,686,5]}
],
src:
"bd/collections",
loc: [667,0,698,1],
module:"bd/collections"}
,"bd.findHash":{
type:
Tfunction,
sdoc:
["Searches for the first item that satisfies predicate."],
ldoc:
["Returns the key (if no callback is provided) or the result of the callback (if a callback is provided)\nof the first item in hash that satisfies the predicate (if such an item\nexists); otherwise, when no item satsifies the predicate, the callback (if any) is not called and bd.notFound is returned.\n\nIf context and any vargs are given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before proceeding as described next."],
params:
[["hash",[["hash",
["The hash to inspect."]]]],
["predicate",[["bd.hashTargetPredicate",
["Returns true when applied to target item."]]]],
["callback",[["bd.hashCallbackFunction, optional",
["The function to apply to found item."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["As above except that callback is taken as"],
ldoc:
[[CODE,"new Function(\"item\", \"index\", \"array\", callback)"]],
params:
[["hash",[]],
["predicate",[]],
["start",[]],
["callback",[["string",
["Source text of a callback function."]]]]],
loc: [726,4,736,5]}
],
returns:
[["any",
["callback(item, key, hash)",
[CASE,"item matches at key and callback is given."]]],
["key",
["the property name of the match",
[CASE,"match is found at hash[key]"]]],
["bd.notFound",
[[CASE,"no match is found or hash is falsy"]]]],
src:
"bd/collections",
loc: [700,0,749,1],
module:"bd/collections"}
,"bd.someHash":{
type:
Tfunction,
sdoc:
["Returns true if some item in hash satisfies predicate; false otherwise."],
ldoc:
["If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before proceeding."],
params:
[["hash",[["hash",
["The hash to inspect."]]]],
["predicate",[["bd.hashPredicate",
["Returns true when applied to target item."]]]],
["context",[["object, optional",
["Context in which to apply predicate."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of predicate."]]]]],
src:
"bd/collections",
loc: [751,0,766,1],
module:"bd/collections"}
,"bd.everyHash":{
type:
Tfunction,
sdoc:
["Returns true if every item in hash satisfies predicate; false otherwise."],
ldoc:
["If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before proceeding."],
params:
[["hash",[["hash",
["The hash to inspect."]]]],
["predicate",[["bd.hashPredicate",
["Returns true when applied to target item."]]]],
["context",[["object, optional",
["Context in which to apply predicate."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of predicate."]]]]],
src:
"bd/collections",
loc: [768,0,789,1],
module:"bd/collections"}
,"bd.keysOf":{
type:
Tfunction,
sdoc:
["Searches for the hash for all items that satisfies target and returns the associated keys."],
ldoc:
["If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before proceeding.",
"If a callback is given, then the callback is applied to each match found."],
params:
[["hash",[["hash",
["The hash to inspect."]]]],
["target",[["any",
["The target to find via operator ===."]]]],
["callback",[["bd.hashCallbackFunction, optional",
["The function to apply to found item (if any)."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["As above except that callback is taken as"],
ldoc:
[[CODE,"new Function(\"item\", \"index\", \"array\", callback)"]],
params:
[["hash",[]],
["callback",[["string",
["Source text of a callback function."]]]]],
loc: [805,4,813,5]}
],
src:
"bd/collections",
loc: [791,0,828,1],
module:"bd/collections"}
,"bd.filterHash":{
type:
Tfunction,
sdoc:
["Creates a new hash that contains all items in hash that satisfy callback."],
ldoc:
["If context is given, then the callback is transformed into `bd.hitch(callback, context, arg1, arg2, ...)` before proceeding."],
params:
[["hash",[["hash",
["The hash to iterate."]]]],
["callback",[["bd.hashCallbackFunction",
["The predicate that filters."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["As above except that callback is taken as"],
ldoc:
[[CODE,"new Function(\"item\", \"index\", \"array\", callback)"]],
params:
[["hash",[]],
["callback",[["string",
["Source text of a callback function."]]]]],
loc: [842,4,850,5]}
],
src:
"bd/collections",
loc: [831,0,864,1],
module:"bd/collections"}
,"modules.bd/collections":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with several functions that operate on collections."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load the module bd. See module.bd."]],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/collections",
loc: [0,0,866,2]}
,"resources.bd/command/namespace":{
type:
Tresource,
sdoc:
["Defines the module bd/command/namespace"],
src:
"bd/command/namespace",
modules:
["bd/command/namespace"],
code:
["dojo.def(\"bd/command/namespace\", [\"bd\"], function(bd) {",
"///",
"// Augments the bd namespace with the bd.command namespace.",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load one or more of the bd/command/accelerators,",
"// bd/command/dispatch, or bd/command/item modules.  See module.bd.command.acclerators, module.bd.command.dispatch,",
"// module.bd.command.item.",
"",
"bd.command=",
"  ///namespace",
"  // Contains the Backdraft command machinery.",
"  bd.command || {};",
"",
"return bd.command;",
"",
"});"]}
,"bd.command":{
type:
Tnamespace,
sdoc:
["Contains the Backdraft command machinery."],
ldoc:
[],
src:
"bd/command/namespace",
loc: [9,0,12,18],
module:"bd/command/namespace"}
,"modules.bd/command/namespace":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with the bd.command namespace."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load one or more of the bd/command/accelerators,\nbd/command/dispatch, or bd/command/item modules.  See module.bd.command.acclerators, module.bd.command.dispatch,\nmodule.bd.command.item."]],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/command/namespace",
loc: [0,0,16,2]}
,"resources.bd/command/accelerators":{
type:
Tresource,
sdoc:
["Defines the module bd/command/accelerators"],
src:
"bd/command/accelerators",
modules:
["bd/command/accelerators"],
docLocs:
[[107,114],[34,54]],
code:
["dojo.def(\"bd/command/accelerators\", [",
"  \"dojo\", \"dijit\", \"bd\", \"bd/command/namespace\",",
"  \"bd/collections\",",
"  \"bd/command/item\",",
"  \"bd/command/dispatch\"",
"], function(dojo, dijit, bd, command) {",
"///",
"// Augments the bd.command namespace with the Backdraft keyboard accelerator machinery.",
"",
"bd.command.accelStates= {",
"  ///enum",
"  // The possible states of the accelerator machinery.",
"",
"  active:",
"    ///",
"    //(0) The accelerator machinery is active.",
"    0,",
"",
"  suspendedOnce:",
"    ///",
"    //(1)The accelerator machinery is suspended for one keydown, keypress, ..., keypress, keyup sequence.",
"    1,",
"",
"  suspendedOnceNeedKeyup:",
"    ///",
"    //(2) The accelerator machinery is on some keypress event during a suspended keydown, keypress, ..., keypress, keyup sequence.",
"    2,",
"",
"  suspended:",
"    ///",
"    //(3) The accelerator machinery is suspended.",
"    3",
"};",
"",
"bd.docGen(\"bd.command\", {",
"  accelTable:",
"    ///type",
"    // Map from keyboard event information to bd.command.id. // The map is a two-dimensional hash given by ",
"    // {(single character or key code) --> {bd.command.shiftState --> bd.command.id}}",
"    ///",
"    // If the key is a single-character, then a keypress event matching that character is processed; if the key is",
"    // a key code, then a keydown event matching the key code is processed. In either case, when a keypress or keydown event is processed,",
"    // if the shift state associated with the event matches an entry in the accelTable item that triggered",
"    // the processing, then that command identifier is dispatched. For example, the following map entries",
"    // cause `command1`, `command2`, or `command3` to be dispatched when a control-a, alt-a, or B is noticed on a",
"    // keydown, keydown, or keyPress event, respectively.",
"    //code",
"    // map[65]= {\"xCx\":\"command1\", \"xxA\":\"command2\"}",
"    // map[\"B\"]= {\"xxx\":\"command3\"}",
"    //note",
"    // Since a keypress event incorporates the shift state in th `keyChar` property of the even object (e.g., shift-\"a\" is ",
"    // causes `keyChar` to hold \"A\") the accelerator machinery design requires the shift state key to be \"xxx\" for ",
"    // keypress-generated accelerators as in the example above.",
"    bd.nodoc",
"});",
"",
"bd.mix(bd.command, {",
"  accelTables:",
"    ///",
"    // (array of bd.command.accelTable) The stack of pushed accelerator tables.",
"    [],",
"",
"  activeAccelTable:",
"    ///",
"    // (bd.command.accelTable) The current accelerator table.",
"    {},",
"",
"  pushAccels: function(",
"    ids ///(array of bd.command.id) The commands to insert into the new table.",
"  ) {",
"    ///",
"    //  Saves the current accelerator table, creates a new table, and initializes it with the accelerators given by ids. //Use ",
"    // bd.command.popAccels to restore the saved table.",
"    this.accelTables.push(this.activeAccelTable);",
"    this.activeAccelTable= {};",
"    bd.forEach(ids, function(id) {",
"      this.insertAccel(id);",
"    }, this);",
"  },",
"",
"  pushAccelTable: function(",
"    ids ///(bd.command.accelTable) The new table to make active.",
"  ) {",
"    ///",
"    // Saves the current accelerator table, and makes the passed table the new table. //Use ",
"    // bd.command.popAccels to restore the saved table.",
"    this.accelTables.push(this.activeAccelTable);",
"    this.activeAccelTable= ids;",
"  },",
"",
"  popAccels: function() {",
"    ///",
"    // Replaces the current accelerator table with the table previously pushed by bd.command.pushAccelerators.",
"    var result= this.activeAccleratorTable;",
"    this.activeAccelTable= this.accelTables.pop();",
"    return result; // the previously active accelerator table",
"  },",
"",
"  insertAccel: function(",
"    id,        ///(bd.command.id) References the command to execute upon detection of accelerator.",
"    keyCodeOrKeyChar, ///(integer or char) A scan code or a single character that identifies the accelerator key.",
"    shiftState,       ///(bd.command.shiftState, optional, \"\") The shift state associated with keyCodeOrKeyChar.",
"    table             ///(bd.command.accelTable, optional, bd.command.activeAccelTable) The table in which to insert the accelerator.",
"  ) {",
"    ///",
"    //  Inserts an accelerator into table. //If/when the table is active, pressing the keyboard chord given by (keyCodeOrKeyChar, shiftState)",
"    // causes `bd.command.dispatchCommand(id, null, dijit._activeStack, e)` to be applied (`e` is the keyboard event).",
"    bd.docGen(\"overload\",",
"      function(",
"        id ///(bd.command.id) The command item given by `bd.command.get(id)` gives accelerator parameters.",
"      ) {",
"        ///",
"        // Syntactic sugar for bd.insertAccel(id, bd.command.getItem(id).accelKey, bd.command.getItem(id).accelShift)`.",
"      }",
"    );",
"",
"    //figure out what was actually passed...",
"    if (arguments.length==1) {",
"      //nothing but id was provided",
"    } else if (keyCodeOrKeyChar && keyCodeOrKeyChar.constructor===Object) {",
"      //neither keyCodeOrKeyChar not shiftState were provided (keyCodeOrKeyChar is actually a table)",
"      table= keyCodeOrKeyChar;",
"      keyCodeOrKeyChar= null;",
"      shiftState= null;",
"    } else if (shiftState && shiftState.constructor===Object) {",
"      //shiftState was not provided (shiftState is actually a table)",
"      table= shiftState;",
"      shiftState= null;",
"    }",
"",
"    table= table || this.activeAccelTable;",
"    if (!keyCodeOrKeyChar) {",
"      var item= this.getItem(id);",
"      if (item) {",
"        bd.command.insertAccel(id, item.accelKey, item.accelShift, table);",
"      } else {",
"        console.error(\"id not found in bd.command.insertAccel\");",
"      }",
"    } else {",
"      if (shiftState && bd.isString(keyCodeOrKeyChar)) {",
"        // looking for a keyCode, not a charCode",
"        keyCodeOrKeyChar= keyCodeOrKeyChar.toUpperCase().charCodeAt(0);",
"      }",
"      var entry= (table[keyCodeOrKeyChar]= (table[keyCodeOrKeyChar] || {}));",
"      entry[this.getShiftStateKey(shiftState)]= id;",
"    }",
"  },",
"",
"  insertMenuAccels: function(",
"    menu ///(bd.menu) The menu to search for accelerators.",
"  ) {",
"    ///",
"    // Fully traverses menu and inserts the accelerator and for any command item found during the traversal that defines",
"    // an accelerator, insert that accelerator into the active accelerator table.",
"    var",
"      menuRole= bd.command.roles.menu,",
"      processItem= function(submenu, menuItemId) {",
"        var item= bd.command.getItem(menuItemId);",
"        if (item.accelKey) {",
"          bd.command.insertAccel(item.id, item.accelKey, item.accelShift);",
"        }",
"        if (item.role==menuRole) {",
"          bd.forEachHash(submenu, processItem);",
"        }",
"      };",
"    bd.forEachHash(menu, processItem);",
"  },",
"",
"  removeAccel: function(",
"    keyCodeOrKeyChar, ///(integer or char) A scan code or a single character that identifies the accelerator key.",
"    shiftState,       ///(bd.command.shiftState, optional, \"\") Any combination of \"shift\", \"control\", \"alt\", \"s\", \"c\", \"a\" and any other characters.",
"    table             ///(bd.command.accelTable, optional, bd.command.activeAccelTable) The table in which to insert the accelerator.",
"  ) {",
"    ///",
"    // Removes the given accelerator from the given table.",
"    if (!bd.isString(shiftState)) {",
"      //shiftState not provided (shiftState is actually a table)",
"      table= shiftState;",
"      shiftState= null;",
"    }",
"    table= table || this.activeAccelTable;",
"    var entry= (table[keyCodeOrKeyChar]= (table[keyCodeOrKeyChar] || {}));",
"    entry[this.getShiftStateKey(shiftState || \"\")]= 0;",
"  },",
"",
"  accelState:",
"    ///",
"    // (bd.command.accelStates) The current state of the accelerator machinery. //",
"    bd.command.accelStates.active,",
"",
"  suspendAccelOnce: function(",
"  ) {",
"    ///",
"    // Suspends the accelerator machinery for one keydown, keypress, ..., keypress, keyup sequence.",
"    this.accelState= this.accelStates.suspendedOnce;",
"  },",
"",
"  suspendAccels: function(",
"  ) {",
"    ///",
"    // Suspends the accelerator machinery until it is resumed with command.resumeAcclerators.",
"    this.accelState= this.accelStates.suspended;",
"  },",
"",
"  resumeAccels: function(",
"  ) {",
"    ///",
"    // Resumes the accelerator machinery after suspending with command.suspendAccels.",
"    this.accelState= this.accelStates.active;",
"  },",
"",
"  dispatchAccel: function(",
"    e ///(raw DOM event object) If the browser supports addEventListener",
"      //(undefined) If the browser is IE; find the event object at window.event",
"  ) {",
"    ///",
"    // Dispatches the id associated with the accelerator implied by e (if any), a keyboard event.",
"    ///",
"    // keydown, keypress, keyup DOM event handler that implements accelerators.",
"    // `warn",
"    // This function is automatically connected to the DOM keyboard events by the Backdraft framework and should",
"    // not be called directly.",
"    // `private",
"    e= dojo._event_listener._fixEvent(e || window.event);",
"",
"    //first handle the suspended states; relay on the fact that active is always zero",
"    if (this.accelState) {",
"      var state= this.accelState;",
"      if (state==this.accelStates.suspended) {",
"        //no-op",
"      } else if (this.accelState==this.accelStates.suspendedOnce && e.type===\"keydown\") {",
"        this.accelState= this.accelStates.suspendedOnceNeedKeyup;",
"      } else if (this.accelState==this.accelStates.suspendedOnceNeedKeyup && e.type===\"keyup\") {",
"        this.accelState= this.accelStates.active;",
"      }",
"      return;",
"    }",
"",
"    //not suspended...",
"    var entry, shift, commandId;",
"    if (e.type===\"keydown\") {",
"      entry= this.activeAccelTable[e.keyCode];",
"      shift= (e.shiftKey ? \"S\" : \"x\") + (e.ctrlKey ? \"C\" : \"x\") + (e.altKey ? \"A\" : \"x\");",
"    } else if (e.type===\"keypress\") {",
"      entry= this.activeAccelTable[e.keyChar];",
"      shift= \"xxx\";",
"    } else {",
"      return;",
"    }",
"    commandId= entry && entry[shift];",
"    if (commandId) {",
"      bd.command.dispatchCommand(commandId, null, dijit._activeStack, e);",
"    }",
"  }",
"});",
"",
"var accelDispatcher= bd.hitch(bd.command, \"dispatchAccel\");",
"",
"if (window.addEventListener) {",
"  //get all keyboard events during capturing thereby getting them at the earliest possible moment and",
"  //giving the best chance to the accel function to cancel any other handlers",
"  bd.doc.addEventListener(\"keydown\", accelDispatcher, true);",
"  bd.doc.addEventListener(\"keyup\", accelDispatcher, true);",
"  bd.doc.addEventListener(\"keypress\", accelDispatcher, true);",
"} else if (dojo.isIE) {",
"  // IE doesn\'t capture; therefore, each time the focus changes, attachEvent to the focused node.",
"  // This should have the same effect as above.",
"  var IEAttachedNode= bd.doc;",
"  bd.doc.attachEvent(\"onkeydown\", accelDispatcher);",
"  bd.doc.attachEvent(\"onkeyup\", accelDispatcher);",
"  bd.doc.attachEvent(\"onkeypress\", accelDispatcher);",
"",
"  bd.doc.attachEvent(\"onactivate\", function() {",
"    var node= window.event.srcElement;",
"    if (node===IEAttachedNode) {",
"      return;",
"    }",
"    if (IEAttachedNode) {",
"      IEAttachedNode.detachEvent(\"onkeydown\", accelDispatcher);",
"      IEAttachedNode.detachEvent(\"onkeyup\", accelDispatcher);",
"      IEAttachedNode.detachEvent(\"onkeypress\", accelDispatcher);",
"      IEAttachedNode= null;",
"    }",
"    if (node) {",
"      IEAttachedNode= node;",
"      node.attachEvent(\"onkeydown\", accelDispatcher);",
"      node.attachEvent(\"onkeyup\", accelDispatcher);",
"      node.attachEvent(\"onkeypress\", accelDispatcher);",
"    }",
"  });",
"}",
"",
"return bd.command;",
"",
"});",
"// Copyright (c) 2000-2009, ALTOVISO, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.command.accelStates":{
type:
Tenum,
sdoc:
["The possible states of the accelerator machinery."],
ldoc:
[],
props:
["active",{
type:
Tvariable,
loc: [16,4,16,5],
types:
[["0",
["The accelerator machinery is active."]]]}
,
"suspendedOnce",{
type:
Tvariable,
loc: [21,4,21,5],
types:
[["1",
["The accelerator machinery is suspended for one keydown, keypress, ..., keypress, keyup sequence."]]]}
,
"suspendedOnceNeedKeyup",{
type:
Tvariable,
loc: [26,4,26,5],
types:
[["2",
["The accelerator machinery is on some keypress event during a suspended keydown, keypress, ..., keypress, keyup sequence."]]]}
,
"suspended",{
type:
Tvariable,
loc: [31,4,31,5],
types:
[["3",
["The accelerator machinery is suspended."]]]}
],
src:
"bd/command/accelerators",
loc: [9,0,32,1],
module:"bd/command/accelerators"}
,"bd.command.accelTable":{
type:
Ttype,
sdoc:
["Map from keyboard event information to bd.command.id. "],
ldoc:
["Map from keyboard event information to bd.command.id.  The map is a two-dimensional hash given by\n{(single character or key code) --> {bd.command.shiftState --> bd.command.id}}",
"If the key is a single-character, then a keypress event matching that character is processed; if the key is\na key code, then a keydown event matching the key code is processed. In either case, when a keypress or keydown event is processed,\nif the shift state associated with the event matches an entry in the accelTable item that triggered\nthe processing, then that command identifier is dispatched. For example, the following map entries\ncause `command1`, `command2`, or `command3` to be dispatched when a control-a, alt-a, or B is noticed on a\nkeydown, keydown, or keyPress event, respectively.",
[CODE,"map[65]= {\"xCx\":\"command1\", \"xxA\":\"command2\"}\nmap[\"B\"]= {\"xxx\":\"command3\"}"],
[NOTE,"Since a keypress event incorporates the shift state in th `keyChar` property of the even object (e.g., shift-\"a\" is\ncauses `keyChar` to hold \"A\") the accelerator machinery design requires the shift state key to be \"xxx\" for\nkeypress-generated accelerators as in the example above."]],
src:
"bd/command/accelerators",
loc: [35,2,53,12],
module:"bd/command/accelerators"}
,"bd.command.accelTables":{
type:
Tvariable,
sdoc:
["(array of bd.command.accelTable) The stack of pushed accelerator tables."],
ldoc:
[],
src:
"bd/command/accelerators",
loc: [57,2,60,6],
module:"bd/command/accelerators"}
,"bd.command.activeAccelTable":{
type:
Tvariable,
sdoc:
["(bd.command.accelTable) The current accelerator table."],
ldoc:
[],
src:
"bd/command/accelerators",
loc: [62,2,65,6],
module:"bd/command/accelerators"}
,"bd.command.pushAccels":{
type:
Tfunction,
sdoc:
[" Saves the current accelerator table, creates a new table, and initializes it with the accelerators given by ids. "],
ldoc:
[" Saves the current accelerator table, creates a new table, and initializes it with the accelerators given by ids. Use\nbd.command.popAccels to restore the saved table."],
params:
[["ids",[["array of bd.command.id",
["The commands to insert into the new table."]]]]],
src:
"bd/command/accelerators",
loc: [67,2,78,3],
module:"bd/command/accelerators"}
,"bd.command.pushAccelTable":{
type:
Tfunction,
sdoc:
["Saves the current accelerator table, and makes the passed table the new table. "],
ldoc:
["Saves the current accelerator table, and makes the passed table the new table. Use\nbd.command.popAccels to restore the saved table."],
params:
[["ids",[["bd.command.accelTable",
["The new table to make active."]]]]],
src:
"bd/command/accelerators",
loc: [80,2,88,3],
module:"bd/command/accelerators"}
,"bd.command.popAccels":{
type:
Tfunction,
sdoc:
["Replaces the current accelerator table with the table previously pushed by bd.command.pushAccelerators."],
ldoc:
[],
src:
"bd/command/accelerators",
loc: [90,2,96,3],
module:"bd/command/accelerators"}
,"bd.command.insertAccel":{
type:
Tfunction,
sdoc:
[" Inserts an accelerator into table. "],
ldoc:
[" Inserts an accelerator into table. If/when the table is active, pressing the keyboard chord given by (keyCodeOrKeyChar, shiftState)\ncauses `bd.command.dispatchCommand(id, null, dijit._activeStack, e)` to be applied (`e` is the keyboard event)."],
params:
[["id",[["bd.command.id",
["References the command to execute upon detection of accelerator."]]]],
["keyCodeOrKeyChar",[["integer or char",
["A scan code or a single character that identifies the accelerator key."]]]],
["shiftState",[["bd.command.shiftState, optional, \"\"",
["The shift state associated with keyCodeOrKeyChar."]]]],
["table",[["bd.command.accelTable, optional, bd.command.activeAccelTable",
["The table in which to insert the accelerator."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Syntactic sugar for bd.insertAccel(id, bd.command.getItem(id).accelKey, bd.command.getItem(id).accelShift)`."],
ldoc:
[],
params:
[["id",[["bd.command.id",
["The command item given by `bd.command.get(id)` gives accelerator parameters."]]]]],
loc: [108,6,113,7]}
],
src:
"bd/command/accelerators",
loc: [98,2,146,3],
module:"bd/command/accelerators"}
,"bd.command.insertMenuAccels":{
type:
Tfunction,
sdoc:
["Fully traverses menu and inserts the accelerator and for any command item found during the traversal that defines\nan accelerator, insert that accelerator into the active accelerator table."],
ldoc:
[],
params:
[["menu",[["bd.menu",
["The menu to search for accelerators."]]]]],
src:
"bd/command/accelerators",
loc: [148,2,166,3],
module:"bd/command/accelerators"}
,"bd.command.removeAccel":{
type:
Tfunction,
sdoc:
["Removes the given accelerator from the given table."],
ldoc:
[],
params:
[["keyCodeOrKeyChar",[["integer or char",
["A scan code or a single character that identifies the accelerator key."]]]],
["shiftState",[["bd.command.shiftState, optional, \"\"",
["Any combination of \"shift\", \"control\", \"alt\", \"s\", \"c\", \"a\" and any other characters."]]]],
["table",[["bd.command.accelTable, optional, bd.command.activeAccelTable",
["The table in which to insert the accelerator."]]]]],
src:
"bd/command/accelerators",
loc: [168,2,183,3],
module:"bd/command/accelerators"}
,"bd.command.accelState":{
type:
Tvariable,
sdoc:
["(bd.command.accelStates) The current state of the accelerator machinery. "],
ldoc:
["(bd.command.accelStates) The current state of the accelerator machinery. "],
src:
"bd/command/accelerators",
loc: [185,2,188,33],
module:"bd/command/accelerators"}
,"bd.command.suspendAccelOnce":{
type:
Tfunction,
sdoc:
["Suspends the accelerator machinery for one keydown, keypress, ..., keypress, keyup sequence."],
ldoc:
[],
src:
"bd/command/accelerators",
loc: [190,2,195,3],
module:"bd/command/accelerators"}
,"bd.command.suspendAccels":{
type:
Tfunction,
sdoc:
["Suspends the accelerator machinery until it is resumed with command.resumeAcclerators."],
ldoc:
[],
src:
"bd/command/accelerators",
loc: [197,2,202,3],
module:"bd/command/accelerators"}
,"bd.command.resumeAccels":{
type:
Tfunction,
sdoc:
["Resumes the accelerator machinery after suspending with command.suspendAccels."],
ldoc:
[],
src:
"bd/command/accelerators",
loc: [204,2,209,3],
module:"bd/command/accelerators"}
,"bd.command.dispatchAccel":{
type:
Tfunction,
sdoc:
["Dispatches the id associated with the accelerator implied by e (if any), a keyboard event."],
ldoc:
["keydown, keypress, keyup DOM event handler that implements accelerators.",
[WARN,"This function is automatically connected to the DOM keyboard events by the Backdraft framework and should\nnot be called directly."]],
flags:
[Fprivate],
params:
[["e",[["raw DOM event object",
["If the browser supports addEventListener"]],
["undefined",
["If the browser is IE; find the event object at window.event"]]]]],
src:
"bd/command/accelerators",
loc: [211,2,253,3],
module:"bd/command/accelerators"}
,"modules.bd/command/accelerators":{
type:
Tmodule,
sdoc:
["Augments the bd.command namespace with the Backdraft keyboard accelerator machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["dijit",[]],
["bd",[]],
["command",[]]],
src:
"bd/command/accelerators",
loc: [0,0,294,2]}
,"resources.bd/command/dispatch":{
type:
Tresource,
sdoc:
["Defines the module bd/command/dispatch"],
src:
"bd/command/dispatch",
modules:
["bd/command/dispatch"],
docLocs:
[[82,91],[23,28]],
code:
["dojo.def(\"bd/command/dispatch\", [",
"  \"dojo\", \"dijit\", \"bd\", \"bd/command/namespace\",",
"  \"bd/async\"",
"], function(dojo, dijit, bd) {",
"///",
"// Augments the bd.command namespace with the Backdraft command dispatch machinery.",
"",
"var ",
"  hotContext= {",
"    cps: ",
"      // Array of no-op stub command handlers to dojo.connect one or more real handlers.",
"      {},",
"    handles:",
"      // Array of connections into this context",
"      []",
"  },",
"",
"  contexts= [hotContext],",
"",
"  dojoDisconnect= function(handle) {",
"    dojo.disconnect(handle);",
"  };",
"",
"bd.docGen(\"bd.command\", {",
"  context:",
"    ///type",
"    // (object) Simple container that holds a map of connection points at `cps` and connect handles at `handles`. See bd.command.hotContext.",
"    bd.nodoc",
"});",
"",
"dojo.mix (bd.command, {",
"  hotContext: ",
"    ///",
"    // (bd.command.context) The current active command context.",
"    ///",
"    // This variable controls connections between a bd.command.id and the handlers connected for that id. The first time a command handler",
"    // connects to some bd.command.id, say `cid`, via bd.command.connect, a single conection point is created at `hotContext.cps[cid]`. The connection",
"    // point is nothing more than than the function `function(){}`. With this in place, bd.connect is used to connect the connection point",
"    // to the handler. Subsequent handlers can also connect to the same connection point thus allowing a several handlers to be applied",
"    // when a single bd.command.id is dispatched. A bd.command.id is dispatched by applying the connection point associated with the id (i.e., executing",
"    // `hotContext.cps[cid]`). This should never be down directly, but rather through bd.command.dispatchCommand, bd.command.scheduleCommand, or,",
"    // as is usually the case, indirectly through a menu or accelerator.",
"    // ",
"    // When a command is connected, the handle returned by bd.connect is returned (see bd.connect). The Backdraft command machinery allows",
"    // the current hot context to be pushed and poped via bd.pushContext and bd.popContext. In order to ease the burden of disconnecting",
"    // handlers, each hotContext keeps a reference to all connection handles and when a hotContext is popped, automatically disconnects those",
"    // handles. Owing to the design of bd.connect, if client code decided to assume the responsibility of explicitly disconnecting, these",
"    // double-disconnects would result in a no-op. This design eases the burden of eliminating circular references and can improve the performance of the",
"    // JavaScript garbage collector.",
"    hotContext,",
"",
"  contexts: ",
"    ///",
"    // (array of bd.command.context) The stack of previously active command contexts.",
"    contexts,",
"",
"  pushContext: function() {",
"    ///",
"    // Saves the current bd.command.hotContext on a stack and creates a new, virgin hotContext. //The saved context",
"    // can be restored via bd.command.popContext.",
"    contexts.push(hotContext);",
"    hotContext= bd.command.hotContext= {cps:[], handles:[]};",
"  },",
"",
"  popContext: function() {",
"    ///",
"    // Restores a bd.command.hotContext previously save by bd.command.pushContext.",
"    bd.forEach(hotContext.handles, function(h) {",
"      h.disconnect();",
"    });",
"    hotContext= bd.command.hotContext= contexts.pop();",
"  },",
"",
"  connect: function(",
"    id,       ///(bd.command.id) The command that triggers the handler.",
"    callback, ///(bd.commandHandler) The function to apply when the command is dispatched.",
"    context,  ///(object, optional) Context in which to apply callback.",
"    vargs     ///(variableArgs, optional) Zero or more arguments for application of callback.",
"",
"  ) {",
"    ///",
"    // Causes bd.command.dispatchCommand to apply callback when command is dispatched.",
"    bd.docGen(\"overload\",",
"      function(",
"        hash ///(hash:bd.command.id --> bd.commandHandler or [callback, context, vargs]) A set of command (id, handler)s to connect",
"      ) {",
"        ///",
"        // Applies bd.command.connect(id, handler) for each (id, handler) in hash. If handler is an array, then",
"        // then bd.command.connect(id, handler[0], handler[1], handler[2], ..., handler[n]) is applied for id; otherwise",
"        // bd.command.connect(id, handler) is applied.",
"      }",
"    );",
"    var result;",
"    if (arguments.length==1) {",
"      result= {};",
"      bd.forEachHash(id, function(callback, id) {",
"        if (bd.isArray(callback)) {",
"          result[id]= bd.command.connect.apply(bd.command, [id].concat(callback));",
"        } else {",
"          result[id]= bd.command.connect(id, callback);",
"        }",
"    });",
"      return result;",
"    } else {",
"      if (!hotContext.cps[id]) {",
"        //stub for other connections",
"        //TODO: no way to take down the last fp if all connections are disconnected",
"        hotContext.cps[id]= function(){};",
"      }",
"      result= new bd.connect.handle(bd.command.connect, id, context, callback, dojo.connect(hotContext.cps, id, bd.hitchCallback(arguments, 1)), dojoDisconnect);",
"      hotContext.handles.push(result);",
"      return result;",
"    }",
"  },",
"",
"  createEvent: function(",
"    args ///(hash) Properties to mixin to the new bd.commandObject",
"  ) {",
"    ///",
"    // Returns a new bd.commandObject object initialized with default values and mixed with args.",
"    return dojo.mix({",
"      id:null,",
"      source:null,",
"      activeStack:dijit._activeStack,",
"      eventObject:null,",
"      stopEvent:true",
"    }, args);",
"  },",
"",
"  eventObject: {",
"    ///type",
"    // (hash) Describes the current command being dispached.",
"    ///",
"    // This object is passed to each command handler associated with a particular command whcn that command is dispatched. ",
"    // Note that it is perfectly acceptable for applications to add addtional properties to this object as the command is",
"    // dispatched to communicate additional state information between command handlers.",
"",
"    id:",
"      ///",
"      // (bd.command.id) The command being dispatched.",
"      bd.nodoc,",
"",
"    source:",
"      ///",
"      // (object) The widget (menu, context menu, toolbar, etc.) that caused the command to be executed; null if an accelerator.",
"      bd.nodoc,",
"",
"    activeStack:",
"      ///",
"      //(array of string) The active focus stack, as given by widget identifiers, at the time the command was issued.",
"      bd.nodoc,",
"",
"    eventObject:",
"      ///",
"      // (DOM.event) The event object that caused the command, if any.",
"      bd.nodoc,",
"",
"    stopEvent:",
"      ///",
"      // (boolean) Instructs the dispatcher to apply dojo.stopEvent on the eventObject at the completion of dispatching.",
"      bd.nodoc",
"  },",
"",
"  dispatchCommand: function(",
"    id,   ///(bd.command.id) The id property of the command item.",
"    source,      ///(object) The widget (menu, context menu, toolbar, etc.) that caused the command to be executed; null if an accelerator.",
"    activeStack, ///(array of string) The active focus stack, as given by widget identifiers, at the time the command was issued.",
"    eventObject  ///(DOM.event) The event object that caused the command, if any.",
"  ) {",
"    ///",
"    // Dispatches a command.",
"    ///",
"    // After creating a bd.command.eventObject (call this object `ceo`), the dispatching algorithm is given as follows:",
"    // ",
"    // 1. `dojo.publish(\"bdExecCommandStart\", [ceo])`",
"    // 2. Apply each connected command handler, passing `ceo`, in the order they were connected.",
"    // 3. `dojo.publish(\"bdExecCommandCapture\", [ceo])`",
"    // 4. Apply `execCommand` for each object in the active stack that defines `execCommand`, passing `ceo`, from the bottom of",
"    //    the stack to the top.",
"    // 4. `dojo.publish(\"bdExecCommandBubble\", [ceo])`",
"    // 5. Apply `execCommand` for each object in the active stack that defines `execCommand`, passing `ceo`, from the top of",
"    //    the stack to the bottom.",
"    // 6. `dojo.publish(\"bdExecCommandEnd\", [ceo])`",
"    //",
"    // Typically, this function is called automatically consequent to a menu selection of accelerator; however, is it perfectly",
"    // acceptable to explicitly dispatch a command through this function. In such cases, the arguments `source`, `activeStack`, and",
"    // `eventObject` can be constructed with semantics that make sense to the task at hand.",
"",
"    source= source || null;",
"    activeStack= activeStack || [];",
"    eventObject= eventObject || null;",
"    var commandEventObject= {",
"      id:id,",
"      source:source,",
"      activeStack:activeStack,",
"      eventObject:eventObject,",
"      stopEvent:true",
"    };",
"    dojo.publish(\"bdExecCommandStart\", [commandEventObject]);",
"    var fp= hotContext.cps[id];",
"    if (fp) {",
"      fp(commandEventObject);",
"    }",
"    dojo.publish(\"bdExecCommandCapture\", [commandEventObject]);",
"    var",
"      widget,",
"      i= 0,",
"      end= activeStack.length;",
"    for (; i<end; i++) {",
"      widget= dijit.byId(activeStack[i]);",
"      if (widget && widget.execCommand) {",
"        widget.execCommand(commandEventObject, \"capturing\");",
"      }",
"    }",
"    dojo.publish(\"bdExecCommandBubble\", [commandEventObject]);",
"    for (i= end; i--;) {",
"      widget= dijit.byId(activeStack[i]);",
"      if (widget && widget.execCommand) {",
"        widget.execCommand(commandEventObject, \"bubbling\");",
"      }",
"    }",
"    dojo.publish(\"bdExecCommandEnd\", [commandEventObject]);",
"    if (eventObject && commandEventObject.stopEvent) {",
"      dojo.stopEvent(eventObject);",
"    }",
"  },  ",
"",
"  asyncQ:",
"    ///",
"    // (array of bd.command.id) The asynchronous queue of commands pending execution.",
"    // `private",
"    [],",
"",
"  asynchDispatcher: function() {",
"    ///",
"    // Executes all the commands in the asynchronous command queue",
"    //note",
"    // Commands that are added to the asynchronous queue while executing commands in the asynchronous queue are executed under a different (later) asynchronous event.",
"    // `private",
"",
"    // other asynchronous commands me be added while processing the current queue; guarantee that these are processed in a different asynch event",
"    var queue= this.asyncQ;",
"    this.asyncQ= [];",
"    for (var i= 0, end= queue.length; i<end; i++) {",
"      var item= queue[i];",
"      try {",
"        bd.command.dispatchCommand(item.id, item.source, item.activeStack, item.eventObject);",
"      } catch (e) {",
"        console.debug(\"exception in bd.command.doCommand\", e);",
"      }",
"    }",
"  },",
"",
"  scheduleCommand: function(",
"    id,   ///(bd.command.id) The id property of the command item.",
"    source,      ///(object) The widget (menu, context menu, toolbar, etc.) that caused the command to be executed; null if an accelerator.",
"    activeStack, ///(array of string, optional, null) The active focus stack as given by widget identifiers at the time the command was issued.",
"    eventObject  ///(DOM.event, optional, null) The event object that caused the command, if any.",
"  ) {",
"    ///",
"    // Executes a command asynchronously. //Asynchronous command dispatch is useful",
"    // when you want the display to settle before executing a command (e.g., menus)",
"    bd.command.asyncQ.push({",
"      id:id,",
"      source:source||null,",
"      activeStack:activeStack||null,",
"      eventObject:eventObject||null",
"    });",
"    if (bd.command.asyncQ.length==1) {",
"      bd.async.schedule(\"last\", \"asynchDispatcher\", this);",
"    }",
"  }",
"});",
"",
"return bd.command;",
"",
"});",
"// Copyright (c) 2000-2009, ALTOVISO, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.command.context":{
type:
Ttype,
sdoc:
["(object) Simple container that holds a map of connection points at `cps` and connect handles at `handles`. See bd.command.hotContext."],
ldoc:
[],
src:
"bd/command/dispatch",
loc: [24,2,27,12],
module:"bd/command/dispatch"}
,"bd.command.hotContext":{
type:
Tvariable,
sdoc:
["(bd.command.context) The current active command context."],
ldoc:
["This variable controls connections between a bd.command.id and the handlers connected for that id. The first time a command handler\nconnects to some bd.command.id, say `cid`, via bd.command.connect, a single conection point is created at `hotContext.cps[cid]`. The connection\npoint is nothing more than than the function `function(){}`. With this in place, bd.connect is used to connect the connection point\nto the handler. Subsequent handlers can also connect to the same connection point thus allowing a several handlers to be applied\nwhen a single bd.command.id is dispatched. A bd.command.id is dispatched by applying the connection point associated with the id (i.e., executing\n`hotContext.cps[cid]`). This should never be down directly, but rather through bd.command.dispatchCommand, bd.command.scheduleCommand, or,\nas is usually the case, indirectly through a menu or accelerator.\n\nWhen a command is connected, the handle returned by bd.connect is returned (see bd.connect). The Backdraft command machinery allows\nthe current hot context to be pushed and poped via bd.pushContext and bd.popContext. In order to ease the burden of disconnecting\nhandlers, each hotContext keeps a reference to all connection handles and when a hotContext is popped, automatically disconnects those\nhandles. Owing to the design of bd.connect, if client code decided to assume the responsibility of explicitly disconnecting, these\ndouble-disconnects would result in a no-op. This design eases the burden of eliminating circular references and can improve the performance of the\nJavaScript garbage collector."],
src:
"bd/command/dispatch",
loc: [31,2,49,14],
module:"bd/command/dispatch"}
,"bd.command.contexts":{
type:
Tvariable,
sdoc:
["(array of bd.command.context) The stack of previously active command contexts."],
ldoc:
[],
src:
"bd/command/dispatch",
loc: [51,2,54,12],
module:"bd/command/dispatch"}
,"bd.command.pushContext":{
type:
Tfunction,
sdoc:
["Saves the current bd.command.hotContext on a stack and creates a new, virgin hotContext. "],
ldoc:
["Saves the current bd.command.hotContext on a stack and creates a new, virgin hotContext. The saved context\ncan be restored via bd.command.popContext."],
src:
"bd/command/dispatch",
loc: [56,2,62,3],
module:"bd/command/dispatch"}
,"bd.command.popContext":{
type:
Tfunction,
sdoc:
["Restores a bd.command.hotContext previously save by bd.command.pushContext."],
ldoc:
[],
src:
"bd/command/dispatch",
loc: [64,2,71,3],
module:"bd/command/dispatch"}
,"bd.command.connect":{
type:
Tfunction,
sdoc:
["Causes bd.command.dispatchCommand to apply callback when command is dispatched."],
ldoc:
[],
params:
[["id",[["bd.command.id",
["The command that triggers the handler."]]]],
["callback",[["bd.commandHandler",
["The function to apply when the command is dispatched."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Applies bd.command.connect(id, handler) for each (id, handler) in hash. If handler is an array, then\nthen bd.command.connect(id, handler[0], handler[1], handler[2], ..., handler[n]) is applied for id; otherwise\nbd.command.connect(id, handler) is applied."],
ldoc:
[],
params:
[["hash",[["hash:bd.command.id --> bd.commandHandler or [callback, context, vargs]",
["A set of command (id, handler)s to connect"]]]]],
loc: [83,6,90,7]}
],
src:
"bd/command/dispatch",
loc: [73,2,113,3],
module:"bd/command/dispatch"}
,"bd.command.createEvent":{
type:
Tfunction,
sdoc:
["Returns a new bd.commandObject object initialized with default values and mixed with args."],
ldoc:
[],
params:
[["args",[["hash",
["Properties to mixin to the new bd.commandObject"]]]]],
src:
"bd/command/dispatch",
loc: [115,2,127,3],
module:"bd/command/dispatch"}
,"bd.command.eventObject":{
type:
Ttype,
sdoc:
["(hash) Describes the current command being dispached."],
ldoc:
["This object is passed to each command handler associated with a particular command whcn that command is dispatched.\nNote that it is perfectly acceptable for applications to add addtional properties to this object as the command is\ndispatched to communicate additional state information between command handlers."],
props:
["id",{
type:
Tvariable,
sdoc:
["(bd.command.id) The command being dispatched."],
ldoc:
[],
loc: [140,6,140,14]}
,
"source",{
type:
Tvariable,
sdoc:
["(object) The widget (menu, context menu, toolbar, etc.) that caused the command to be executed; null if an accelerator."],
ldoc:
[],
loc: [145,6,145,14]}
,
"activeStack",{
type:
Tvariable,
loc: [150,6,150,14],
types:
[["array of string",
["The active focus stack, as given by widget identifiers, at the time the command was issued."]]]}
,
"eventObject",{
type:
Tvariable,
sdoc:
["(DOM.event) The event object that caused the command, if any."],
ldoc:
[],
loc: [155,6,155,14]}
,
"stopEvent",{
type:
Tvariable,
sdoc:
["(boolean) Instructs the dispatcher to apply dojo.stopEvent on the eventObject at the completion of dispatching."],
ldoc:
[],
loc: [160,6,160,14]}
],
src:
"bd/command/dispatch",
loc: [129,2,161,3],
module:"bd/command/dispatch"}
,"bd.command.dispatchCommand":{
type:
Tfunction,
sdoc:
["Dispatches a command."],
ldoc:
["After creating a bd.command.eventObject (call this object `ceo`), the dispatching algorithm is given as follows:\n\n1. `dojo.publish(\"bdExecCommandStart\", [ceo])`\n2. Apply each connected command handler, passing `ceo`, in the order they were connected.\n3. `dojo.publish(\"bdExecCommandCapture\", [ceo])`\n4. Apply `execCommand` for each object in the active stack that defines `execCommand`, passing `ceo`, from the bottom of\n   the stack to the top.\n4. `dojo.publish(\"bdExecCommandBubble\", [ceo])`\n5. Apply `execCommand` for each object in the active stack that defines `execCommand`, passing `ceo`, from the top of\n   the stack to the bottom.\n6. `dojo.publish(\"bdExecCommandEnd\", [ceo])`\n\nTypically, this function is called automatically consequent to a menu selection of accelerator; however, is it perfectly\nacceptable to explicitly dispatch a command through this function. In such cases, the arguments `source`, `activeStack`, and\n`eventObject` can be constructed with semantics that make sense to the task at hand."],
params:
[["id",[["bd.command.id",
["The id property of the command item."]]]],
["source",[["object",
["The widget (menu, context menu, toolbar, etc.) that caused the command to be executed; null if an accelerator."]]]],
["activeStack",[["array of string",
["The active focus stack, as given by widget identifiers, at the time the command was issued."]]]],
["eventObject",[["DOM.event",
["The event object that caused the command, if any."]]]]],
src:
"bd/command/dispatch",
loc: [163,2,225,3],
module:"bd/command/dispatch"}
,"bd.command.asyncQ":{
type:
Tvariable,
sdoc:
["(array of bd.command.id) The asynchronous queue of commands pending execution."],
ldoc:
[],
flags:
[Fprivate],
src:
"bd/command/dispatch",
loc: [227,2,231,6],
module:"bd/command/dispatch"}
,"bd.command.asynchDispatcher":{
type:
Tfunction,
sdoc:
["Executes all the commands in the asynchronous command queue"],
ldoc:
[[NOTE,"Commands that are added to the asynchronous queue while executing commands in the asynchronous queue are executed under a different (later) asynchronous event."]],
flags:
[Fprivate],
src:
"bd/command/dispatch",
loc: [233,2,251,3],
module:"bd/command/dispatch"}
,"bd.command.scheduleCommand":{
type:
Tfunction,
sdoc:
["Executes a command asynchronously. "],
ldoc:
["Executes a command asynchronously. Asynchronous command dispatch is useful\nwhen you want the display to settle before executing a command (e.g., menus)"],
params:
[["id",[["bd.command.id",
["The id property of the command item."]]]],
["source",[["object",
["The widget (menu, context menu, toolbar, etc.) that caused the command to be executed; null if an accelerator."]]]],
["activeStack",[["array of string, optional, null",
["The active focus stack as given by widget identifiers at the time the command was issued."]]]],
["eventObject",[["DOM.event, optional, null",
["The event object that caused the command, if any."]]]]],
src:
"bd/command/dispatch",
loc: [253,2,271,3],
module:"bd/command/dispatch"}
,"modules.bd/command/dispatch":{
type:
Tmodule,
sdoc:
["Augments the bd.command namespace with the Backdraft command dispatch machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["dijit",[]],
["bd",[]]],
src:
"bd/command/dispatch",
loc: [0,0,276,2]}
,"resources.bd/command/item":{
type:
Tresource,
sdoc:
["Defines the module bd/command/item"],
src:
"bd/command/item",
modules:
["bd/command/item"],
docLocs:
[[239,314],[58,104]],
code:
["dojo.def(\"bd/command/item\", [",
"  \"dojo\", \"bd\",  \"bd/command/namespace\",",
"  \"bd/namespace\"",
"], function(dojo, bd) {",
"///",
"// Augments the bd.command namespace with the Backdraft command item machinery.",
"",
"var defaultValue= // lexical variable for this module",
"bd.command.defaultValue=",
"  ///const",
"  // Constant value used to signal \"use default semantics\" for several command item fields. //See bd.command.item.",
"  -1;",
"",
"bd.command.roles= {",
"  ///enum",
"  // The set of roles a bd.command.item may play.",
"",
"  invalid:",
"    ///",
"    //(0) The command item\'s role is unknown.",
"    0,",
"",
"  command:",
"    ///",
"    //(1) The command item is a command.",
"    1,",
"",
"  menu:",
"    ///",
"    //(2) The command item is a menu or submenu.",
"    2,",
"",
"  group:",
"    ///",
"    //(3) The command item is a command group (a group of commands on a [sub]menu).",
"    3",
"};",
"",
"bd.command.checked= {",
"  ///enum",
"  // The set of checked states of a command item.",
"",
"  na:",
"    ///",
"    //(0) The item does not show a checked/unchecked value.",
"    0,",
"",
"  checked:",
"    ///",
"    //(1) The item is checked.",
"    1,",
"",
"  unchecked:",
"    ///",
"    //(2) The item shows a checked value but is currently unchecked.",
"    2",
"};",
"",
"bd.docGen(\"bd.command\", {",
"  id:",
"    ///type",
"    // (string) An identifier for a command.",
"    bd.nodoc,",
"",
"  shiftState:",
"    ///type",
"    // (string) Gives the shift state required to recognize a keydown event as an accelerator. //Any combination of \"shift\", ",
"    // \"control\", \"alt\", \"s\", \"c\", \"a\" (case is ignored) to indicate the shift state for the accelerator key; any other characters are ignored.",
"    //",
"    // The command machinery automatically transforms this loose definition into a normalized shift state given by /(S|x)(C|x)(A|x)/ for ",
"    // all internal use. For example, when a command item is created with a shift state of \"control-alt\", the constructor",
"    // will normalize the shift state to \"xCA\".",
"    bd.nodoc,",
"",
"  menuTree:",
"    ///type",
"    // A tree of hashes that represents a hierarchical menu. //The top-level object holds the top-level menu.",
"    // ",
"    // * The keys in the hash are bd.command.id values.",
"    //  ",
"    // * For each property in the top-level object that is a submenu, the value of that property",
"    //   holds another hash that represents the contents of that submenu.",
"    //",
"    // * For each property in the top-leven object that is a command, the value of that property",
"    //   is set to truthy.",
"    //",
"    // * Submenus are recursively defined just as the top-level menu.",
"    // ",
"    // For example,",
"    //code",
"    // {",
"    //   file: {",
"    //     open:1,",
"    //     close:1,",
"    //     save:1,",
"    //     saveAs:1",
"    //   },",
"    //   edit: {",
"    //     cut:1,",
"    //     copy:1,",
"    //     paste:1",
"    //   }",
"    // }",
"    bd.nodoc",
"});",
"",
"    // The menu object is a tree of hashes. The top-level object holds the top-level menu.",
"    //",
"    // * For each property in the top-level object that is a submenu, the value of that property",
"    //   holds another hash that represents the contents of that submenu.",
"    //",
"    // * For each property in the top-leven object that is a command, the value of that property",
"    //   is set to true.",
"    //",
"    // * Submenus are recursively defined just as the top-level menu.",
"    //",
"    // This structure nicely models a menu tree.",
"",
"",
"bd.command.getShiftStateKey= function(",
"  shiftStateText ///(bd.command.shiftState) The shift state to transform.",
") {",
"  ///",
"  // Transforms any combination of \"shift\", \"control\", \"alt\", \"s\", \"c\", \"a\" and any other characters in any case into /(S|x)(C|x)(A|x)/.",
"  if (!dojo.isString(shiftStateText)) {",
"    return \"xxx\";",
"  }",
"  var temp= shiftStateText.replace(/shift/i, \"S\").replace(/control/i, \"C\").replace(/alt/i, \"A\");",
"  return (temp.match(/s/i) ? \"S\" : \"x\") + (temp.match(/c/i) ? \"C\" : \"x\") + (temp.match(/a/i) ? \"A\" : \"x\");",
"};",
"",
"bd.declare(",
"  /// ",
"  // A container that defines all the visual aspects of a command as well as its enabled/disabled and checked/unchecked state.",
"",
"  //class name",
"  \"bd:command.item\", ",
"  ",
"  //superclasses",
"  [],",
" ",
"  //members",
"  {",
"  id:",
"    ///(bd.command.id) The identifier for the command.",
"    \"\",",
"",
"  parentMenuId:",
"    ///(bd.command.id) The menu (in bd.command.itemCache) that contains this command item (if any).",
"    \"\",",
"",
"  groupId:",
"    ///(bd.command.id) The group (in bd.command.itemCache) the contains this command item.",
"    bd.command.defaultValue,",
"",
"  text:",
"    ///(string) The raw text displayed to the user for this item.",
"    \"\",",
"",
"  role:",
"    ///(bd.command.roles) The role this command plays.",
"    bd.command.roles.invalid,",
"",
"  groupOrder:",
"    ///(integer) Derived from itemOrder of command item at groupId.",
"    0,",
"",
"  itemOrder:",
"    ///(integer) The order of this item relative to its siblings.",
"    0,",
"",
"  accelKey:",
"    ///",
"    // The key in combination with accelShift to detect an accelerator. //See bd.command.accelTable.",
"    ///",
"    //(integer) The scan code to detect on keydown.",
"    //(char) The key to detect on keypress.",
"    0,",
"",
"  accelShift:",
"    ///(bd.command.shiftState) The shift state in combination with accelKey to detect an accelerator.",
"    \"\",",
"",
"  accelText:",
"    ///(string) The text used to inform the user that an accelerator exists.",
"    bd.command.defaultValue,",
"",
"  statusText:",
"    ///(string) The text shown on the status bar for the command.",
"    bd.command.defaultValue,",
"",
"  helpUrl:",
"    ///(string) The help URL for associated with the command.",
"    bd.command.defaultValue,",
"",
"  tooltipText:",
"    ///(string) The tooltip text associated with the command.",
"    bd.command.defaultValue,",
"",
"  enabledIcon:",
"    ///",
"    // The icon to show for an enabled command. //See bd.command.item.getIcon for algorithm that sets ",
"    // the HTML class intended to influence the icon presented with a command item.",
"    ///",
"    //(string) The icon resource.",
"    //(truthy) Show the icon, deduce resource from id.",
"    //(falsy) Don\'t show an icon.",
"    false,",
"",
"  disabledIcon:",
"    ///",
"    //(string) The icon resource.",
"    //(truthy) Show the icon, deduce resource from id.",
"    //(falsy) Don\'t show an icon.",
"    ///",
"    // The icon to show for a disabled command.",
"    ///",
"    // See bd.command.item.getIcon for algorithm that sets the HTML class intended to influence the icon presented with a command item.",
"    false,",
"",
"  disabled:",
"    ///",
"    // Run-time property that says if this item is disabled.",
"    ///",
"    //(bool) Truthy puts the command in the disabled state, and conversely.",
"    false,",
"",
"  checked:",
"    ///",
"    // Run-time property that says if this item is checked.",
"    ///",
"    //(bd.command.checked) The checked state of the command.",
"    bd.command.checked.na,",
"",
"  constructor: function(",
"    args ///(kwargs) Properties with which to initialize this object.",
"  ) {",
"    /// ",
"    // Creates a new instance.",
"    bd.docGen(\"kwargs\", {",
"      ///",
"      // Describes the property values used to initialize a bd.command.commantItem instance.",
"",
"      id:",
"        ///(bd.command.id) The identifier for the command.",
"        undefined,",
"    ",
"      parentMenuId:",
"        ///(bd.command.id) The menu that contains this command item (if any).",
"        \"\",",
"    ",
"      groupId:",
"        ///(bd.command.id) The group the contains this command item.",
"        bd.command.defaultValue,",
"    ",
"      text:",
"        ///(string) The raw text displayed to the user for this item.",
"        \"\",",
"    ",
"      role:",
"        ///(bd.command.roles) The role this command plays.",
"        bd.command.roles.invalid,",
"    ",
"      itemOrder:",
"        ///(integer) The order of this item relative to its siblings.",
"        Number.MAX_VALUE,",
"    ",
"      accelKey:",
"        ///",
"        // The key in combination with accelShift to detect an accelerator",
"        //",
"        //(integer) The scan code to detect on keydown.",
"        //(char) The key to detect on keypress.",
"        0,",
"    ",
"      accelShift:",
"        ///(bd.command.shiftState) The shift state in combination with accelKey to detect an accelerator.",
"        \"\",",
"    ",
"      accelText:",
"        ///(string) The text used to inform the user that an accelerator exists.",
"        bd.command.defaultValue,",
"    ",
"      statusText:",
"        ///(string) The text shown on the status bar for the command.",
"        bd.command.defaultValue,",
"    ",
"      helpUrl:",
"        ///(string) The help URL for associated with the command.",
"        bd.command.defaultValue,",
"    ",
"      tooltipText:",
"        ///(string) The tooltip text associated with the command.",
"        bd.command.defaultValue,",
"    ",
"      enabledIcon:",
"        ///",
"        // The icon to show for an enabled command. See bd.command.item.getIcon for algorithm that ",
"        // sets the HTML class intended to influence the icon presented with a command item.",
"        ///",
"        //(string) The icon resource.",
"        //(truthy) Show the icon, deduce resource from id.",
"        //(falsy) Don\'t show an icon.",
"        false,",
"    ",
"      disabledIcon:",
"        ///",
"        // The icon to show for a disabled command. See bd.command.item.getIcon for algorithm that",
"        // sets the HTML class intended to influence the icon presented with a command item.",
"        ///",
"        //(string) The icon resource.",
"        //(truthy) Show the icon, deduce resource from id.",
"        //(falsy) Don\'t show an icon.",
"        false",
"    });",
"",
"    dojo.mix(this, args);",
"    this.fixup();",
"  },",
"",
"  modify: function(",
"    args ///(hash) Properties to mixin to this object.",
"  ) {",
"    /// ",
"    // Edits one or more properties of the instance. //",
"    // Deduced properties (e.g. accelText) are recalculated.",
"    dojo.mix(this, args);",
"    this.fixup();",
"  },",
"",
"  fixup: function() {",
"    ///",
"    // Inspects all properties of a command item and attempts to derive properties not explicitly specified.",
"    ///",
"    // The following properties are derived:",
"    //",
"    //   * If the value at groupId is identical to bd.defaultValue, then it is set to the value at parentMenuId.",
"    //",
"    //   * The value at text is searched for any character preceeded by a backslash. Any such character is assumed to be",
"    //     a menu hot key.  A backslash is escaped by writing two consecutive backslashes. A backslash is given as a menu hot key by writing three consecutive backslashes.",
"    //",
"    //   * The value at htmlText is derived by surrounding any menu hot key (say \'x\') with \"<span class=\'hotKey\'>x</span>\" and",
"    //     removing the accompanying backslash.",
"    //",
"    //   * The value cleanedText is derived by removing any menu hot key backslash characters",
"    //",
"    //   * If the value at accelKey is a character and a shift state is given, then the value is converted to a keyCode.",
"    //",
"    //   * If no value is given at accelText, then a value is manufactured from accelKey and accelShift if possible.",
"    //",
"    //   * If statusText===bd.defaultValue, then a value is manufacture. See source for details.",
"    //",
"    //   * If tooltipText===bd.defaultValue, then it is set to the value at statusText",
"    //",
"    //   * If helpUrl===bd.defaultValue, then a value is manufactured equivalent to <span class=\"placeholder\">groupId</span>#<span class=\"placeholder\">id</span>",
"    //",
"",
"    if (this.groupId===defaultValue) {",
"      this.groupId= this.parentMenuId;",
"    }",
"",
"    // the mnemonic is given by \'\\\' preceeded by a non-\'\\\' followed by a non-\'\\\'",
"    // the mnemonic literal \'\\\' is given by \'\\\\\\\'",
"",
"    // (any non-backslash character or beginning-of-line) followed by (backslash) followed by (any non-backslash character)",
"    var mnemonic= this.text.match(/([^\\\\]|^)\\\\([^\\\\])/);",
"    if (mnemonic) {",
"      this.mnemonic= mnemonic[2].charAt(0).toLowerCase();",
"    } else {",
"      // three backslashes preceeded by any character other than backslash or ^ followed by any character other than backslash or $",
"      this.mnemonic= /([^\\\\]|^)\\\\\\\\\\\\([^\\\\]|$)/.test(this.text) ? \"\\\\\" : null;",
"    }",
"",
"    // htmlText replaces the mnemonic \'x\' with \"<span class=\'menuMnemonic\'>x</span>\"",
"    // cleanedText removes the mnemonic escape character",
"    var",
"      htmlText= this.text,",
"      cleanedText= htmlText;",
"    if (htmlText) {",
"      htmlText= htmlText.replace(",
"        /([^\\\\]|^)(\\\\)([^\\\\])/, \"$1<span class=\'menuMnemonic\'>$3</span>\"",
"      ).replace(",
"        /([^\\\\]|^)\\\\\\\\\\\\([^\\\\]|$)/, \"$1<span class=\'menuMnemonic\'>\\\\</span>$2\"",
"      ).replace(",
"        /\\\\\\\\/g, \"\\\\\"",
"      );",
"      cleanedText= cleanedText.replace(/(\\\\)([^\\\\])/, \"$2\").replace(/([^\\\\]|^)\\\\\\\\\\\\([^\\\\]|$)/, \"$1\\\\$2\").replace(/\\\\\\\\/g, \"\\\\\");",
"    }",
"    this.htmlText= htmlText;",
"    this.cleanedText= cleanedText;",
"",
"    // set...",
"    // accelShift::= 0 | /(S|x)(C|x)(A|x)/",
"    // accelKey::= string resolved by dojo.keys => keyCode | charCode => intercept onkeypress | keyCode => intercept onkeydown",
"    // accelText::= as given or derive a best guess",
"    var accelKey;",
"    if ((accelKey= this.accelKey) && (accelKey= dojo.keys[accelKey])) {",
"      this.accelKey= accelKey;",
"    }",
"    this.accelShift= this.accelShift ? bd.command.getShiftStateKey(this.accelShift) : 0;",
"    if (this.accelShift || !dojo.isString(this.accelKey)) {",
"      // intercept at onkeydown and looking for a keyCode, _not_ a charCode",
"      if (dojo.isString(this.accelKey)) {",
"        if (this.accelText==defaultValue) {",
"          var shiftText= \"\";",
"          if (this.accelShift.charAt(0)==\'S\') {",
"            shiftText+= \"shift+\";",
"          }",
"          if (this.accelShift.charAt(1)==\'C\') {",
"            shiftText+= \"control+\";",
"          }",
"          if (this.accelShift.charAt(2)==\'A\') {",
"            shiftText+= \"alt+\";",
"          }",
"          this.accelText= shiftText + this.accelKey.toLowerCase().charAt(0);",
"        }",
"        this.accelKey= this.accelKey.toUpperCase().charCodeAt(0);",
"      } else {",
"        //this.accelKey should be a keyCode and the accelText should be set manually",
"      }",
"    } else if (this.accelText==defaultValue) {",
"      //no shift and the accelKey is a string; therefore intercept at onkeypress and looking for a charCode",
"      this.accelText= this.accelKey;",
"    }",
"",
"    if (this.statusText===defaultValue) {",
"      if (this.role==bd.command.roles.menu) {",
"        this.statusText= \"click to open the \" + this.cleanedText + \" menu\";",
"      } else if (this.role==bd.command.roles.command) {",
"        this.statusText= \"click to execute the \" + this.cleanedText + \" command\";",
"      }",
"    }",
"",
"    if (this.helpUrl===defaultValue) {",
"      this.helpUrl= this.groupId + \'#\' + this.id;",
"    }",
"",
"    if (this.tooltipText===defaultValue) {",
"      this.tooltipText= this.statusText;",
"    }",
"  },",
"",
"  getIcon: function() {",
"    ///",
"    // Derives a HTML class name that gives the icon based on the values of enabledIcon, disabledIcon, and disabled.",
"    var",
"      icon= (this.disabled && this.disabledIcon) ? this.disabledIcon : this.enabledIcon,",
"      prefix= (this.disabled ? \"commandIconDisabled \" : \"commandIcon \");",
"    if (dojo.isString(icon)) {",
"      return prefix + icon;",
"    } else if (icon) {",
"      return prefix  + this.id;",
"    } else {",
"      return \"\";",
"    }",
"  }",
"});",
"",
"bd.declare(",
"  ///",
"  // bd.namespace-derived class used for the global command item cache (bd.command.itemCache).",
"",
"  //class name",
"  \"bd:command.namespace\",",
"",
"  //superclasses",
"  [bd.namespace], ",
"",
"  //members",
"  {",
"  mxPending:",
"    // Says if items have been added, but some derivable properties still needs to be computed. \\\\When true, ",
"    // bd.command.namespace.process will be called before any items are returned from the namespace via bd.command.namespace.get.",
"    // `private",
"    false,",
"",
"  set: function(",
"    item ///(bd.command.item) The command item to add to the cache.",
"  ) {",
"    ///",
"    // Adds a new command item to the namespace at item.id. //If the command",
"    // given by item.id already exists in the namespace, then it is replaced.",
"    this.mxPending= true;",
"    this._hash[item.id]= item;",
"    return this;",
"  },",
"",
"  get: function(",
"    id ///(bd.command.id) Identifies the command item to retrieve.",
"  ) {",
"    ///",
"    // Returns the command item given by id from the namespace.",
"    if (this.mxPending) {",
"      this.process();",
"    }",
"    return this._hash[id];",
"  },",
"",
"  modify: function(",
"    id, ///(bd.command.id) identifies the command item to retrieve",
"    props      ///(hash) the properties to mixin into the comamnd item",
"  ) {",
"    ///",
"    // Modifies the properties of the command item given by id as given by props.",
"    this.mxPending= true;",
"    this._hash[id].modify(props);",
"  },",
"",
"  process: function() {",
"    ///",
"    // Computes any dependent itemOrder properties, then compute all derived groupOrder properties.",
"    this.mxPending= false;",
"    var",
"      orderCountToCompute= 0, //the number of items whos order must be computed",
"      currentOrderRecursiveDepth= 0,",
"      groupHash= {},",
"      hash= this._hash,",
"      computeItemOrder= function(item) {",
"        currentOrderRecursiveDepth++;",
"        if (currentOrderRecursiveDepth > orderCountToCompute+1) {",
"          console.warn(\"cycle in command items order calculation\");",
"          item.itemOrder= Number.MAX_VALUE;",
"        }",
"        if (item.itemOrder.reference) {",
"          //this item not yet computed...",
"          var referenceItem= hash[item.itemOrder.reference];",
"          if (!referenceItem) {",
"            console.warn(\"item.itemOrder.reference= \" + item.itemOrder.reference + \" is not defined.\");",
"            item.itemOrder= Number.MAX_VALUE;",
"          } else {",
"            var order= computeItemOrder(hash[item.itemOrder.reference]);",
"            if (item.itemOrder.offset===\"after\" || !item.itemOrder.offset) {",
"              item.itemOrder= order + 1;",
"              dojo.forEach(groupHash[item.groupId], function(i) {",
"                if (i!==item && !i.itemOrder.reference && i.itemOrder!==0 && i.itemOrder>=item.itemOrder) {",
"                  i.itemOrder+= 1;",
"                }",
"              });",
"            } else if (item.itemOrder.offset===\"before\") {",
"              item.itemOrder= order - 1;",
"              dojo.forEach(groupHash[item.groupId], function(i) {",
"                if (i!==item && !i.itemOrder.reference && i.itemOrder!==0 && i.itemOrder<=item.itemOrder) {",
"                  i.itemOrder-= 1;",
"                }",
"              });",
"            } else {",
"              item.itemOrder= order + item.itemOrder.offset;",
"            }",
"          }",
"        } else if (item.itemOrder===0) {",
"          var max= 0;",
"          dojo.forEach(groupHash[item.groupId], function(i) {",
"            if (i!==item && !i.itemOrder.reference && i.itemOrder>=max) {",
"              max= i.itemOrder;",
"            }",
"          });",
"          item.itemOrder= max+1;",
"        }",
"        currentOrderRecursiveDepth--;",
"        return item.itemOrder;",
"      };",
"",
"    // calculate the watchdog...",
"    this.forEach(function(itemId, item) {",
"      if (item.itemOrder.reference || item.itemOrder===0) {",
"        orderCountToCompute++;",
"      }",
"    });",
"    if (orderCountToCompute) {",
"      // initialize the group hash...",
"      this.forEach(function(itemId, item) {",
"        (groupHash[item.groupId]= (groupHash[item.groupId] || [])).push(item);",
"      });",
"      this.forEach(function(itemId, item) {",
"        computeItemOrder(item);",
"      });",
"    }",
"",
"    var",
"      commandRole= bd.command.roles.command,",
"      menuRole= bd.command.roles.menu;",
"    this.forEach(function(itemId, item) {",
"      var",
"        menuItem= hash[item.parentMenuId],",
"        groupItem= hash[item.groupId];",
"      if (groupItem) {",
"        item.groupOrder= groupItem.itemOrder;",
"      } else if ((item.role==commandRole || item.role==menuRole) && itemId!=\"top\") {",
"        console.warn(\"group item not found for command item: \" + item.id);",
"      }",
"    });",
"  }",
"});",
"",
"dojo.mix (bd.command, {",
"  itemCache: ",
"    ///",
"    // (bd.command.namespace) The global cache of command items.",
"    new bd.command.namespace(),",
"",
"  getItem: function(",
"    id ///(bd.command.id) The item to retrieve.",
"  ) {",
"    ///",
"    // Returns the command item given by id from the global command item cache.",
"    //return",
"    //(bd.command.item) The command item in the global command cache with id==id.",
"    return this.itemCache.get(id);",
"  },",
"",
"  addItem: function(",
"    args ///(bd.command.item.constructor.kwargs) arguments to provide to the bd.command.item constructor",
"  ) {",
"    ///",
"    // Creates a new bd.command.item and adds it to the global command item cache (bd.command.itemCache).",
"    //return ",
"    //(bd.command.namespace) bd.command.itemCache.",
"    return this.itemCache.set(new bd.command.item(args));",
"  },",
"",
"  addItems: function(",
"    items ///(array of bd.command.item.constructor.kwargs) Set of args to provide to the bd.command.item constructor.",
"  ) {",
"    ///",
"    // Adds a set of new bd.command.item objects to the global command item cache (bd.command.itemCache).",
"    //return",
"    //(bd.command.namespace) bd.command.itemCache.",
"    dojo.forEach(items, function(args) {",
"      this.itemCache.set(new bd.command.item(args));",
"    }, this);",
"    return this.itemCache;",
"  },",
"",
"  modifyItem: function(",
"    id, ///(bd.command.id) The command item to modify.",
"    props      ///(hash) The properties to mixin into the command item.",
"  ) {",
"    ///",
"    // Modifies the properties of the command item in the global command item cache (bd.command.itemCache)",
"    // given by id as given by props.",
"    //return",
"    //(bd.command.namespace) bd.command.itemCache.",
"    this.itemCache.modify(id, props);",
"    return this.itemCache;",
"  },",
"",
"  removeItem: function(",
"    id ///(bd.command.id) The command item to remove.",
"  ) {",
"    ///",
"    // Removes the command item given by id from the global cache (bd.command.itemCache).",
"    //return",
"    //(bd.command.namespace) bd.command.itemCache.",
"    return this.itemCache.del(id);",
"  },",
"",
"  compare: function(",
"    lhs, ///(bd.command.id) the left-hand-side of the comparison",
"    rhs  ///(bd.command.id) the right-hand-side of the comparison",
"  ) {",
"    ///",
"    // Compares the relative order of (lhs ? rhs). //",
"    // Command items are ordered most-significant to least significant by (groupOrder, itemOrder, text).",
"    lhs= bd.command.getItem(lhs);",
"    rhs= bd.command.getItem(rhs);",
"    if (!lhs || !rhs) {",
"      //TODO probably throw",
"    }",
"    var result= lhs.groupOrder==rhs.groupOrder ? lhs.itemOrder - rhs.itemOrder : lhs.groupOrder - rhs.groupOrder;",
"    if (result===0) {",
"      if (lhs.cleanedText<rhs.cleanedText) {",
"        return -1; // if lhs < rhs",
"      } else if (lhs.cleanedText==rhs.cleanedText) {",
"        return 0; // if lhs == rhs",
"      } else {",
"        return 1; // if lhs > rhs",
"      }",
"    }",
"    return result;",
"  },",
"",
"",
"  itemIdsInOrder: function(",
"    menuContents ///(hash with keys of bd.command.id) The contents of a menu.",
"  ) {",
"    ///",
"    // Sorts the contents of a menu as given bye bd.command.compare.",
"    //return",
"    //(array of bd.command.id) sorted by order as given by bd.command.compare",
"    var items= [];",
"    for(var item in menuContents) {",
"      items.push(item);",
"    }",
"    return items.sort(bd.command.compare);",
"  },",
"",
"  deduceMenu: function(",
"    commandSet ///(array or id) The commands to form into a menu object.",
"  ) {",
"    ///",
"    // Constructs a bd.command.menuTree that contains exactly the commands given in commandSet.",
"",
"    //Take a copy of commandSet since this routine destroys it",
"    commandSet= commandSet.slice(0);",
"",
"    //get a map of (id --> item) for the command set",
"    var items= {};",
"    dojo.forEach(commandSet, function(id) {",
"      items[id]= bd.command.getItem(id);",
"    });",
"",
"    var",
"      menuRole= bd.command.roles.menu,",
"      result= {},",
"      resultMap= {},",
"      consumedAtLeastOne= true;",
"    while (consumedAtLeastOne && commandSet.length) {",
"      consumedAtLeastOne= false;",
"      for (var i= 0; i<commandSet.length;) {",
"        var",
"          itemId= commandSet[i],",
"          item= items[itemId],",
"          parentId= item.parentMenuId,",
"          parentItem= resultMap[parentId];",
"        if (parentItem) {",
"          // the parent has been added to the result; add this item as a child of the parent",
"          resultMap[itemId]= parentItem[itemId]= (item.role===menuRole ? {} : true);",
"          consumedAtLeastOne= true;",
"          commandSet.splice(i, 1);",
"        } else if (!items[parentId]) {",
"          // the parent is not in the command set; therefore, it\'s a top-level item...",
"          result[itemId]= resultMap[itemId]= (item.role===menuRole ? {} : true);",
"          consumedAtLeastOne= true;",
"          commandSet.splice(i, 1);",
"        } else {",
"          i++;",
"        }",
"      }",
"    }",
"    return result;",
"  }",
"});",
"",
"return bd.command;",
"",
"});",
"// Copyright (c) 2000-2009, ALTOVISO, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.command.roles":{
type:
Tenum,
sdoc:
["The set of roles a bd.command.item may play."],
ldoc:
[],
props:
["invalid",{
type:
Tvariable,
loc: [20,4,20,5],
types:
[["0",
["The command item\'s role is unknown."]]]}
,
"command",{
type:
Tvariable,
loc: [25,4,25,5],
types:
[["1",
["The command item is a command."]]]}
,
"menu",{
type:
Tvariable,
loc: [30,4,30,5],
types:
[["2",
["The command item is a menu or submenu."]]]}
,
"group",{
type:
Tvariable,
loc: [35,4,35,5],
types:
[["3",
["The command item is a command group (a group of commands on a [sub]menu)."]]]}
],
src:
"bd/command/item",
loc: [13,0,36,1],
module:"bd/command/item"}
,"bd.command.checked":{
type:
Tenum,
sdoc:
["The set of checked states of a command item."],
ldoc:
[],
props:
["na",{
type:
Tvariable,
loc: [45,4,45,5],
types:
[["0",
["The item does not show a checked/unchecked value."]]]}
,
"checked",{
type:
Tvariable,
loc: [50,4,50,5],
types:
[["1",
["The item is checked."]]]}
,
"unchecked",{
type:
Tvariable,
loc: [55,4,55,5],
types:
[["2",
["The item shows a checked value but is currently unchecked."]]]}
],
src:
"bd/command/item",
loc: [38,0,56,1],
module:"bd/command/item"}
,"bd.command.id":{
type:
Ttype,
sdoc:
["(string) An identifier for a command."],
ldoc:
[],
src:
"bd/command/item",
loc: [59,2,62,12],
module:"bd/command/item"}
,"bd.command.shiftState":{
type:
Ttype,
sdoc:
["(string) Gives the shift state required to recognize a keydown event as an accelerator. "],
ldoc:
["(string) Gives the shift state required to recognize a keydown event as an accelerator. Any combination of \"shift\",\n\"control\", \"alt\", \"s\", \"c\", \"a\" (case is ignored) to indicate the shift state for the accelerator key; any other characters are ignored.\n\nThe command machinery automatically transforms this loose definition into a normalized shift state given by /(S|x)(C|x)(A|x)/ for\nall internal use. For example, when a command item is created with a shift state of \"control-alt\", the constructor\nwill normalize the shift state to \"xCA\"."],
src:
"bd/command/item",
loc: [64,2,72,12],
module:"bd/command/item"}
,"bd.command.menuTree":{
type:
Ttype,
sdoc:
["A tree of hashes that represents a hierarchical menu. "],
ldoc:
["A tree of hashes that represents a hierarchical menu. The top-level object holds the top-level menu.\n\n* The keys in the hash are bd.command.id values.\n\n* For each property in the top-level object that is a submenu, the value of that property\n  holds another hash that represents the contents of that submenu.\n\n* For each property in the top-leven object that is a command, the value of that property\n  is set to truthy.\n\n* Submenus are recursively defined just as the top-level menu.\n\nFor example,",
[CODE,"{\n  file: {\n    open:1,\n    close:1,\n    save:1,\n    saveAs:1\n  },\n  edit: {\n    cut:1,\n    copy:1,\n    paste:1\n  }\n}"]],
src:
"bd/command/item",
loc: [74,2,103,12],
module:"bd/command/item"}
,"bd.command.getShiftStateKey":{
type:
Tfunction,
sdoc:
["Transforms any combination of \"shift\", \"control\", \"alt\", \"s\", \"c\", \"a\" and any other characters in any case into /(S|x)(C|x)(A|x)/."],
ldoc:
[],
params:
[["shiftStateText",[["bd.command.shiftState",
["The shift state to transform."]]]]],
src:
"bd/command/item",
loc: [119,0,129,1],
module:"bd/command/item"}
,"bd.command.item":{
type:
Tclass,
sdoc:
["A container that defines all the visual aspects of a command as well as its enabled/disabled and checked/unchecked state."],
ldoc:
[],
src:
"bd/command/item",
loc: [131,0,456,2],
module:"bd/command/item"}
,"bd.command.item.id":{
type:
Tvariable,
imember:1,
loc: [143,2,145,6],
types:
[["bd.command.id",
["The identifier for the command."]]]}
,"bd.command.item.parentMenuId":{
type:
Tvariable,
imember:1,
loc: [147,2,149,6],
types:
[["bd.command.id",
["The menu (in bd.command.itemCache) that contains this command item (if any)."]]]}
,"bd.command.item.groupId":{
type:
Tvariable,
imember:1,
loc: [151,2,153,27],
types:
[["bd.command.id",
["The group (in bd.command.itemCache) the contains this command item."]]]}
,"bd.command.item.text":{
type:
Tvariable,
imember:1,
loc: [155,2,157,6],
types:
[["string",
["The raw text displayed to the user for this item."]]]}
,"bd.command.item.role":{
type:
Tvariable,
imember:1,
loc: [159,2,161,28],
types:
[["bd.command.roles",
["The role this command plays."]]]}
,"bd.command.item.groupOrder":{
type:
Tvariable,
imember:1,
loc: [163,2,165,5],
types:
[["integer",
["Derived from itemOrder of command item at groupId."]]]}
,"bd.command.item.itemOrder":{
type:
Tvariable,
imember:1,
loc: [167,2,169,5],
types:
[["integer",
["The order of this item relative to its siblings."]]]}
,"bd.command.item.accelKey":{
type:
Tvariable,
sdoc:
["The key in combination with accelShift to detect an accelerator. "],
imember:1,
ldoc:
["The key in combination with accelShift to detect an accelerator. See bd.command.accelTable."],
loc: [171,2,177,5],
types:
[["integer",
["The scan code to detect on keydown."]],
["char",
["The key to detect on keypress."]]]}
,"bd.command.item.accelShift":{
type:
Tvariable,
imember:1,
loc: [179,2,181,6],
types:
[["bd.command.shiftState",
["The shift state in combination with accelKey to detect an accelerator."]]]}
,"bd.command.item.accelText":{
type:
Tvariable,
imember:1,
loc: [183,2,185,27],
types:
[["string",
["The text used to inform the user that an accelerator exists."]]]}
,"bd.command.item.statusText":{
type:
Tvariable,
imember:1,
loc: [187,2,189,27],
types:
[["string",
["The text shown on the status bar for the command."]]]}
,"bd.command.item.helpUrl":{
type:
Tvariable,
imember:1,
loc: [191,2,193,27],
types:
[["string",
["The help URL for associated with the command."]]]}
,"bd.command.item.tooltipText":{
type:
Tvariable,
imember:1,
loc: [195,2,197,27],
types:
[["string",
["The tooltip text associated with the command."]]]}
,"bd.command.item.enabledIcon":{
type:
Tvariable,
sdoc:
["The icon to show for an enabled command. "],
imember:1,
ldoc:
["The icon to show for an enabled command. See bd.command.item.getIcon for algorithm that sets\nthe HTML class intended to influence the icon presented with a command item."],
loc: [199,2,207,9],
types:
[["string",
["The icon resource."]],
["truthy",
["Show the icon, deduce resource from id."]],
["falsy",
["Don\'t show an icon."]]]}
,"bd.command.item.disabledIcon":{
type:
Tvariable,
sdoc:
["The icon to show for a disabled command."],
imember:1,
ldoc:
["See bd.command.item.getIcon for algorithm that sets the HTML class intended to influence the icon presented with a command item."],
loc: [209,2,218,9],
types:
[["string",
["The icon resource."]],
["truthy",
["Show the icon, deduce resource from id."]],
["falsy",
["Don\'t show an icon."]]]}
,"bd.command.item.disabled":{
type:
Tvariable,
sdoc:
["Run-time property that says if this item is disabled."],
imember:1,
ldoc:
[],
loc: [220,2,225,9],
types:
[["bool",
["Truthy puts the command in the disabled state, and conversely."]]]}
,"bd.command.item.checked":{
type:
Tvariable,
sdoc:
["Run-time property that says if this item is checked."],
imember:1,
ldoc:
[],
loc: [227,2,232,25],
types:
[["bd.command.checked",
["The checked state of the command."]]]}
,"bd.command.item.constructor":{
type:
Tfunction,
sdoc:
["Creates a new instance."],
imember:1,
ldoc:
[],
params:
[["args",[["kwargs",
["Properties with which to initialize this object."]]]]],
loc: [234,2,318,3]}
,"bd.command.item.constructor.kwargs":{
type:
Tvariable,
sdoc:
["Describes the property values used to initialize a bd.command.commantItem instance."],
ldoc:
[],
props:
["id",{
type:
Tvariable,
loc: [245,8,245,17],
types:
[["bd.command.id",
["The identifier for the command."]]]}
,
"parentMenuId",{
type:
Tvariable,
loc: [249,8,249,10],
types:
[["bd.command.id",
["The menu that contains this command item (if any)."]]]}
,
"groupId",{
type:
Tvariable,
loc: [253,8,253,31],
types:
[["bd.command.id",
["The group the contains this command item."]]]}
,
"text",{
type:
Tvariable,
loc: [257,8,257,10],
types:
[["string",
["The raw text displayed to the user for this item."]]]}
,
"role",{
type:
Tvariable,
loc: [261,8,261,32],
types:
[["bd.command.roles",
["The role this command plays."]]]}
,
"itemOrder",{
type:
Tvariable,
loc: [265,8,265,24],
types:
[["integer",
["The order of this item relative to its siblings."]]]}
,
"accelKey",{
type:
Tvariable,
sdoc:
["The key in combination with accelShift to detect an accelerator"],
ldoc:
[],
loc: [273,8,273,9],
types:
[["integer",
["The scan code to detect on keydown."]],
["char",
["The key to detect on keypress."]]]}
,
"accelShift",{
type:
Tvariable,
loc: [277,8,277,10],
types:
[["bd.command.shiftState",
["The shift state in combination with accelKey to detect an accelerator."]]]}
,
"accelText",{
type:
Tvariable,
loc: [281,8,281,31],
types:
[["string",
["The text used to inform the user that an accelerator exists."]]]}
,
"statusText",{
type:
Tvariable,
loc: [285,8,285,31],
types:
[["string",
["The text shown on the status bar for the command."]]]}
,
"helpUrl",{
type:
Tvariable,
loc: [289,8,289,31],
types:
[["string",
["The help URL for associated with the command."]]]}
,
"tooltipText",{
type:
Tvariable,
loc: [293,8,293,31],
types:
[["string",
["The tooltip text associated with the command."]]]}
,
"enabledIcon",{
type:
Tvariable,
sdoc:
["The icon to show for an enabled command. See bd.command.item.getIcon for algorithm that\nsets the HTML class intended to influence the icon presented with a command item."],
ldoc:
[],
loc: [303,8,303,13],
types:
[["string",
["The icon resource."]],
["truthy",
["Show the icon, deduce resource from id."]],
["falsy",
["Don\'t show an icon."]]]}
,
"disabledIcon",{
type:
Tvariable,
sdoc:
["The icon to show for a disabled command. See bd.command.item.getIcon for algorithm that\nsets the HTML class intended to influence the icon presented with a command item."],
ldoc:
[],
loc: [313,8,313,13],
types:
[["string",
["The icon resource."]],
["truthy",
["Show the icon, deduce resource from id."]],
["falsy",
["Don\'t show an icon."]]]}
],
loc: [239,24,314,5]}
,"bd.command.item.modify":{
type:
Tfunction,
sdoc:
["Edits one or more properties of the instance. "],
imember:1,
ldoc:
["Edits one or more properties of the instance. \nDeduced properties (e.g. accelText) are recalculated."],
params:
[["args",[["hash",
["Properties to mixin to this object."]]]]],
loc: [320,2,328,3]}
,"bd.command.item.fixup":{
type:
Tfunction,
sdoc:
["Inspects all properties of a command item and attempts to derive properties not explicitly specified."],
imember:1,
ldoc:
["The following properties are derived:\n\n  * If the value at groupId is identical to bd.defaultValue, then it is set to the value at parentMenuId.\n\n  * The value at text is searched for any character preceeded by a backslash. Any such character is assumed to be\n    a menu hot key.  A backslash is escaped by writing two consecutive backslashes. A backslash is given as a menu hot key by writing three consecutive backslashes.\n\n  * The value at htmlText is derived by surrounding any menu hot key (say \'x\') with \"<span class=\'hotKey\'>x</span>\" and\n    removing the accompanying backslash.\n\n  * The value cleanedText is derived by removing any menu hot key backslash characters\n\n  * If the value at accelKey is a character and a shift state is given, then the value is converted to a keyCode.\n\n  * If no value is given at accelText, then a value is manufactured from accelKey and accelShift if possible.\n\n  * If statusText===bd.defaultValue, then a value is manufacture. See source for details.\n\n  * If tooltipText===bd.defaultValue, then it is set to the value at statusText\n\n  * If helpUrl===bd.defaultValue, then a value is manufactured equivalent to <span class=\"placeholder\">groupId</span>#<span class=\"placeholder\">id</span>"],
loc: [330,2,440,3]}
,"bd.command.item.getIcon":{
type:
Tfunction,
sdoc:
["Derives a HTML class name that gives the icon based on the values of enabledIcon, disabledIcon, and disabled."],
imember:1,
ldoc:
[],
loc: [442,2,455,3]}
,"bd.command.namespace":{
type:
Tclass,
sdoc:
["bd.namespace-derived class used for the global command item cache (bd.command.itemCache)."],
ldoc:
[],
src:
"bd/command/item",
loc: [458,0,592,2],
supers:
["bd.namespace"],
module:"bd/command/item"}
,"bd.command.namespace.set":{
type:
Tfunction,
sdoc:
["Adds a new command item to the namespace at item.id. "],
imember:1,
ldoc:
["Adds a new command item to the namespace at item.id. If the command\ngiven by item.id already exists in the namespace, then it is replaced."],
params:
[["item",[["bd.command.item",
["The command item to add to the cache."]]]]],
loc: [476,2,485,3]}
,"bd.command.namespace.get":{
type:
Tfunction,
sdoc:
["Returns the command item given by id from the namespace."],
imember:1,
ldoc:
[],
params:
[["id",[["bd.command.id",
["Identifies the command item to retrieve."]]]]],
loc: [487,2,496,3]}
,"bd.command.namespace.modify":{
type:
Tfunction,
sdoc:
["Modifies the properties of the command item given by id as given by props."],
imember:1,
ldoc:
[],
params:
[["id",[["bd.command.id",
["identifies the command item to retrieve"]]]],
["props",[["hash",
["the properties to mixin into the comamnd item"]]]]],
loc: [498,2,506,3]}
,"bd.command.namespace.process":{
type:
Tfunction,
sdoc:
["Computes any dependent itemOrder properties, then compute all derived groupOrder properties."],
imember:1,
ldoc:
[],
loc: [508,2,591,3]}
,"bd.command.itemCache":{
type:
Tvariable,
sdoc:
["(bd.command.namespace) The global cache of command items."],
ldoc:
[],
src:
"bd/command/item",
loc: [595,2,598,30],
module:"bd/command/item"}
,"bd.command.getItem":{
type:
Tfunction,
sdoc:
["Returns the command item given by id from the global command item cache."],
ldoc:
[],
params:
[["id",[["bd.command.id",
["The item to retrieve."]]]]],
returns:
[["bd.command.item",
["The command item in the global command cache with id==id."]]],
src:
"bd/command/item",
loc: [600,2,608,3],
module:"bd/command/item"}
,"bd.command.addItem":{
type:
Tfunction,
sdoc:
["Creates a new bd.command.item and adds it to the global command item cache (bd.command.itemCache)."],
ldoc:
[],
params:
[["args",[["bd.command.item.constructor.kwargs",
["arguments to provide to the bd.command.item constructor"]]]]],
returns:
[["bd.command.namespace",
["bd.command.itemCache."]]],
src:
"bd/command/item",
loc: [610,2,618,3],
module:"bd/command/item"}
,"bd.command.addItems":{
type:
Tfunction,
sdoc:
["Adds a set of new bd.command.item objects to the global command item cache (bd.command.itemCache)."],
ldoc:
[],
params:
[["items",[["array of bd.command.item.constructor.kwargs",
["Set of args to provide to the bd.command.item constructor."]]]]],
returns:
[["bd.command.namespace",
["bd.command.itemCache."]]],
src:
"bd/command/item",
loc: [620,2,631,3],
module:"bd/command/item"}
,"bd.command.modifyItem":{
type:
Tfunction,
sdoc:
["Modifies the properties of the command item in the global command item cache (bd.command.itemCache)\ngiven by id as given by props."],
ldoc:
[],
params:
[["id",[["bd.command.id",
["The command item to modify."]]]],
["props",[["hash",
["The properties to mixin into the command item."]]]]],
returns:
[["bd.command.namespace",
["bd.command.itemCache."]]],
src:
"bd/command/item",
loc: [633,2,644,3],
module:"bd/command/item"}
,"bd.command.removeItem":{
type:
Tfunction,
sdoc:
["Removes the command item given by id from the global cache (bd.command.itemCache)."],
ldoc:
[],
params:
[["id",[["bd.command.id",
["The command item to remove."]]]]],
returns:
[["bd.command.namespace",
["bd.command.itemCache."]]],
src:
"bd/command/item",
loc: [646,2,654,3],
module:"bd/command/item"}
,"bd.command.compare":{
type:
Tfunction,
sdoc:
["Compares the relative order of (lhs ? rhs). "],
ldoc:
["Compares the relative order of (lhs ? rhs). \nCommand items are ordered most-significant to least significant by (groupOrder, itemOrder, text)."],
params:
[["lhs",[["bd.command.id",
["the left-hand-side of the comparison"]]]],
["rhs",[["bd.command.id",
["the right-hand-side of the comparison"]]]]],
src:
"bd/command/item",
loc: [656,2,679,3],
module:"bd/command/item"}
,"bd.command.itemIdsInOrder":{
type:
Tfunction,
sdoc:
["Sorts the contents of a menu as given bye bd.command.compare."],
ldoc:
[],
params:
[["menuContents",[["hash with keys of bd.command.id",
["The contents of a menu."]]]]],
returns:
[["array of bd.command.id",
["sorted by order as given by bd.command.compare"]]],
src:
"bd/command/item",
loc: [682,2,694,3],
module:"bd/command/item"}
,"bd.command.deduceMenu":{
type:
Tfunction,
sdoc:
["Constructs a bd.command.menuTree that contains exactly the commands given in commandSet."],
ldoc:
[],
params:
[["commandSet",[["array or id",
["The commands to form into a menu object."]]]]],
src:
"bd/command/item",
loc: [696,2,740,3],
module:"bd/command/item"}
,"modules.bd/command/item":{
type:
Tmodule,
sdoc:
["Augments the bd.command namespace with the Backdraft command item machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/command/item",
loc: [0,0,745,2]}
,"resources.bd/connect":{
type:
Tresource,
sdoc:
["Defines the module bd/connect"],
src:
"bd/connect",
modules:
["bd/connect"],
code:
["dojo.def(\"bd/connect\", [\"bd/kernel\", \"dojo\", \"bd/declare\"], function(bd, dojo) {",
"///",
"// Augments the bd namespace with machinery that extends the dojo connection framework.",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load the module bd. See module.bd.",
"",
"bd.connect= function(",
"  src,     ///(object) The object that contains event.",
"           //(falsy) bd.global is the object that contains the event.",
"  event,   ///(string) The function name in src that generates the event.",
"           //(function) The function is src that generates the event.",
"  watcher, ///(string) The function name in dest that wants to watch the event.",
"           //(function) The function in dest that wants to watch the event.",
"  dest,    ///(object) The object that contains watcher.",
"           //(falsy) bd.global contains watcher.",
"  vargs    ///(variableArgs, optional) Zero or more arguments to automatically apply to watcher before any event arguments.",
") {",
"  ///",
"  // dojo.connect with additional features.",
"  ///",
"  // As with all Backdraft functions that take a callback-like function argument, `(watcher, dest, vargs)`",
"  // is transformed to `bd.hitch(dest, watcher, arg1, arg2, ...)`.",
"  //warn",
"  // Owing to the bd.connect function signature, the dojo.connect argument dontFix is not available.",
"  ///",
"  // For example,",
"  //code",
"  // bd.connect(myWidget, \"click\", \"myWatcher\", myController, \"this is a test\");",
"  ///",
"  // results in the following (as other functionality discussed next)...",
"  //code",
"  // dojo.connect(myWidget, \"click\", bd.hitch(myController, \"myWatcher\", \"this is a test\"));",
"  ///",
"  // Unlike dojo.connect, bd.connect advises both the event and watcher sources if they contain the functions",
"  // adviseEventSource and adviseEventWatcher, respectively. Additionally, the handle returned is a full-fledged ",
"  // object that contains information about the connection and the method `disconnect` to facilitate ",
"  // disconnection (and prevent double-disconnects). See bd.connect.handle for details.",
"  return new bd.connect.handle(src || bd.global, event, dest || bd.global, watcher, dojo.connect(src, event, 0, bd.hitchCallback(arguments, 2)), dojoDisconnect);",
"};",
"",
"var dojoDisconnect= function(handle) {",
"  dojo.disconnect(handle);",
"};",
"",
"bd.disconnect= function(",
"  handle ///(bd.connect.handle) A handle returned by bd.connect.",
") {",
"  ///",
"  // Equivalent to `handle.disconnect()`.",
"  handle.disconnect();",
"};",
"",
"bd.subscribe= function(",
"  topic,   ///(string) The topic to subscribe to.",
"  watcher, ///(string) The function name is dest that wants to watch the topic.",
"           //(function) The function in dest that wants to watch the topic.",
"  dest,    ///(object) The object that contains watcher.",
"           //(falsy) bd.global contains watcher.",
"  vargs    ///(variableArgs, optional) Zero or more arguments to automatically apply to watcher before any topic arguments.",
") {",
"  ///",
"  // dojo.subscribe with additional features.",
"  ///",
"  // As with all Backdraft functions that take a callback-like function argument, `(watcher, dest, vargs)`",
"  // is transformed to `bd.hitch(dest, watcher, arg1, arg2, ...)`.",
"  // For example,",
"  //code",
"  // bd.subscribe(\"some/cool/topic\", \"myWatcher\", myController, \"this is a test\");",
"  ///",
"  // results in the following (as other functionality discussed next)...",
"  //code",
"  // dojo.subscribe(\"some/cool/topic\", bd.hitch(myController, \"myWatcher\", \"this is a test\"));",
"  ///",
"  // Unlike dojo.subscribe, bd.subscribe advises the watcher if it contains the function",
"  // adviseEventWatcher. Additionally, the handle returned is a full-fledged object with that contains information",
"  // about the connection and the method disconnect to facilitate disconnection (and prevent double-disconnects). See",
"  // bd.connect.handle.",
"  return new bd.connect.handle(dojo.publish, topic, dest, watcher, dojo.subscribe(topic, bd.hitchCallback(arguments, 1)), dojoUnsubscribe);",
"};",
"",
"var dojoUnsubscribe= function(handle) {",
"  dojo.unsubscribe(handle);",
"};",
"",
"bd.unsubscribe= function(",
"  handle ///(bd.connect.handle) A handle returned by bd.subscribe.",
") {",
"  ///",
"  // Equivalent to `handle.disconnect()`.",
"  handle.disconnect();",
"};",
"",
"",
"bd.declare(",
"  ///",
"  // Manages connecting and disconnection events and watchers.",
"  ///",
"  // Construction of an object causes src.adviseEventSource (if any) and dest.adviseEventWatcher (if any) to be applied, thereby signaling",
"  // a connection.",
"  // ",
"  // The disconnect method causes the connection to be taken down via the disconnector property and src.adviseEventSource (if any)",
"  // and dest.adviseEventWatcher (if any) to be applied, thereby signalling a disconnection. The subsequent disconnects result in no-ops",
"  // and are therefore harmless.",
"  // ",
"  // This functionality can be used to define objects that ensure that all references are taken down when they are explicitly",
"  // destroyed. For the canonical example, study bd.visual.",
"",
"  //class name",
"  \"bd:connect.handle\",",
"",
"  //superclasses",
"  [], ",
"",
"  //members",
"  {",
"  src:",
"    ///",
"    //(any) The object that contains the event.",
"    ///",
"    // See bd.connect.handle.constructor.",
"    0,",
"",
"  event:",
"    ///",
"    //(function) The function in src that is being watched.",
"    //(string) The function name in src that is being watched.",
"    ///",
"    // See bd.connect.handle.constructor.",
"    0,",
"",
"  dest:",
"    ///",
"    //(any) The object that contains the watcher",
"    ///",
"    // See bd.connect.handle.constructor.",
"    0,",
"",
"  watcher:",
"    ///",
"    //(function) The function in dest that is watcheding",
"    //(string) The function name in dest that is watching",
"    ///",
"    // See bd.connect.handle.constructor.",
"    0,",
"",
"  handle:",
"    ///",
"    //(any) Opaque object that informs disconnector how to disconnect.",
"    ///",
"    // See bd.connect.handle.constructor.",
"    0,",
"",
"  disconnector:",
"    ///",
"    //(function(handle)) Disconnects src.event from dest.water given handle.",
"    ///",
"    // See bd.connect.handle.constructor.",
"    0,",
"",
"  uid:",
"    ///",
"    //(string) Legal JavaScript identifier as generated by bd.uid.",
"    ///",
"    // An application-wide unique identifier.",
"    bd.noDoc,",
"",
"  constructor: function(",
"    src,         ///(object) The object that contains event.",
"    event,       ///(string) The function name in src that generates the event.",
"                 //(function) The function is src that generates the event.",
"    dest,        ///(object) The object that contains watcher.",
"    watcher,     ///(string) The function name is dest that wants to watch the event.",
"                 //(function) The function in dest that wants to watch the event.",
"    handle,      ///(any) The handle returned by connecting function.",
"    disconnector ///(function(handle)) The function to call to disconnect handle.",
"  ) {",
"    ///",
"    // Initializes a connection from src.event to dest.watcher and causes src.adviseEventSource (if any) and ",
"    // dest.adviseEventWatcher (if any) to be applied signalling a connection.",
"    this.src= src;",
"    this.event= event;",
"    this.dest= dest;",
"    this.watcher= watcher;",
"    this.handle= handle;",
"    this.disconnector= disconnector;",
"    this.uid= bd.uid();",
"  },",
"",
"  postscript: function() {",
"    var o= this.src;",
"    if (o && bd.isFunction(o.adviseEventSource)) {",
"      o.adviseEventSource(this, true);",
"    }",
"    o= this.dest;",
"    if (o && bd.isFunction(o.adviseEventWatcher)) {",
"      o.adviseEventWatcher(this, true);",
"    }",
"  },",
"",
"  disconnect: function() {",
"    ///",
"    // Disconnects a connection made by bd.connect.",
"    ///",
"    // Call dojo.disconnect as usual. Additionally calls event src.adviseEventSource and dest.adviseEventSource iff they exist.",
"    if (!this.src) {",
"      return;",
"    }",
"    var o= this.src;",
"    if (o && bd.isFunction(o.adviseEventSource)) {",
"      o.adviseEventSource(this, false);",
"    }",
"    o= this.dest;",
"    if (o && bd.isFunction(o.adviseEventWatcher)) {",
"      o.adviseEventWatcher(this, false);",
"    }",
"    this.disconnector(this.handle);",
"    this.src= this.event= this.dest= this.watcher= this.handle= this.disconnector= 0;",
"  }",
"});",
"",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.connect":{
type:
Tfunction,
sdoc:
["dojo.connect with additional features."],
ldoc:
["As with all Backdraft functions that take a callback-like function argument, `(watcher, dest, vargs)`\nis transformed to `bd.hitch(dest, watcher, arg1, arg2, ...)`.",
[WARN,"Owing to the bd.connect function signature, the dojo.connect argument dontFix is not available."],
"For example,",
[CODE,"bd.connect(myWidget, \"click\", \"myWatcher\", myController, \"this is a test\");"],
"results in the following (as other functionality discussed next)...",
[CODE,"dojo.connect(myWidget, \"click\", bd.hitch(myController, \"myWatcher\", \"this is a test\"));"],
"Unlike dojo.connect, bd.connect advises both the event and watcher sources if they contain the functions\nadviseEventSource and adviseEventWatcher, respectively. Additionally, the handle returned is a full-fledged\nobject that contains information about the connection and the method `disconnect` to facilitate\ndisconnection (and prevent double-disconnects). See bd.connect.handle for details."],
params:
[["src",[["object",
["The object that contains event."]],
["falsy",
["bd.global is the object that contains the event."]]]],
["event",[["string",
["The function name in src that generates the event."]],
["function",
["The function is src that generates the event."]]]],
["watcher",[["string",
["The function name in dest that wants to watch the event."]],
["function",
["The function in dest that wants to watch the event."]]]],
["dest",[["object",
["The object that contains watcher."]],
["falsy",
["bd.global contains watcher."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments to automatically apply to watcher before any event arguments."]]]]],
src:
"bd/connect",
loc: [7,0,39,1],
module:"bd/connect"}
,"bd.disconnect":{
type:
Tfunction,
sdoc:
["Equivalent to `handle.disconnect()`."],
ldoc:
[],
params:
[["handle",[["bd.connect.handle",
["A handle returned by bd.connect."]]]]],
src:
"bd/connect",
loc: [45,0,51,1],
module:"bd/connect"}
,"bd.subscribe":{
type:
Tfunction,
sdoc:
["dojo.subscribe with additional features."],
ldoc:
["As with all Backdraft functions that take a callback-like function argument, `(watcher, dest, vargs)`\nis transformed to `bd.hitch(dest, watcher, arg1, arg2, ...)`.\nFor example,",
[CODE,"bd.subscribe(\"some/cool/topic\", \"myWatcher\", myController, \"this is a test\");"],
"results in the following (as other functionality discussed next)...",
[CODE,"dojo.subscribe(\"some/cool/topic\", bd.hitch(myController, \"myWatcher\", \"this is a test\"));"],
"Unlike dojo.subscribe, bd.subscribe advises the watcher if it contains the function\nadviseEventWatcher. Additionally, the handle returned is a full-fledged object with that contains information\nabout the connection and the method disconnect to facilitate disconnection (and prevent double-disconnects). See\nbd.connect.handle."],
params:
[["topic",[["string",
["The topic to subscribe to."]]]],
["watcher",[["string",
["The function name is dest that wants to watch the topic."]],
["function",
["The function in dest that wants to watch the topic."]]]],
["dest",[["object",
["The object that contains watcher."]],
["falsy",
["bd.global contains watcher."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments to automatically apply to watcher before any topic arguments."]]]]],
src:
"bd/connect",
loc: [53,0,79,1],
module:"bd/connect"}
,"bd.unsubscribe":{
type:
Tfunction,
sdoc:
["Equivalent to `handle.disconnect()`."],
ldoc:
[],
params:
[["handle",[["bd.connect.handle",
["A handle returned by bd.subscribe."]]]]],
src:
"bd/connect",
loc: [85,0,91,1],
module:"bd/connect"}
,"bd.connect.handle":{
type:
Tclass,
sdoc:
["Manages connecting and disconnection events and watchers."],
ldoc:
["Construction of an object causes src.adviseEventSource (if any) and dest.adviseEventWatcher (if any) to be applied, thereby signaling\na connection.\n\nThe disconnect method causes the connection to be taken down via the disconnector property and src.adviseEventSource (if any)\nand dest.adviseEventWatcher (if any) to be applied, thereby signalling a disconnection. The subsequent disconnects result in no-ops\nand are therefore harmless.\n\nThis functionality can be used to define objects that ensure that all references are taken down when they are explicitly\ndestroyed. For the canonical example, study bd.visual."],
src:
"bd/connect",
loc: [94,0,219,2],
module:"bd/connect"}
,"bd.connect.handle.src":{
type:
Tvariable,
sdoc:
["See bd.connect.handle.constructor."],
imember:1,
ldoc:
[],
loc: [116,2,121,5],
types:
[["any",
["The object that contains the event."]]]}
,"bd.connect.handle.event":{
type:
Tvariable,
sdoc:
["See bd.connect.handle.constructor."],
imember:1,
ldoc:
[],
loc: [123,2,129,5],
types:
[["function",
["The function in src that is being watched."]],
["string",
["The function name in src that is being watched."]]]}
,"bd.connect.handle.dest":{
type:
Tvariable,
sdoc:
["See bd.connect.handle.constructor."],
imember:1,
ldoc:
[],
loc: [131,2,136,5],
types:
[["any",
["The object that contains the watcher"]]]}
,"bd.connect.handle.watcher":{
type:
Tvariable,
sdoc:
["See bd.connect.handle.constructor."],
imember:1,
ldoc:
[],
loc: [138,2,144,5],
types:
[["function",
["The function in dest that is watcheding"]],
["string",
["The function name in dest that is watching"]]]}
,"bd.connect.handle.handle":{
type:
Tvariable,
sdoc:
["See bd.connect.handle.constructor."],
imember:1,
ldoc:
[],
loc: [146,2,151,5],
types:
[["any",
["Opaque object that informs disconnector how to disconnect."]]]}
,"bd.connect.handle.disconnector":{
type:
Tvariable,
sdoc:
["See bd.connect.handle.constructor."],
imember:1,
ldoc:
[],
loc: [153,2,158,5],
types:
[["function(handle)",
["Disconnects src.event from dest.water given handle."]]]}
,"bd.connect.handle.uid":{
type:
Tvariable,
sdoc:
["An application-wide unique identifier."],
imember:1,
ldoc:
[],
loc: [160,2,165,12],
types:
[["string",
["Legal JavaScript identifier as generated by bd.uid."]]]}
,"bd.connect.handle.constructor":{
type:
Tfunction,
sdoc:
["Initializes a connection from src.event to dest.watcher and causes src.adviseEventSource (if any) and\ndest.adviseEventWatcher (if any) to be applied signalling a connection."],
imember:1,
ldoc:
[],
params:
[["src",[["object",
["The object that contains event."]]]],
["event",[["string",
["The function name in src that generates the event."]],
["function",
["The function is src that generates the event."]]]],
["dest",[["object",
["The object that contains watcher."]]]],
["watcher",[["string",
["The function name is dest that wants to watch the event."]],
["function",
["The function in dest that wants to watch the event."]]]],
["handle",[["any",
["The handle returned by connecting function."]]]],
["disconnector",[["function(handle)",
["The function to call to disconnect handle."]]]]],
loc: [167,2,187,3]}
,"bd.connect.handle.disconnect":{
type:
Tfunction,
sdoc:
["Disconnects a connection made by bd.connect."],
imember:1,
ldoc:
["Call dojo.disconnect as usual. Additionally calls event src.adviseEventSource and dest.adviseEventSource iff they exist."],
loc: [200,2,218,3]}
,"modules.bd/connect":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with machinery that extends the dojo connection framework."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load the module bd. See module.bd."]],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/connect",
loc: [0,0,222,2]}
,"resources.bd/connectable":{
type:
Tresource,
sdoc:
["Defines the module bd/connectable"],
src:
"bd/connectable",
modules:
["bd/connectable"],
code:
["dojo.def(\"bd/connectable\", [",
"  \"bd\", ",
"  \"bd/lang\", ",
"  \"bd/collections\", ",
"  \"bd/connect\"",
"], function(bd) {",
"///",
"// Defines the bd.connectable class and associated machinery.",
"",
"bd.deferredWatcherSink= ",
"  function() {",
"    ///",
"    // A no-op function used as the connection point when a class does not explicitly define its own connection point.",
"    ///",
"    // See bd.connectable, bd.connectable.deferredConnects, and bd.makeDeferredConnects for more details.",
"  };",
"",
"bd.makeDeferredConnects= function(",
"  deferredConnects, ///(bd.deferedConnectSet) //TODOC",
"  supers            ///(zero or more constructor functions) Zero to many superclasses from which to get deferred connection information.",
") {",
"  ///",
"  // Helper function to build the per-class bd.connectable.deferredConnects property. //Automatically",
"  // generates stub methods for deferred-connectable events as implemented in bd.connectable. For example,",
"  //code",
"  // bd.declare([bd.connectable],",
"  //   bd.makeDeferredConnects({",
"  //     onFocus: [\"focus\", \"domNode\"], ",
"  //     onClick: [\"click\", \"domNode\"]}",
"  //   );",
"  // );",
"  ///",
"  // Is equivalent to...",
"  //code",
"  // bd.declare([bd.connectable],",
"  //   deferredConnects: {",
"  //     onFocus: [\"focus\", \"domNode\"], ",
"  //     onClick: [\"click\", \"domNode\"]",
"  //   },",
"  //   onFocus: bd.deferredWatcherSink;",
"  //   onClick: bd.deferredWatcherSink;",
"  // );",
"  ///",
"  // The deferredConnects contents in each of the supers (if any) is included in the result. This information",
"  // is computed before the deferredConnects argument is computed and in the order given. This algorithm causes information",
"  // in deferredConnects to take precidence over information about the same",
"  // connection point in any super, and, similarly, information in the last super given to take precidence over information",
"  // in any previous super for any particular connection point. For example,",
"  //code",
"  // var",
"  //   A= bd.declare(",
"  //     // supers",
"  //     [],",
"  // ",
"  //     bd.makeDeferredConnects({",
"  //       onEvent1: [\"event1A\"]",
"  //       onEvent2: [\"event2A\"]",
"  //       onEvent3: [\"event3A\"]",
"  //     })",
"  //     // ...",
"  //   ),",
"  // ",
"  //   B= bd.declare(",
"  //     // supers",
"  //     [],",
"  // ",
"  //     bd.makeDeferredConnects({",
"  //       onEvent1: [\"event1B\"]",
"  //       onEvent3: [\"event3A\"]",
"  //     })",
"  //     // ...",
"  //   ),",
"  // ",
"  //   C= bd.declare(",
"  //     // supers",
"  //     [A, B],",
"  //     ",
"  //     bd.makeDeferredConnects({",
"  //       onEvent3: [\"event3C\"]",
"  //     },",
"  //     A, B)",
"  //     // ...",
"  //   ),",
"  ///",
"  // The `deferredConnects` object created by bd.makeDeferredConnects in C\'s definition contains:",
"  // ",
"  //   * `onEvent3: [\"event3C\"]` since the deferredConnects argument overides all super arguments.",
"  //   * `onEvent1: [\"event1B\"]` since the the super B comes after the super A, its deffered connection info",
"  //     for the connection point onEvent1 wins over A\'s information.",
"  //   * `onEvent2: [\"event2A]` since neither C nor B define this connection point and A was provided as a super to",
"  //     makeDeferredConnects.",
"  var result= {}, protoProps= {};",
"  for (var i= 1; i<arguments.length; i++) {",
"    bd.forEachHash(arguments[i].prototype.deferredConnects, function(rootEventSourceInfo, connectionPoint) {",
"      result[connectionPoint]= rootEventSourceInfo;",
"    });",
"  }",
"  bd.forEachHash(deferredConnects, function(rootEventSourceInfo, connectionPoint) {",
"    if (connectionPoint!=\"useEventSource\" && connectionPoint!=\"otherSupers\") {",
"      result[connectionPoint]= rootEventSourceInfo;",
"      protoProps[connectionPoint]= bd.deferredWatcherSink;",
"    }",
"  });",
"  protoProps.deferredConnects= result;",
"  return protoProps;",
"};",
"",
"bd.declare(",
"  ///",
"  // Mixin class that manages connections from, to, and within instances. ",
"  ///",
"  // This class provides adviseEventSource and adviseEventWatcher methods to keep track of connections to/from individiual instances as well as a destroy method that",
"  // disconnects all existing connections. This can be used to ease the burden of eliminating circular",
"  // references and thereby improve the performance of the JavaScript garbage collector.",
"  // ",
"  // The class also provides an implementation of \"deferred connectable events\". The idea is to define",
"  // a class that has the capability of signaling events but only make the necessary connections if",
"  // a client when demanded. This allows classes to provide rich",
"  // connection point interfaces without suffering the cost of making any of the connections until",
"  // a client actually connects.",
"  // ",
"  // Each potential connection is defined by a source event and a connection point. The connection point is always an instance method;",
"  // the source event may be any function or DOM event; see bd.connectable.deferredConnects for details.",
"  // Until and unless a client makes a connection to",
"  // the connection point no connections are made. However, when the first client attempts to connect to a connection point",
"  // by `bd.connect`, two connections are made: (1) a connection between the source event and the connection point, and (2) a connection",
"  // between the connection point and the client watcher. For example, assume you\'ve defined a class that has the source event",
"  // (this.domNode, \"click\") and the connection point \"onClick\". When some client attempts to connect to the `onClick` connection",
"  // point on a particular instance of your class by executing `bd.connect(someInstance, \"onClick\", clientListener)`, `bd.connectable`",
"  // automatically makes the connection `bd.connect(this.domNode, \"click\", this, \"onClick\")`.",
"  // ",
"  // Notice that the connection point functions as both a watcher and an event source: it watches the source event, and then",
"  // sources that event to other watchers.",
"  // ",
"  // Another use for this machinery is to allow subclasses to define non-trivial connection point methods and (1) be free of the burden",
"  // of connecting to the source event, and (2) maintain a single, orderly flow from source events to any number of",
"  // watchers.",
"  // ",
"  // At the point in a class hierarchy that a deferred event is defined, a connection point for the deferred event *must* also be defined. If",
"  // the defining class has no need to watch the source event itself, then is must define the connection point  method to be",
"  // identical to bd.deferredWatcherSink. This causes the constructor to *not* connect the source event to",
"  // the connection point until some external client demands the connection. The convenience function bd.makeDeferredConnects is available to",
"  // automatically generate these function definitions.",
"  //warn",
"  // This class requires a postscript process to properly find and connect all non-trivial connection points. Often,",
"  // this class is used in a hierarchy that includes bd.visual which includes a sufficient postscript process. If",
"  // you are using this class in a derivation chain where no other class includes a postscript, then a default postscript",
"  // is supplied; if using this class in a derivation chain that includes a postscript, then ensure that this class\'s",
"  // postscript (or equivalent) is applied during the creation process.",
"",
"  //class name",
"  \"bd:connectable\",",
"",
"  //superclasses",
"  [], ",
"",
"  //members",
"  {",
"  deferredConnects: ",
"    ///",
"    // Map from connection points to event sources. //The map type is defined as ",
"    // {``connection-point-name``(string) --> [``source-event``(string or function), ``source-event-context``(string, falsy, object, optional)])}.",
"    // ",
"    // `classattr",
"    // ",
"    // For the source event:",
"    // ",
"    // * `[\"someMethodName\"]` implies `this[\"someMethodName\"]`.",
"    // * `[someFunction]` implies the function `someFunction`.",
"    // * `[\"somePropertyName\", someObject]` implies the function `someObject[\"somePropertyName\"]`",
"    // * `[\"someEventName\", someDomNode]` implies the DOM event `\"someEventName\"` on someDomNode and therefore `addEventListener` is used to connect.",
"    // * `[\"someEventName\", \"somePropertyName\"]` implies the function `this[\"somePropertyName\"][\"someEventName\"]`; notice",
"    //   if `this[\"somePropertyName\"]` is a DOM node then `addEventListener` is used to connect.",
"    // ",
"    // An entry in the map causes `bd.connect(``source-event``, ``connection-point-name``, this)` to executed the first time ",
"    // either of the following conditions are detected:",
"    // ",
"    //   * `this[``connection-point-name``]` is detected to be something other than `bd.deferredWatcherSink` at construction.",
"    //   * an attempt is made to connect to `this[``connection-point-name``]`",
"    // ",
"    // For classes derived from bd.connectable, simply defining a non-trivial connection point will automatically cause the",
"    // source event to be connected to the connection point. For example,",
"    //code",
"    // var myClass= bd.declare([bd.connectable], {",
"    //   deferredConnects: {onFocus: [\"focus\", \"domNode\"], onClick: [\"click\", \"domNode\"]},",
"    //   //etc.",
"    // });",
"    // ",
"    // var myClass= bd.declare(\"mySubclass\", [myClass], {",
"    //   onFocus: function() {",
"    //     //do something spectacular!",
"    //   }",
"    // });",
"    // ",
"    // var o= new mySubclass();",
"    // // At this point bd.connect(this.domNode, \"focus\", \"onFocus\", this) has automatically been connected,",
"    // // but click has not!",
"    ///",
"    // Simply connecting to a connection point will be noticed and cause the connection point to be connected to the event source. For example,",
"    //code",
"    // // continuing from above...",
"    // bd.connect(o, \"onClick\", \"someHandler\", someController);",
"    // // causes two connects...",
"    // //",
"    // //   1. bd.connect(o.domNode, \"click\", \"onClick\", o);",
"    // //   2. bd.connect(o, \"onClick\", \"someHandler\", someContoller);",
"    {},",
"",
"  deferredConnected:",
"    ///",
"    // Map that holds the handle that was returned when source event was connected in an instance of this class. //The map type is defined as ",
"    // {``connection-point``(string) --> bd.connect.handle}.",
"    // `private",
"    // `nosource",
"    0,",
"",
"  connects:",
"    ///",
"    // Map that holds each bd.connect.handle that manages a connection to/from an instance of this class. //The map type is defined as ",
"    // {bd.connect.handle.uid --> bd.connect.handle}.",
"    // `private",
"    // `nosource",
"    0,",
"",
"  connectConnectionPoint: function(",
"    connectionPointName",
"  ) {",
"    if (!this.deferredConnected[connectionPointName]) {",
"      var ",
"        eventSourceInfo= this.deferredConnects[connectionPointName],",
"        event= eventSourceInfo[0],",
"        source= eventSourceInfo[1] || this.deferredSource || this;",
"      bd.isString(source) && (source= this[source]);",
"      this.deferredConnected[connectionPointName]= bd.connect(source, event, connectionPointName, this);",
"    }",
"  },",
"",
"  postcreateDom: function() {",
"    // connect up deferred connects if there\'s a non-trivial handler defined...",
"    this.inherited(arguments);",
"    this.connects= {};",
"    this.deferredConnected= {};",
"    var deferredWatcherSink= bd.deferredWatcherSink;",
"    bd.forEachHash(this.deferredConnects, function(eventSourceInfo, connectionPointName) {",
"      if (this[connectionPointName]!==deferredWatcherSink) {",
"        this.connectConnectionPoint(connectionPointName);",
"      }",
"    }, this);",
"  },",
"",
"  destroy: function() {",
"    ///",
"    // Disconnect all connections made to and from this object.",
"",
"    // can\'t just iterate through connects because disconnect calls this.advise* which modifies connects",
"    bd.forEachHashSafe(this.connects, function(handle, uid) {",
"      handle.disconnect();",
"    });",
"    bd.forEachHashSafe(this.deferredConnected, function(handle, connectionPointName) {",
"      handle.disconnect();",
"    });",
"  },",
"",
"  adviseEventSource: function(",
"    handle,    ///(bd.connect.handle) Information about the connection.",
"    connecting ///(boolean) true if connecting, false if disconnecting.",
"  ) {",
"    ///",
"    // Records this instance serves an event source. //Automatically called by bd.connect; see bd.connect.",
"    //note",
"    // Typically, this method is not applied by client code; instead, it is called automatically by bd.connect.",
"    if (connecting) {",
"      this.connects[handle.uid]= handle;",
"      this.deferredConnects[handle.event] && this.connectConnectionPoint(handle.event);",
"    } else {",
"      delete this.connects[handle.uid];",
"    }",
"  },",
"",
"  adviseEventWatcher: function(",
"    handle,    ///(bd.connect.handle) Information about the connection.",
"    connecting ///(boolean) true if connecting, false if disconnecting.",
"  ) {",
"    ///",
"    // Records this instance serves an event watcher. //Automatically called by bd.connect; see bd.connect.",
"    //note",
"    // Typically, this method is not applied by client code; instead, it is called automatically by bd.connect.",
"    if (connecting) {",
"      this.connects[handle.uid]= handle;",
"    } else {",
"      delete this.connects[handle.uid];",
"    }",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.deferredWatcherSink":{
type:
Tfunction,
sdoc:
["A no-op function used as the connection point when a class does not explicitly define its own connection point."],
ldoc:
["See bd.connectable, bd.connectable.deferredConnects, and bd.makeDeferredConnects for more details."],
src:
"bd/connectable",
loc: [9,0,15,3],
module:"bd/connectable"}
,"bd.makeDeferredConnects":{
type:
Tfunction,
sdoc:
["Helper function to build the per-class bd.connectable.deferredConnects property. "],
ldoc:
["Helper function to build the per-class bd.connectable.deferredConnects property. Automatically\ngenerates stub methods for deferred-connectable events as implemented in bd.connectable. For example,",
[CODE,"bd.declare([bd.connectable],\n  bd.makeDeferredConnects({\n    onFocus: [\"focus\", \"domNode\"],\n    onClick: [\"click\", \"domNode\"]}\n  );\n);"],
"Is equivalent to...",
[CODE,"bd.declare([bd.connectable],\n  deferredConnects: {\n    onFocus: [\"focus\", \"domNode\"],\n    onClick: [\"click\", \"domNode\"]\n  },\n  onFocus: bd.deferredWatcherSink;\n  onClick: bd.deferredWatcherSink;\n);"],
"The deferredConnects contents in each of the supers (if any) is included in the result. This information\nis computed before the deferredConnects argument is computed and in the order given. This algorithm causes information\nin deferredConnects to take precidence over information about the same\nconnection point in any super, and, similarly, information in the last super given to take precidence over information\nin any previous super for any particular connection point. For example,",
[CODE,"var\n  A= bd.declare(\n    // supers\n    [],\n\n    bd.makeDeferredConnects({\n      onEvent1: [\"event1A\"]\n      onEvent2: [\"event2A\"]\n      onEvent3: [\"event3A\"]\n    })\n    // ...\n  ),\n\n  B= bd.declare(\n    // supers\n    [],\n\n    bd.makeDeferredConnects({\n      onEvent1: [\"event1B\"]\n      onEvent3: [\"event3A\"]\n    })\n    // ...\n  ),\n\n  C= bd.declare(\n    // supers\n    [A, B],\n\n    bd.makeDeferredConnects({\n      onEvent3: [\"event3C\"]\n    },\n    A, B)\n    // ...\n  ),"],
"The `deferredConnects` object created by bd.makeDeferredConnects in C\'s definition contains:\n\n  * `onEvent3: [\"event3C\"]` since the deferredConnects argument overides all super arguments.\n  * `onEvent1: [\"event1B\"]` since the the super B comes after the super A, its deffered connection info\n    for the connection point onEvent1 wins over A\'s information.\n  * `onEvent2: [\"event2A]` since neither C nor B define this connection point and A was provided as a super to\n    makeDeferredConnects."],
params:
[["deferredConnects",[["bd.deferedConnectSet",
["//TODOC"]]]],
["supers",[["zero or more constructor functions",
["Zero to many superclasses from which to get deferred connection information."]]]]],
src:
"bd/connectable",
loc: [17,0,105,1],
module:"bd/connectable"}
,"bd.connectable":{
type:
Tclass,
sdoc:
["Mixin class that manages connections from, to, and within instances."],
ldoc:
["This class provides adviseEventSource and adviseEventWatcher methods to keep track of connections to/from individiual instances as well as a destroy method that\ndisconnects all existing connections. This can be used to ease the burden of eliminating circular\nreferences and thereby improve the performance of the JavaScript garbage collector.\n\nThe class also provides an implementation of \"deferred connectable events\". The idea is to define\na class that has the capability of signaling events but only make the necessary connections if\na client when demanded. This allows classes to provide rich\nconnection point interfaces without suffering the cost of making any of the connections until\na client actually connects.\n\nEach potential connection is defined by a source event and a connection point. The connection point is always an instance method;\nthe source event may be any function or DOM event; see bd.connectable.deferredConnects for details.\nUntil and unless a client makes a connection to\nthe connection point no connections are made. However, when the first client attempts to connect to a connection point\nby `bd.connect`, two connections are made: (1) a connection between the source event and the connection point, and (2) a connection\nbetween the connection point and the client watcher. For example, assume you\'ve defined a class that has the source event\n(this.domNode, \"click\") and the connection point \"onClick\". When some client attempts to connect to the `onClick` connection\npoint on a particular instance of your class by executing `bd.connect(someInstance, \"onClick\", clientListener)`, `bd.connectable`\nautomatically makes the connection `bd.connect(this.domNode, \"click\", this, \"onClick\")`.\n\nNotice that the connection point functions as both a watcher and an event source: it watches the source event, and then\nsources that event to other watchers.\n\nAnother use for this machinery is to allow subclasses to define non-trivial connection point methods and (1) be free of the burden\nof connecting to the source event, and (2) maintain a single, orderly flow from source events to any number of\nwatchers.\n\nAt the point in a class hierarchy that a deferred event is defined, a connection point for the deferred event *must* also be defined. If\nthe defining class has no need to watch the source event itself, then is must define the connection point  method to be\nidentical to bd.deferredWatcherSink. This causes the constructor to *not* connect the source event to\nthe connection point until some external client demands the connection. The convenience function bd.makeDeferredConnects is available to\nautomatically generate these function definitions.",
[WARN,"This class requires a postscript process to properly find and connect all non-trivial connection points. Often,\nthis class is used in a hierarchy that includes bd.visual which includes a sufficient postscript process. If\nyou are using this class in a derivation chain where no other class includes a postscript, then a default postscript\nis supplied; if using this class in a derivation chain that includes a postscript, then ensure that this class\'s\npostscript (or equivalent) is applied during the creation process."]],
src:
"bd/connectable",
loc: [107,0,293,2],
module:"bd/connectable"}
,"bd.connectable.deferredConnects":{
type:
Tvariable,
sdoc:
["Map from connection points to event sources. "],
imember:1,
ldoc:
["Map from connection points to event sources. The map type is defined as\n{``connection-point-name``(string) --> [``source-event``(string or function), ``source-event-context``(string, falsy, object, optional)])}.",
"For the source event:\n\n* `[\"someMethodName\"]` implies `this[\"someMethodName\"]`.\n* `[someFunction]` implies the function `someFunction`.\n* `[\"somePropertyName\", someObject]` implies the function `someObject[\"somePropertyName\"]`\n* `[\"someEventName\", someDomNode]` implies the DOM event `\"someEventName\"` on someDomNode and therefore `addEventListener` is used to connect.\n* `[\"someEventName\", \"somePropertyName\"]` implies the function `this[\"somePropertyName\"][\"someEventName\"]`; notice\n  if `this[\"somePropertyName\"]` is a DOM node then `addEventListener` is used to connect.\n\nAn entry in the map causes `bd.connect(``source-event``, ``connection-point-name``, this)` to executed the first time\neither of the following conditions are detected:\n\n  * `this[``connection-point-name``]` is detected to be something other than `bd.deferredWatcherSink` at construction.\n  * an attempt is made to connect to `this[``connection-point-name``]`\n\nFor classes derived from bd.connectable, simply defining a non-trivial connection point will automatically cause the\nsource event to be connected to the connection point. For example,",
[CODE,"var myClass= bd.declare([bd.connectable], {\n  deferredConnects: {onFocus: [\"focus\", \"domNode\"], onClick: [\"click\", \"domNode\"]},\n  //etc.\n});\n\nvar myClass= bd.declare(\"mySubclass\", [myClass], {\n  onFocus: function() {\n    //do something spectacular!\n  }\n});\n\nvar o= new mySubclass();\n// At this point bd.connect(this.domNode, \"focus\", \"onFocus\", this) has automatically been connected,\n// but click has not!"],
"Simply connecting to a connection point will be noticed and cause the connection point to be connected to the event source. For example,",
[CODE,"// continuing from above...\nbd.connect(o, \"onClick\", \"someHandler\", someController);\n// causes two connects...\n//\n//   1. bd.connect(o.domNode, \"click\", \"onClick\", o);\n//   2. bd.connect(o, \"onClick\", \"someHandler\", someContoller);"]],
flags:
[Fclassattr],
loc: [158,2,206,6]}
,"bd.connectable.deferredConnected":{
type:
Tvariable,
sdoc:
["Map that holds the handle that was returned when source event was connected in an instance of this class. "],
imember:1,
ldoc:
["Map that holds the handle that was returned when source event was connected in an instance of this class. The map type is defined as\n{``connection-point``(string) --> bd.connect.handle}."],
flags:
[Fnosource,Fprivate],
loc: [208,2,214,5]}
,"bd.connectable.connects":{
type:
Tvariable,
sdoc:
["Map that holds each bd.connect.handle that manages a connection to/from an instance of this class. "],
imember:1,
ldoc:
["Map that holds each bd.connect.handle that manages a connection to/from an instance of this class. The map type is defined as\n{bd.connect.handle.uid --> bd.connect.handle}."],
flags:
[Fnosource,Fprivate],
loc: [216,2,222,5]}
,"bd.connectable.destroy":{
type:
Tfunction,
sdoc:
["Disconnect all connections made to and from this object."],
imember:1,
ldoc:
[],
loc: [250,2,261,3]}
,"bd.connectable.adviseEventSource":{
type:
Tfunction,
sdoc:
["Records this instance serves an event source. "],
imember:1,
ldoc:
["Records this instance serves an event source. Automatically called by bd.connect; see bd.connect.",
[NOTE,"Typically, this method is not applied by client code; instead, it is called automatically by bd.connect."]],
params:
[["handle",[["bd.connect.handle",
["Information about the connection."]]]],
["connecting",[["boolean",
["true if connecting, false if disconnecting."]]]]],
loc: [263,2,277,3]}
,"bd.connectable.adviseEventWatcher":{
type:
Tfunction,
sdoc:
["Records this instance serves an event watcher. "],
imember:1,
ldoc:
["Records this instance serves an event watcher. Automatically called by bd.connect; see bd.connect.",
[NOTE,"Typically, this method is not applied by client code; instead, it is called automatically by bd.connect."]],
params:
[["handle",[["bd.connect.handle",
["Information about the connection."]]]],
["connecting",[["boolean",
["true if connecting, false if disconnecting."]]]]],
loc: [279,2,292,3]}
,"modules.bd/connectable":{
type:
Tmodule,
sdoc:
["Defines the bd.connectable class and associated machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/connectable",
loc: [0,0,295,2]}
,"resources.bd/containable":{
type:
Tresource,
sdoc:
["Defines the module bd/containable"],
src:
"bd/containable",
modules:
["bd/containable"],
docLocs:
[[76,83]],
code:
["dojo.def(\"bd/containable\", [",
"  \"bd\"",
"], function(bd) {",
"///",
"// Defines the bd.containable class and associated machinery.",
"",
"var",
"  parentPropertyGetNames= {},",
"  parentPropertySetNames= {},",
"",
"  initParentPropertyNames= function(",
"    name",
"  ) {",
"    parentPropertyGetNames[name]= name + \"GetPP\";",
"    parentPropertySetNames[name]= name + \"SetPP\";",
"    return false;",
"  };",
"",
"bd.declare(",
"  ///",
"  // Mixin class that allows a child to provide an area in which a parent can store child-dependent information. //The ",
"  // class implements this functionality by adding the single property (an object) \"parentSpace\" to the host instance.",
"  // ",
"  // The methods `getParentProp` and `setParentProp` are provided to facilitate retrieving and storing values in the parent space.",
"  // These methods allow (but do not require) subclasses to override how any particular property is retrieved/stored by providing the methods",
"  // ```propert-name``GetPP` and ```property-name``SetPP`. See bd.containable.getParentProp and ",
"  // bd.containable.setParentProp for details.",
"  //",
"",
"  //class name",
"  \"bd:containable\",",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  {",
"",
"  getParentProp: function(",
"    propertyName, ///(string) The property name to get.",
"    defaultValue  ///(any, optional, bd.notFound) If the property does not exist, set the property to and return this value.",
"  ) {",
"    ///",
"    // Returns the value of the property given by property name in the parent space.",
"    //",
"    //return",
"    //(any) The result of `this.``propertyName``GetPP()`.",
"    //> `this` contains the function ```propertyName``GetPP`.",
"    //(any) `this.parentSpace[propertyName]` ",
"    //> `this.parentSpace[propertyName]` is defined.",
"    //(any) defaultValue",
"    //> `this.parentSpace[propertyName]` is undefined.",
"    //(object) bd.notFound",
"    //> `this.parentSpace[propertyName]` is undefined and defaultValue was not provided.",
"    var methodName= parentPropertyGetNames[propertyName] || initParentPropertyNames(propertyName) || parentPropertyGetNames[propertyName];",
"    if (this[methodName]) {",
"      return this[methodName]();",
"    }",
"    var parentSpace= this.parentSpace || (this.parentSpace= {});",
"    if (parentSpace[propertyName]!==undefined) {",
"      return parentSpace[propertyName];",
"    }",
"    if (this.descriptor && this.descriptor.parentSpace && this.descriptor.parentSpace[propertyName]!==undefined) {",
"      return (parentSpace[propertyName]= this.descriptor.parentSpace[propertyName]);",
"    };",
"    return parentSpace[propertyName]= (defaultValue!==undefined ? defaultValue : bd.notFound);",
"  },",
"",
"  setParentProp: function(",
"    propertyName, ///(string) The property name to set.",
"    value         ///(any) The value to set.",
"  ) {",
"    ///",
"    // Sets the property given by property name to value in the parent space. //If `this` contains the function ```propertyName``SetPP`, then",
"    // processing is delegated to that function; otherwise, `this.parentSpace[propertyName]` is set to value by operator=. `this.parentSpace`",
"    // is automatically created if required. Returns `this`.    ",
"    bd.docGen(\"overload\",",
"      function(",
"        values ///(hash) Set of (property, value) pairs to set in the parent space.",
"      ) {",
"        ///",
"        // Syntactic sugar for `bd.forEachHash(values, function(value, name) { this.setParentProp(name, value); }, this)`.",
"      }",
"    );",
"",
"    if (bd.isString(propertyName)) {",
"      var methodName= parentPropertySetNames[propertyName] || initParentPropertyNames(propertyName) || parentPropertySetNames[propertyName];",
"      if (this[methodName]) {",
"        return this[methodName](value) || this;",
"      } else {",
"        var parentSpace= this.parentSpace || (this.parentSpace= {});",
"        parentSpace[propertyName]= value;",
"        return this;",
"      }",
"    } else {",
"      for(var x in propertyName) {",
"        this.setParentProp(x, propertyName[x]);",
"      }",
"      return this;",
"    }",
"  }",
"});",
"",
"bd.getParentProp= function(",
"  child,        ///(any) An object that may or may not implement the bd.parentSpace interface.",
"  propertyName, ///(string) The name of the property which is to be retrieved.",
"  defaultValue  ///(any, optional, bd.notFound) If the property does not exist, set the property to this value; return this value.",
") {",
"  ///",
"  // Fault-tolerant helper to retrieve a value in the parent space. //If child",
"  // implements bd.parentSpace, then delegate to child.getParentProp (see bd.parentSpace.getParentProp); otherwise,",
"  // return default value.",
"  if (child.getParentProp) {",
"    return child.getParentProp(propertyName, defaultValue);",
"  } else {",
"    return defaultValue;",
"  }",
"};",
"",
"});",
"// Copyright (c) 2000-2009, ALTOVISO, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.containable":{
type:
Tclass,
sdoc:
["Mixin class that allows a child to provide an area in which a parent can store child-dependent information. "],
ldoc:
["Mixin class that allows a child to provide an area in which a parent can store child-dependent information. The\nclass implements this functionality by adding the single property (an object) \"parentSpace\" to the host instance.\n\nThe methods `getParentProp` and `setParentProp` are provided to facilitate retrieving and storing values in the parent space.\nThese methods allow (but do not require) subclasses to override how any particular property is retrieved/stored by providing the methods\n```propert-name``GetPP` and ```property-name``SetPP`. See bd.containable.getParentProp and\nbd.containable.setParentProp for details."],
src:
"bd/containable",
loc: [18,0,101,2],
module:"bd/containable"}
,"bd.containable.getParentProp":{
type:
Tfunction,
sdoc:
["Returns the value of the property given by property name in the parent space."],
imember:1,
ldoc:
[],
params:
[["propertyName",[["string",
["The property name to get."]]]],
["defaultValue",[["any, optional, bd.notFound",
["If the property does not exist, set the property to and return this value."]]]]],
returns:
[["any",
["The result of `this.``propertyName``GetPP()`.",
[CASE,"`this` contains the function ```propertyName``GetPP`."]]],
["any",
["`this.parentSpace[propertyName]`",
[CASE,"`this.parentSpace[propertyName]` is defined."]]],
["any",
["defaultValue",
[CASE,"`this.parentSpace[propertyName]` is undefined."]]],
["object",
["bd.notFound",
[CASE,"`this.parentSpace[propertyName]` is undefined and defaultValue was not provided."]]]],
loc: [38,2,66,3]}
,"bd.containable.setParentProp":{
type:
Tfunction,
sdoc:
["Sets the property given by property name to value in the parent space. "],
imember:1,
ldoc:
["Sets the property given by property name to value in the parent space. If `this` contains the function ```propertyName``SetPP`, then\nprocessing is delegated to that function; otherwise, `this.parentSpace[propertyName]` is set to value by operator=. `this.parentSpace`\nis automatically created if required. Returns `this`."],
params:
[["propertyName",[["string",
["The property name to set."]]]],
["value",[["any",
["The value to set."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Syntactic sugar for `bd.forEachHash(values, function(value, name) { this.setParentProp(name, value); }, this)`."],
ldoc:
[],
params:
[["values",[["hash",
["Set of (property, value) pairs to set in the parent space."]]]]],
loc: [77,6,82,7]}
],
loc: [68,2,100,3]}
,"bd.getParentProp":{
type:
Tfunction,
sdoc:
["Fault-tolerant helper to retrieve a value in the parent space. "],
ldoc:
["Fault-tolerant helper to retrieve a value in the parent space. If child\nimplements bd.parentSpace, then delegate to child.getParentProp (see bd.parentSpace.getParentProp); otherwise,\nreturn default value."],
params:
[["child",[["any",
["An object that may or may not implement the bd.parentSpace interface."]]]],
["propertyName",[["string",
["The name of the property which is to be retrieved."]]]],
["defaultValue",[["any, optional, bd.notFound",
["If the property does not exist, set the property to this value; return this value."]]]]],
src:
"bd/containable",
loc: [103,0,117,1],
module:"bd/containable"}
,"modules.bd/containable":{
type:
Tmodule,
sdoc:
["Defines the bd.containable class and associated machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/containable",
loc: [0,0,119,2]}
,"resources.bd/container":{
type:
Tresource,
sdoc:
["Defines the module bd/container"],
src:
"bd/container",
modules:
["bd/container"],
docLocs:
[[155,163],[113,120]],
code:
["dojo.def(\"bd/container\", [",
"  \"bd\",",
"  \"dojo\"",
"], function(bd, dojo) {",
"///",
"// Defines the bd.container class and associated machinery.",
"",
"var traverse= function(children, callback) {",
"  for (var child, grandChildren, i=0, end= children.length; i<end; i++) {",
"    child= children[i];",
"    grandChildren= bd.isFunction(child.children) ? child.children() : child.children;",
"    grandChildren && traverse(grandChildren, callback);",
"    callback(child);",
"  }",
"};",
"",
"bd.declare(",
"  ///",
"  // Mixin class that manages children widgets.",
"  ///",
"  // Children are contained in an array facilitating fast lookup (no DOM querying required).",
"  // Children may also be cataloged by name and name need only be unique per bd.container instance. This",
"  // allows (e.g.) several panes with the same design but different contents to exist concurrently.",
"  // Notice that if we required each widget to have a unique name, then some sort of runtime",
"  // naming machinery would be required to allow several panes with the same design to exist ",
"  // concurrently.",
"  //",
"  // The design of this class is similar to dijit.\\_Container except that this class exerts",
"  // more direct control over the children compared to dijit.\\_Container which relys on the DOM.",
"  //",
"",
"  //class name",
"  \"bd:container\",",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  {",
"  constructor: function() {",
"    this.children= [];",
"    this.childrenByName= {};",
"  },",
"",
"  startup: function() {",
"    ///",
"    // Calls startup on all children and then delegates further processing to the superclass. //See, for example, bd.visual.",
"    if (!this.started) {",
"      bd.forEach(this.children, bd.startupChild);",
"      this.inherited(arguments);",
"    }",
"  },",
"",
"  stop: function() {",
"    ///",
"    // Calls stop on all children and then delegates further processing to the superclass. //See, for example. bd.visual.",
"    if (this.started) {",
"      bd.forEach(this.children, bd.stopChild);",
"      this.inherited(arguments);",
"    }",
"  },",
"",
"  initChild: function(",
"    child",
"  ) {",
"    ///",
"    // Starts the child iff this container is started. //Automatically called for each child added to this container via bd.container.addChild.",
"    this.started && bd.startupChild(child);",
"  },",
"",
"  uninitChild: function(",
"    child",
"  ) {",
"    ///",
"    // Stops the child. //Automatically called for each child added to this container via bd.container.removeChild.",
"    bd.stopChild(child);",
"  },",
"",
"  addChild: function(",
"    child,         ///(any, typically a widget) The child to add.",
"    referenceNode, ///(DOM node, optional, `this.containerNode` || `this.domNode`) The reference node for placement of child into DOM.",
"    position       ///(\"before\", \"after\", \"first\", \"last\", optional, \"last\") The position relative to reference node to place child.",
"  ) {",
"    ///",
"    // Adds a child to this container.",
"    ///",
"    // The following tasks are executed:",
"    // ",
"    // 1. Pushes the child into the children array.",
"    // 2. Adds the child to the name hash if the name is unique (warns otherwise).",
"    // 3. If `child.domNode` exists, then places the child in the DOM document as given by (referenceNode, position).",
"    // 4. Applies initChild to the child (which starts the child if the container is already started).",
"    //",
"    // Notice that there are no requirements on child (other than it exist). In particular, a child may be a purely computational",
"    // object that does not define any DOM presentation.",
"    this.children.push(child);",
"    var name= child.get && child.get(\"name\");",
"    if (name) {",
"      if (this.childrenByName[name]) {",
"        console.warn(\"attempting to add two children with the same name\");",
"      } else {",
"	      this.childrenByName[name]= child;",
"      }",
"    }",
"    child.domNode && dojo.place(child.domNode, referenceNode || this.containerNode || this.domNode, position || \"last\");",
"    this.initChild(child);",
"  },",
"",
"  removeChild: function(",
"    child ///(any) A child previously added to this container via bd.container.addChild.",
"  ) {",
"    ///",
"    // Removes the child from the container. //Applies uninitChild to the child (which stops the child).",
"    bd.docGen(\"overload\",",
"      function(",
"        name ///(string) Name of a child previously added to this container via bd.container.addChild.",
"      ) {",
"        ///",
"        // Syntactic sugar for ```instance``.removeChild(``instance``.getChild(name))`.",
"      }",
"    );",
"    child= bd.isString(child) && this.childrenByName[child] || child;",
"    if (child.name && this.childrenByName[child.name]===child) {",
"      delete this.childrenByName[child.name];",
"    }",
"    for (var children= this.children, i= 0, end= children.length; i<end; i++) {",
"      if (children[i]===child) {",
"	      children.splice(i, 1);",
"   	    var node= child.domNode;",
"	      node.parentNode.removeChild(node);",
"	      this.uninitChild(child);",
"	      return child;",
"      }",
"    }",
"    return null;",
"  },",
"",
"  getChildren: function() {",
"    ///",
"    // Returns the array of children managed by this container. //This interface allows defining other container types",
"    // that may not actually maintain an array of children.",
"    return this.children;",
"  },",
"",
"  hasChildren: function() {",
"    ///",
"    // Returns true is this container has any children; false otherwise.",
"    return this.getChildren().length>0;",
"  },",
"",
"  getChild: function(",
"    name ///(string) Name of a child previously added to this container via bd.container.addChild.",
"  ) {",
"    ///",
"    // Returns the child with the name `name` if such a child exists; false otherwise.",
"    bd.docGen(\"overload\",",
"      function(",
"        child ///(any other than string) A child.",
"      ) {",
"        ///",
"        // Returns child. This design provides an interface analogous to dojo.byId and dijit.byId whereby ",
"        // requesting the target object results in the identity function.",
"      }",
"    );",
"    return bd.isString(name) && this.childrenByName[name] || name;",
"  },",
"",
"  destroy: function() {",
"    ///",
"    // Destroys all children and then delegates to the superclass.",
"    bd.forEach(this.children, function(child){",
"      child.destroy();",
"    });",
"    delete this.childrenByName;",
"    delete this.children;",
"    this.inherited(arguments);",
"  },",
"",
"  layout: function() {",
"    ///",
"    // Applies layout to all children and returns this object\'s margin box if this container is started; no-op otherwise.",
"    if (!this.started) {",
"      return 0;",
"    }",
"    for (var child, children= this.children, i= 0, end= children.length; i<end; i++) {",
"      (child= children[i]) && child.layout && child.layout();",
"    }",
"    return dojo.marginBox(this.domNode);",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.container":{
type:
Tclass,
sdoc:
["Mixin class that manages children widgets."],
ldoc:
["Children are contained in an array facilitating fast lookup (no DOM querying required).\nChildren may also be cataloged by name and name need only be unique per bd.container instance. This\nallows (e.g.) several panes with the same design but different contents to exist concurrently.\nNotice that if we required each widget to have a unique name, then some sort of runtime\nnaming machinery would be required to allow several panes with the same design to exist\nconcurrently.\n\nThe design of this class is similar to dijit.\\_Container except that this class exerts\nmore direct control over the children compared to dijit.\\_Container which relys on the DOM."],
src:
"bd/container",
loc: [16,0,189,2],
module:"bd/container"}
,"bd.container.startup":{
type:
Tfunction,
sdoc:
["Calls startup on all children and then delegates further processing to the superclass. "],
imember:1,
ldoc:
["Calls startup on all children and then delegates further processing to the superclass. See, for example, bd.visual."],
loc: [44,2,51,3]}
,"bd.container.stop":{
type:
Tfunction,
sdoc:
["Calls stop on all children and then delegates further processing to the superclass. "],
imember:1,
ldoc:
["Calls stop on all children and then delegates further processing to the superclass. See, for example. bd.visual."],
loc: [53,2,60,3]}
,"bd.container.initChild":{
type:
Tfunction,
sdoc:
["Starts the child iff this container is started. "],
imember:1,
ldoc:
["Starts the child iff this container is started. Automatically called for each child added to this container via bd.container.addChild."],
params:
[["child",[]]],
loc: [62,2,68,3]}
,"bd.container.uninitChild":{
type:
Tfunction,
sdoc:
["Stops the child. "],
imember:1,
ldoc:
["Stops the child. Automatically called for each child added to this container via bd.container.removeChild."],
params:
[["child",[]]],
loc: [70,2,76,3]}
,"bd.container.addChild":{
type:
Tfunction,
sdoc:
["Adds a child to this container."],
imember:1,
ldoc:
["The following tasks are executed:\n\n1. Pushes the child into the children array.\n2. Adds the child to the name hash if the name is unique (warns otherwise).\n3. If `child.domNode` exists, then places the child in the DOM document as given by (referenceNode, position).\n4. Applies initChild to the child (which starts the child if the container is already started).\n\nNotice that there are no requirements on child (other than it exist). In particular, a child may be a purely computational\nobject that does not define any DOM presentation."],
params:
[["child",[["any, typically a widget",
["The child to add."]]]],
["referenceNode",[["DOM node, optional, `this.containerNode` || `this.domNode`",
["The reference node for placement of child into DOM."]]]],
["position",[["\"before\", \"after\", \"first\", \"last\", optional, \"last\"",
["The position relative to reference node to place child."]]]]],
loc: [78,2,106,3]}
,"bd.container.removeChild":{
type:
Tfunction,
sdoc:
["Removes the child from the container. "],
imember:1,
ldoc:
["Removes the child from the container. Applies uninitChild to the child (which stops the child)."],
params:
[["child",[["any",
["A child previously added to this container via bd.container.addChild."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Syntactic sugar for ```instance``.removeChild(``instance``.getChild(name))`."],
ldoc:
[],
params:
[["name",[["string",
["Name of a child previously added to this container via bd.container.addChild."]]]]],
loc: [114,6,119,7]}
],
loc: [108,2,135,3]}
,"bd.container.getChildren":{
type:
Tfunction,
sdoc:
["Returns the array of children managed by this container. "],
imember:1,
ldoc:
["Returns the array of children managed by this container. This interface allows defining other container types\nthat may not actually maintain an array of children."],
loc: [137,2,142,3]}
,"bd.container.hasChildren":{
type:
Tfunction,
sdoc:
["Returns true is this container has any children; false otherwise."],
imember:1,
ldoc:
[],
loc: [144,2,148,3]}
,"bd.container.getChild":{
type:
Tfunction,
sdoc:
["Returns the child with the name `name` if such a child exists; false otherwise."],
imember:1,
ldoc:
[],
params:
[["name",[["string",
["Name of a child previously added to this container via bd.container.addChild."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Returns child. This design provides an interface analogous to dojo.byId and dijit.byId whereby\nrequesting the target object results in the identity function."],
ldoc:
[],
params:
[["child",[["any other than string",
["A child."]]]]],
loc: [156,6,162,7]}
],
loc: [150,2,165,3]}
,"bd.container.destroy":{
type:
Tfunction,
sdoc:
["Destroys all children and then delegates to the superclass."],
imember:1,
ldoc:
[],
loc: [167,2,176,3]}
,"bd.container.layout":{
type:
Tfunction,
sdoc:
["Applies layout to all children and returns this object\'s margin box if this container is started; no-op otherwise."],
imember:1,
ldoc:
[],
loc: [178,2,188,3]}
,"modules.bd/container":{
type:
Tmodule,
sdoc:
["Defines the bd.container class and associated machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/container",
loc: [0,0,191,2]}
,"resources.bd/creators":{
type:
Tresource,
sdoc:
["Defines the module bd/creators"],
src:
"bd/creators",
modules:
["bd/creators"],
docLocs:
[[111,133]],
code:
["dojo.def(\"bd/creators\", [",
"  \"bd/kernel\",",
"  \"dojo\",",
"  \"bd/collections\",",
"  \"bd/lang\"",
"], function(bd, dojo) {",
"///",
"// Augments the bd namespace with several creator functions.",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load the module bd. See module.bd.",
"",
"bd.createObject=",
"  function(",
"    ctorName,///(bd.namespacedName or jsname) Constructor function name.",
"    args,    ///(array, optional, []) Arguments passed to constructor.",
"    callback ///(function(newObject), optional, undefined) Function to call after new object has been created.",
"  ){",
"    ///",
"    // Creates a new object given a constructor name.",
"    ///",
"    // The constructor given by `bd.get(ctorName)` is loaded (if required) and executed to instantiate a new object.",
"    // `args`, if any, are provided to the constructor. After construction, if given, `callback` is applied to the",
"    // new object. A bd.Deferred instance is used to control the possibly-asynchronous loading",
"    // of the contructor and the callback if the constructor needs to be loaded.",
"    //warn",
"    // Since it is *not* assumed that the constructor has been previously loaded",
"    // it is possible that the module that holds the constructor must be loaded before the new object",
"    // can be created. Since Backdraft assumes an asynchronous loader, the object may not",
"    // be created upon return from this function.",
"    // ",
"    //return",
"    //(any, as given by `ctorName`) The newly created object.",
"    //> The constructor did not need to be loaded.",
"    //(bd.Deferred) A bd.Deferred instance that asynchronously loads the constructor, creates the object,",
"    // and optionally calls callback. The result of the deferred is the newly created object.",
"    //> The module that defines the constructor needed to be loaded.",
"",
"    //argument juggling",
"    if (!bd.isArray(args)) {",
"      callback= args;",
"      args= [];",
"    }",
"",
"    var ",
"      doCreate= function() {",
"        var",
"          ctor= bd.get(ctorName),",
"          result= bd.delegate(ctor.prototype);",
"        ctor.apply(result, args);",
"        return result;",
"      },",
"      callbackHelper= function(object) {",
"        var cbResult= callback(object);",
"        if (cbResult instanceof bd.Deferred) {",
"          cbResult.addCallback(function() {",
"            return object;",
"          });",
"          return cbResult;",
"        }",
"        return object;",
"      };",
"",
"    if (bd.get(ctorName)) {",
"      var newObject= doCreate();",
"      callback && callbackHelper(newObject);",
"      return newObject;",
"    } else {",
"      var deferred= new bd.Deferred();",
"      deferred.addCallback(doCreate);",
"      callback && deferred.addCallback(callbackHelper);",
"      dojo.def([bd.moduleName(ctorName)], function() { ",
"        deferred.callback(true); ",
"      });",
"      return deferred;",
"    }",
"  };",
"",
"var traverse= function(descriptor) {",
"  if (descriptor.className && !bd.get(descriptor.className)) {",
"    dojo.req(bd.moduleName(descriptor.className));",
"  }",
"  bd.forEach(descriptor.children, traverse);",
"};",
"",
"bd.createWidget=",
"  function(",
"    args,     ///(kwargs) Describes how to create the widget.",
"    callback, ///(function(newWidget), optional) Function to call after new widget tree has been created.",
"    onCreates   ///(private) Array of functions to call after hierarchy completely created. Built up",
"              // as this function traverses the hierarchy; this argument should *never* be provided for ",
"              // top-level (i.e., non-recursive) applications of this function.",
"  ){",
"    ///",
"    // Creates a new widget hierarchy as given by args.",
"    ///",
"    // Creates a new widget hierarchy as given by args (including all the decendent children, grandchildren, etc.).",
"    // The hierarchy is created depth-first. Adds the top-level widget to the parent (if any) after the entire ",
"    // hierarchy is created, and then calls any onCreate functions found in widget heirarchy in the reverse order they were ",
"    // encountered during the creation traversal.",
"    //",
"    // Since it is *not* assumed that demanded widget classes have been previously loaded,",
"    // one or more modules may need to be loaded before some widgets",
"    // can be created. Further, since Backdraft assumes an asynchronous loader, the hierarchy may not",
"    // be created upon return from this function. Therefore, in the event modules must be loaded in order to complete",
"    // the creation of the hierarch, this function returns a bd.Deferred object that controls the asynchronous",
"    // creation. On the other hand, if all required constructors were available upon entry, then the result of callback applied to the",
"    // root of the hierarchy (when callback is provided) or the root (otherwise) is returned immediately.",
"    //note",
"    // This function is, perhaps, the foundational function of the Backdraft framework. It allows hierarchies of powerful widgets to be",
"    // easily created *without markup or a parser* in an asynchronous  environment using a deterministic, effecient algorithm.",
"    bd.docGen(\"kwargs\", {",
"      ///",
"      // Describes a how to create, bind, and place a new bd widget.",
"    ",
"      parent:",
"        ///(bd.containerWidget) The parent into which to place the widget.",
"        //(string) The parent as resolved by bd.object.byId into which to place the widget.",
"        //(falsy) The widget is left an orphan.",
"        null,",
"    ",
"      descriptor:",
"        ///(bd.descriptor) Describes how to create the widget.",
"        bd.noDefault,",
"    ",
"      key:",
"        ///(bd.key) Describes how to restrict data to bind to widget.",
"        {},",
"    ",
"      data:",
"        ///(bd.data) Data to bind to widget. Typically, working set of single rows,",
"        // each row a member of some rowset, that are used to bind data; but may be anything meaninful to the widget class.",
"        {}",
"    });",
"",
"    //traverse the descriptor and request any required modules that aren\'t already loaded",
"    var topLevel= false;",
"    if (onCreates===undefined) {",
"      topLevel= true;",
"      traverse(args.descriptor);",
"      onCreates= [];",
"    }",
"",
"    var",
"      key= args.key || {},",
"      data= args.data || {},",
"      parent= bd.isString(args.parent) ? bd.object.byId(args.parent) : args.parent,",
"      finish= function(widget) {",
"        var ",
"          // any service request can return a bd.Deferred; once we slip",
"          // into deferred execution, this process starts adding functions",
"          // to the first deferred result\'s callback queue and will return ",
"          // the deferred as the result. This variable will hold the first",
"          // deferred if/when we get it.",
"          controllingDeferred= 0;",
"",
"        if (args.descriptor.onCreate) {",
"          onCreates.push(bd.hitch(widget, args.descriptor.onCreate, widget));",
"        }",
"      ",
"        // create the widget\'s children (if any)",
"        if (widget.loadChildren) {",
"          ((controllingDeferred= widget.loadChildren(onCreates)) instanceof bd.Deferred) || (controllingDeferred= 0);",
"        } else {",
"          var",
"            childrenDescriptors= widget.getChildrenDescriptors && widget.getChildrenDescriptors(),",
"            childrenKeyset= widget.childrenKeys || [key];",
"          if (childrenDescriptors && childrenKeyset) {",
"            //create a set of children for each key in the keyset",
"            bd.forEach(childrenKeyset, function(key){",
"              var augmentedData= bd.mix({}, data);",
"              widget.calcData && widget.calcData(key, augmentedData);",
"              bd.forEach(childrenDescriptors, function(descriptor) {",
"                var result= bd.createWidget({",
"                  parent:widget, ",
"                  descriptor:descriptor, ",
"                  key:key, ",
"                  data:augmentedData}, 0, onCreates);",
"                if (result instanceof bd.Deferred) {",
"                  if (controllingDeferred) {",
"                    //add a function to the controlling deferred callback queue that will wait for this child",
"                    controllingDeferred.addCallback((function(result) { return function() { return result; }; })(result));",
"                  } else {",
"                    //this is the first deferred result; therefore, it becomes the controlling deferred",
"                    controllingDeferred= result;",
"                  }",
"                }",
"              });",
"            });",
"          }",
"        }",
"        // at this point the children are all created (if any) or controllingDeferred holds a bd.Deferred that\'s controlling",
"        // the asynchronous creation of the children.",
"",
"        // NOTICE: we assume that addChild never returns a bd.Deferred",
"        if (controllingDeferred) {",
"          controllingDeferred.addCallback(function(){ ",
"            if (widget.parent && widget.parent.addChild) {",
"              widget.parent.addChild(widget);",
"            }",
"          });",
"        } else if (widget.parent && widget.parent.addChild) {",
"          widget.parent.addChild(widget);",
"        }",
"",
"        // if this is the top level, then run the on-load queue      ",
"        if (topLevel) {",
"          while (!controllingDeferred && onCreates.length) {",
"            ((controllingDeferred= onCreates.pop().call(null)) instanceof bd.Deferred) || (controllingDeferred= 0);",
"          }",
"          if (controllingDeferred) {",
"            while (onCreates.length) {",
"              controllingDeferred.addCallback(onCreates.pop());",
"            }",
"          }",
"        }",
"",
"        // make the callback (if any)",
"        if (callback) {",
"          if (controllingDeferred) {",
"            // the callback is expecting the widget; make sure it gets it...",
"            controllingDeferred.addCallback(function() {",
"              return widget;",
"            });",
"            controllingDeferred.addCallback(callback);",
"          } else {",
"            ((controllingDeferred= callback(widget)) instanceof bd.Deferred) || (controllingDeferred= 0);",
"          }",
"        }",
"     ",
"        // return the newly manufactured widget instance with all of its decendents",
"        if (controllingDeferred) {",
"          // the caller is expecting the widget; make sure it gets it...",
"          controllingDeferred.addCallback(function() { ",
"            return widget; ",
"          });",
"          return controllingDeferred;",
"        }",
"        return widget;",
"      };",
"    return bd.createObject(args.descriptor.className, [{parent:parent, descriptor:args.descriptor, key:key, data:data}], finish);",
"  };",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.createObject":{
type:
Tfunction,
sdoc:
["Creates a new object given a constructor name."],
ldoc:
["The constructor given by `bd.get(ctorName)` is loaded (if required) and executed to instantiate a new object.\n`args`, if any, are provided to the constructor. After construction, if given, `callback` is applied to the\nnew object. A bd.Deferred instance is used to control the possibly-asynchronous loading\nof the contructor and the callback if the constructor needs to be loaded.",
[WARN,"Since it is *not* assumed that the constructor has been previously loaded\nit is possible that the module that holds the constructor must be loaded before the new object\ncan be created. Since Backdraft assumes an asynchronous loader, the object may not\nbe created upon return from this function."]],
params:
[["ctorName",[["bd.namespacedName or jsname",
["Constructor function name."]]]],
["args",[["array, optional, []",
["Arguments passed to constructor."]]]],
["callback",[["function(newObject), optional, undefined",
["Function to call after new object has been created."]]]]],
returns:
[["any, as given by `ctorName`",
["The newly created object.",
[CASE,"The constructor did not need to be loaded."]]],
["bd.Deferred",
["A bd.Deferred instance that asynchronously loads the constructor, creates the object,\n and optionally calls callback. The result of the deferred is the newly created object.",
[CASE,"The module that defines the constructor needed to be loaded."]]]],
src:
"bd/creators",
loc: [12,0,76,3],
module:"bd/creators"}
,"bd.createWidget":{
type:
Tfunction,
sdoc:
["Creates a new widget hierarchy as given by args."],
ldoc:
["Creates a new widget hierarchy as given by args (including all the decendent children, grandchildren, etc.).\nThe hierarchy is created depth-first. Adds the top-level widget to the parent (if any) after the entire\nhierarchy is created, and then calls any onCreate functions found in widget heirarchy in the reverse order they were\nencountered during the creation traversal.\n\nSince it is *not* assumed that demanded widget classes have been previously loaded,\none or more modules may need to be loaded before some widgets\ncan be created. Further, since Backdraft assumes an asynchronous loader, the hierarchy may not\nbe created upon return from this function. Therefore, in the event modules must be loaded in order to complete\nthe creation of the hierarch, this function returns a bd.Deferred object that controls the asynchronous\ncreation. On the other hand, if all required constructors were available upon entry, then the result of callback applied to the\nroot of the hierarchy (when callback is provided) or the root (otherwise) is returned immediately.",
[NOTE,"This function is, perhaps, the foundational function of the Backdraft framework. It allows hierarchies of powerful widgets to be\neasily created *without markup or a parser* in an asynchronous  environment using a deterministic, effecient algorithm."]],
params:
[["args",[["kwargs",
["Describes how to create the widget."]]]],
["callback",[["function(newWidget), optional",
["Function to call after new widget tree has been created."]]]],
["onCreates",[["private",
["Array of functions to call after hierarchy completely created. Built up\n as this function traverses the hierarchy; this argument should *never* be provided for\n top-level (i.e., non-recursive) applications of this function."]]]]],
src:
"bd/creators",
loc: [85,0,241,3],
module:"bd/creators"}
,"bd.createWidget.kwargs":{
type:
Tvariable,
sdoc:
["Describes a how to create, bind, and place a new bd widget."],
ldoc:
[],
props:
["parent",{
type:
Tvariable,
loc: [119,8,119,12],
types:
[["bd.containerWidget",
["The parent into which to place the widget."]],
["string",
["The parent as resolved by bd.object.byId into which to place the widget."]],
["falsy",
["The widget is left an orphan."]]]}
,
"descriptor",{
type:
Tvariable,
loc: [123,8,123,20],
types:
[["bd.descriptor",
["Describes how to create the widget."]]]}
,
"key",{
type:
Tvariable,
loc: [127,8,127,10],
types:
[["bd.key",
["Describes how to restrict data to bind to widget."]]]}
,
"data",{
type:
Tvariable,
loc: [132,8,132,10],
types:
[["bd.data",
["Data to bind to widget. Typically, working set of single rows,\n each row a member of some rowset, that are used to bind data; but may be anything meaninful to the widget class."]]]}
],
loc: [111,24,133,5]}
,"modules.bd/creators":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with several creator functions."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load the module bd. See module.bd."]],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/creators",
loc: [0,0,243,2]}
,"resources.bd/css":{
type:
Tresource,
sdoc:
["Defines the module bd/css"],
src:
"bd/css",
modules:
["bd/css"],
docLocs:
[[11,65]],
code:
["dojo.def(\"bd/css\", [",
"  \"dojo\", \"bd\"",
"], function(dojo, bd) {",
"///",
"// Augments the bd namespace with CSS convenience functions.",
"",
"bd.css=",
"  ///namespace ",
"  // Contains a set of convenience functions to help with CSS tasks.",
" bd.css || {};",
"",
"bd.docGen(\"bd.css\", {",
"  abbreviatedBox: {",
"    ///type",
"    // Provides none, one, some, or all of the top, right, bottom, left, height, and width",
"    // measurements of a box. //The key attribute of this type is specifying these metrics without",
"    // having to \"spell out\" the attribute (e.g., just write \"t\" instead of \"top\"). For example,",
"    // in order to get the CSS style string:",
"    //c \"top: 5em; left: 10em; height: 15em; width: 60em;\"",
"    /// Simply write",
"    //c bd.css.emBox({t:5, l:10, h:15, w:60}); ",
"    ",
"    t:",
"      ///",
"      //The \"top\" attribute.",
"      //(number or string) Valid metric as defined by usage context (see bd.css.box, bd.css.emBox).",
"      undefined,",
"",
"    r:",
"      ///",
"      // The \"right\" attribute.",
"      //(number or string) Valid metric as defined by usage context (see bd.css.box, bd.css.emBox).",
"      undefined,",
"",
"    b:",
"      ///",
"      // The \"bottom\" attribute.",
"      //(number or string) Valid metric as defined by usage context (see bd.css.box, bd.css.emBox).",
"      undefined,",
"",
"    l:",
"      ///",
"      // The \"left\" attribute.",
"      //(number or string) Valid metric as defined by usage context (see bd.css.box, bd.css.emBox).",
"      undefined,",
"",
"    h:",
"      ///",
"      // The \"height\" attribute.",
"      //(number or string) Valid metric as defined by usage context (see bd.css.box, bd.css.emBox).",
"      undefined,",
"",
"    w:",
"      ///",
"      // The \"width\" attribute.",
"      //(number or string) Valid metric as defined by usage context (see bd.css.box, bd.css.emBox).",
"      undefined",
"  },",
"  cornerPosit:",
"    ///type",
"    // A string of the form (t|c|b)(l|c|r)-(t|c|b)(l|c|r) that says how to position one box with respect to another.  //The",
"    // characters t, c, b, l, and r, stand for top, center, bottom, left, and right, respectively. The first pair give the",
"    // target box position while the second pair give the reference box position. For example \"BR-TL\" says position the bottom-right",
"    // corner of the target box at the same coordinate as the top-left corner of the reference box. See bd.css.cornerCalculators.",
"    0",
"});",
"",
"bd.mix(bd.css, {",
"  metric:",
"    function(",
"      value ///(string) a CSS length (e.g., \"25%\"); missing units implies pixels (e.g., \"25\" implies \"25px\").",
"            //(number) a CSS length to be interpreted as pixels (e.g., 25 implies \"25px\").",
"    ) {",
"      ///",
"      // Converts value to a valid CSS length string. //A string of dijits or a number without units imply units of \"px\".",
"      if (bd.isString(value)){",
"        if (/^\\d+$/.test(value)) {",
"          //size is a raw number; therefore, it must be pixels",
"          value= value + \"px\";",
"        }",
"      } else {",
"        value= value + \"px\";",
"      }",
"      return value; ///(string) A valid CSS metric with units.",
"    },",
"",
"  emBox:",
"    function(",
"      box ///(bd.css.abbreviatedBox) Box to convert.",
"    ){",
"      ///",
"      // Converts box to a valid object containing CSS box metrics suitable as a setter",
"      // value for dojo.style. //Assumes box units are \"em\".",
"      // Box metrics must be numbers or strings that convert to numbers. For example,",
"      // in order to get...",
"      //c {top: \"5em\", left: \"10em\", height: \"15em\", width: \"60em\"}",
"      /// Simply write...",
"      //c bd.css.emBox({t:5, l:10, h:15, w:60}); ",
"      var result= {};",
"      box.t!==undefined && (result.top= box.t + \"em\");",
"      box.b!==undefined && (result.bottom= box.b + \"em\");",
"      box.l!==undefined && (result.left= box.l + \"em\");",
"      box.r!==undefined && (result.right= box.r + \"em\");",
"      box.h!==undefined && (result.height= box.h + \"em\");",
"      box.w!==undefined && (result.width= box.w + \"em\");",
"      return result; ///(object) A valid object to pass to dojo.style with box metrics.",
"    },",
"",
"  box:",
"    function(",
"      box ///(bd.css.abbreviatedBox) Box to convert.",
"    ){",
"      ///",
"      // Converts box to a valid object containing CSS box metrics suitable as a setter",
"      // value for dojo.style. //Assumes box units are \"px\" if ",
"      // missing. Box metrics must be values that convert to valid CSS metrics as",
"      // given by bd.css.metric. For example, in order to get the CSS style string:",
"      //c {top: \"5px\", left: \"10px\", height: \"15%\", width: \"50%\"}",
"      /// Simply write,",
"      //c bd.css.box({t:5, l:10, h:\"15%\", w:\"50%\"}); ",
"      var result= {};",
"      box.t!==undefined && (result.top= bd.css.metric(box.t));",
"      box.b!==undefined && (result.bottom= bd.css.metric(box.b));",
"      box.l!==undefined && (result.left= bd.css.metric(box.l));",
"      box.r!==undefined && (result.right= bd.css.metric(box.r));",
"      box.h!==undefined && (result.height= bd.css.metric(box.h));",
"      box.w!==undefined && (result.width= bd.css.metric(box.w));",
"      return result; ///(object) A valid object to pass to dojo.style with box metrics.",
"    },",
"",
"  clearPosit:",
"    function(",
"      node ///(DOM node) The node to clear.",
"    ){",
"      ///",
"      // Sets the top, bottom, left, and right CSS properties to empty string.",
"      dojo.style(node, {top:\'\', bottom:\'\', left:\'\', right:\'\'});",
"      return node; ///(DOM node) The node argument; allows for chaining function calls on the node.",
"    },",
"",
"  clearSize:",
"    function(",
"      node ///(DOM node) The node to clear.",
"    ){",
"      ///",
"      // Sets the height and width CSS properties to empty string.",
"      dojo.style(node, {height:\'\', width:\'\'});",
"      return node; ///(DOM node) The node argument; allows for chaining function calls on the node.",
"    },",
"",
"  clearPositAndSize:",
"    function(",
"      node ///(DOM node) the node to clear.",
"    ){",
"      ///",
"      // Sets the top, bottom, left, right, height, and width CSS properties to empty string.",
"      dojo.style(node, {top:\'\', bottom:\'\', left:\'\', right:\'\', height:\'\', width:\'\'});",
"      return node; ///(DOM node) The node argument; allows for chaining function calls on the node.",
"    },",
"",
"  cornerCalculators:",
"    ///namespace",
"    // Defines functions that compute the (top, left) coordinates of a target box with respect to a reference box.",
"    {}",
"});",
"",
"bd.mix(bd.css.cornerCalculators, {",
"  left_ll: function(target, ref) {",
"    ///",
"    // Align the left side of the target with the left side of the reference.",
"    return ref.l; ",
"  },",
"  left_cl: function(target, ref) {",
"    ///",
"    // Align the horizontal center of the target with the left side of the reference.",
"    return ref.l - Math.floor(target.w / 2); ",
"  },",
"  left_rl: function(target, ref) {",
"    ///",
"    // Align the right side of the target with the left side of the reference.",
"    return ref.l - target.w; ",
"  },",
"",
"  left_lc: function(target, ref) {",
"    ///",
"    // Align the left side of the target with the horizontal center of the reference.",
"    return ref.l + Math.floor(ref.w / 2); ",
"  },",
"  left_cc: function(target, ref) {",
"    ///",
"    // Align the horizontal center of the target with the horizontal center of the reference.",
"    return ref.l + Math.floor(ref.w / 2) - Math.floor(target.w / 2); ",
"  },",
"  left_rc: function(target, ref) {",
"    ///",
"    // Align the right side of the target with the horizontal center of the reference.",
"    return ref.l + Math.floor(ref.w / 2) - target.w; ",
"  },",
"",
"  left_lr: function(target, ref) {",
"    ///",
"    // Align the left side of the target with the right side of the reference.",
"    return ref.l + ref.w; ",
"  },",
"  left_cr: function(target, ref) {",
"    ///",
"    // Align the horizontal center of the target with the right side of the reference.",
"    return ref.l + ref.w - Math.floor(target.w / 2); ",
"  },",
"  left_rr: function(target, ref) {",
"    ///",
"    // Align the right side of the target with the right side of the reference.",
"    return ref.l + ref.w - target.w; ",
"  },",
"",
"  top_tt: function(target, ref) {",
"    ///",
"    // Align the top side of the target with the top side of the reference.",
"    return ref.t; ",
"  },",
"  top_ct: function(target, ref) {",
"    ///",
"    // Align the vertical center of the target with the top side of the reference.",
"    return ref.t - Math.floor(target.h / 2); ",
"  },",
"  top_bt: function(target, ref) {",
"    ///",
"    // Align the bottom side of the target with the top side of the reference.",
"    return ref.t - target.h; ",
"  },",
"",
"  top_tc: function(target, ref) {",
"    ///",
"    // Align the top side of the target with the vertical center of the reference.",
"    return ref.t + Math.floor(ref.h / 2); ",
"  },",
"  top_cc: function(target, ref) {",
"    ///",
"    // Align the vertical center of the target with the vertical center of the reference.",
"    return ref.t + Math.floor(ref.h / 2) - Math.floor(target.h / 2); ",
"  },",
"  top_bc: function(target, ref) {",
"    ///",
"    // Align the bottom side of the target with the vertical center of the reference.",
"    return ref.t + Math.floor(ref.h / 2) - target.h; ",
"  },",
"",
"  top_tb: function(target, ref) {",
"    ///",
"    // Align the top side of the target with the botom side of the reference.",
"    return ref.t + ref.h; ",
"  },",
"  top_cb: function(target, ref) {",
"    ///",
"    // Align the vertical center of the target with the bottom side of the reference.",
"    return ref.t + ref.h - Math.floor(target.h / 2); ",
"  },",
"  top_bb: function(target, ref) {",
"    ///",
"    // Align the bottom side of the target with the bottom side of the reference.",
"    return ref.t + ref.h - target.h; ",
"  },",
"",
"  getTop:",
"    function(",
"      posit,       ///(bd.css.cornerPosit) The position to compute targetBox with respect to referenceBox.",
"      targetBox,   ///(bd.css.abbreviatedBox) The target box.",
"      referenceBox ///(bd.css.abbreviatedBox) The reference box.",
"    ) {",
"      ///",
"      // Returns the top coordinate of targetBox with respect to referenceBox at posit.",
"      return this[\"top_\" + posit.charAt(0)+posit.charAt(3)](targetBox, referenceBox);",
"    },",
"  getLeft:",
"    function(",
"      posit,       ///(bd.css.cornerPosit) The position to compute targetBox with respect to referenceBox.",
"      targetBox,   ///(bd.css.abbreviatedBox) The target box.",
"      referenceBox ///(bd.css.abbreviatedBox) The reference box.",
"    ) {",
"      ///",
"      // Returns the left coordinate of targetBox with respect to referenceBox at posit.",
"      return this[\"left_\" + posit.charAt(1)+posit.charAt(4)](targetBox, referenceBox);",
"    }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.css":{
type:
Tnamespace,
sdoc:
["Contains a set of convenience functions to help with CSS tasks."],
ldoc:
[],
src:
"bd/css",
loc: [6,0,9,13],
module:"bd/css"}
,"bd.css.abbreviatedBox":{
type:
Ttype,
sdoc:
["Provides none, one, some, or all of the top, right, bottom, left, height, and width\nmeasurements of a box. "],
ldoc:
["Provides none, one, some, or all of the top, right, bottom, left, height, and width\nmeasurements of a box. The key attribute of this type is specifying these metrics without\nhaving to \"spell out\" the attribute (e.g., just write \"t\" instead of \"top\"). For example,\nin order to get the CSS style string:",
[CODE,"\"top: 5em; left: 10em; height: 15em; width: 60em;\""],
"Simply write",
[CODE,"bd.css.emBox({t:5, l:10, h:15, w:60});"]],
props:
["t",{
type:
Tvariable,
sdoc:
["The \"top\" attribute."],
ldoc:
[],
loc: [26,6,26,15],
types:
[["number or string",
["Valid metric as defined by usage context (see bd.css.box, bd.css.emBox)."]]]}
,
"r",{
type:
Tvariable,
sdoc:
["The \"right\" attribute."],
ldoc:
[],
loc: [32,6,32,15],
types:
[["number or string",
["Valid metric as defined by usage context (see bd.css.box, bd.css.emBox)."]]]}
,
"b",{
type:
Tvariable,
sdoc:
["The \"bottom\" attribute."],
ldoc:
[],
loc: [38,6,38,15],
types:
[["number or string",
["Valid metric as defined by usage context (see bd.css.box, bd.css.emBox)."]]]}
,
"l",{
type:
Tvariable,
sdoc:
["The \"left\" attribute."],
ldoc:
[],
loc: [44,6,44,15],
types:
[["number or string",
["Valid metric as defined by usage context (see bd.css.box, bd.css.emBox)."]]]}
,
"h",{
type:
Tvariable,
sdoc:
["The \"height\" attribute."],
ldoc:
[],
loc: [50,6,50,15],
types:
[["number or string",
["Valid metric as defined by usage context (see bd.css.box, bd.css.emBox)."]]]}
,
"w",{
type:
Tvariable,
sdoc:
["The \"width\" attribute."],
ldoc:
[],
loc: [56,6,56,15],
types:
[["number or string",
["Valid metric as defined by usage context (see bd.css.box, bd.css.emBox)."]]]}
],
src:
"bd/css",
loc: [12,2,57,3],
module:"bd/css"}
,"bd.css.cornerPosit":{
type:
Ttype,
sdoc:
["A string of the form (t|c|b)(l|c|r)-(t|c|b)(l|c|r) that says how to position one box with respect to another.  "],
ldoc:
["A string of the form (t|c|b)(l|c|r)-(t|c|b)(l|c|r) that says how to position one box with respect to another.  The\ncharacters t, c, b, l, and r, stand for top, center, bottom, left, and right, respectively. The first pair give the\ntarget box position while the second pair give the reference box position. For example \"BR-TL\" says position the bottom-right\ncorner of the target box at the same coordinate as the top-left corner of the reference box. See bd.css.cornerCalculators."],
src:
"bd/css",
loc: [58,2,64,5],
module:"bd/css"}
,"bd.css.metric":{
type:
Tfunction,
sdoc:
["Converts value to a valid CSS length string. "],
ldoc:
["Converts value to a valid CSS length string. A string of dijits or a number without units imply units of \"px\"."],
params:
[["value",[["string",
["a CSS length (e.g., \"25%\"); missing units implies pixels (e.g., \"25\" implies \"25px\")."]],
["number",
["a CSS length to be interpreted as pixels (e.g., 25 implies \"25px\")."]]]]],
returns:
[["string",
["A valid CSS metric with units."]]],
src:
"bd/css",
loc: [68,2,84,5],
module:"bd/css"}
,"bd.css.emBox":{
type:
Tfunction,
sdoc:
["Converts box to a valid object containing CSS box metrics suitable as a setter\nvalue for dojo.style. "],
ldoc:
["Converts box to a valid object containing CSS box metrics suitable as a setter\nvalue for dojo.style. Assumes box units are \"em\".\nBox metrics must be numbers or strings that convert to numbers. For example,\nin order to get...",
[CODE,"{top: \"5em\", left: \"10em\", height: \"15em\", width: \"60em\"}"],
"Simply write...",
[CODE,"bd.css.emBox({t:5, l:10, h:15, w:60});"]],
params:
[["box",[["bd.css.abbreviatedBox",
["Box to convert."]]]]],
returns:
[["object",
["A valid object to pass to dojo.style with box metrics."]]],
src:
"bd/css",
loc: [86,2,106,5],
module:"bd/css"}
,"bd.css.box":{
type:
Tfunction,
sdoc:
["Converts box to a valid object containing CSS box metrics suitable as a setter\nvalue for dojo.style. "],
ldoc:
["Converts box to a valid object containing CSS box metrics suitable as a setter\nvalue for dojo.style. Assumes box units are \"px\" if\nmissing. Box metrics must be values that convert to valid CSS metrics as\ngiven by bd.css.metric. For example, in order to get the CSS style string:",
[CODE,"{top: \"5px\", left: \"10px\", height: \"15%\", width: \"50%\"}"],
"Simply write,",
[CODE,"bd.css.box({t:5, l:10, h:\"15%\", w:\"50%\"});"]],
params:
[["box",[["bd.css.abbreviatedBox",
["Box to convert."]]]]],
returns:
[["object",
["A valid object to pass to dojo.style with box metrics."]]],
src:
"bd/css",
loc: [108,2,128,5],
module:"bd/css"}
,"bd.css.clearPosit":{
type:
Tfunction,
sdoc:
["Sets the top, bottom, left, and right CSS properties to empty string."],
ldoc:
[],
params:
[["node",[["DOM node",
["The node to clear."]]]]],
returns:
[["DOM node",
["The node argument; allows for chaining function calls on the node."]]],
src:
"bd/css",
loc: [130,2,138,5],
module:"bd/css"}
,"bd.css.clearSize":{
type:
Tfunction,
sdoc:
["Sets the height and width CSS properties to empty string."],
ldoc:
[],
params:
[["node",[["DOM node",
["The node to clear."]]]]],
returns:
[["DOM node",
["The node argument; allows for chaining function calls on the node."]]],
src:
"bd/css",
loc: [140,2,148,5],
module:"bd/css"}
,"bd.css.clearPositAndSize":{
type:
Tfunction,
sdoc:
["Sets the top, bottom, left, right, height, and width CSS properties to empty string."],
ldoc:
[],
params:
[["node",[["DOM node",
["the node to clear."]]]]],
returns:
[["DOM node",
["The node argument; allows for chaining function calls on the node."]]],
src:
"bd/css",
loc: [150,2,158,5],
module:"bd/css"}
,"bd.css.cornerCalculators":{
type:
Tnamespace,
sdoc:
["Defines functions that compute the (top, left) coordinates of a target box with respect to a reference box."],
ldoc:
[],
src:
"bd/css",
loc: [160,2,163,6],
module:"bd/css"}
,"bd.css.cornerCalculators.left_ll":{
type:
Tfunction,
sdoc:
["Align the left side of the target with the left side of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [167,2,171,3],
module:"bd/css"}
,"bd.css.cornerCalculators.left_cl":{
type:
Tfunction,
sdoc:
["Align the horizontal center of the target with the left side of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [172,2,176,3],
module:"bd/css"}
,"bd.css.cornerCalculators.left_rl":{
type:
Tfunction,
sdoc:
["Align the right side of the target with the left side of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [177,2,181,3],
module:"bd/css"}
,"bd.css.cornerCalculators.left_lc":{
type:
Tfunction,
sdoc:
["Align the left side of the target with the horizontal center of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [183,2,187,3],
module:"bd/css"}
,"bd.css.cornerCalculators.left_cc":{
type:
Tfunction,
sdoc:
["Align the horizontal center of the target with the horizontal center of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [188,2,192,3],
module:"bd/css"}
,"bd.css.cornerCalculators.left_rc":{
type:
Tfunction,
sdoc:
["Align the right side of the target with the horizontal center of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [193,2,197,3],
module:"bd/css"}
,"bd.css.cornerCalculators.left_lr":{
type:
Tfunction,
sdoc:
["Align the left side of the target with the right side of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [199,2,203,3],
module:"bd/css"}
,"bd.css.cornerCalculators.left_cr":{
type:
Tfunction,
sdoc:
["Align the horizontal center of the target with the right side of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [204,2,208,3],
module:"bd/css"}
,"bd.css.cornerCalculators.left_rr":{
type:
Tfunction,
sdoc:
["Align the right side of the target with the right side of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [209,2,213,3],
module:"bd/css"}
,"bd.css.cornerCalculators.top_tt":{
type:
Tfunction,
sdoc:
["Align the top side of the target with the top side of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [215,2,219,3],
module:"bd/css"}
,"bd.css.cornerCalculators.top_ct":{
type:
Tfunction,
sdoc:
["Align the vertical center of the target with the top side of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [220,2,224,3],
module:"bd/css"}
,"bd.css.cornerCalculators.top_bt":{
type:
Tfunction,
sdoc:
["Align the bottom side of the target with the top side of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [225,2,229,3],
module:"bd/css"}
,"bd.css.cornerCalculators.top_tc":{
type:
Tfunction,
sdoc:
["Align the top side of the target with the vertical center of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [231,2,235,3],
module:"bd/css"}
,"bd.css.cornerCalculators.top_cc":{
type:
Tfunction,
sdoc:
["Align the vertical center of the target with the vertical center of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [236,2,240,3],
module:"bd/css"}
,"bd.css.cornerCalculators.top_bc":{
type:
Tfunction,
sdoc:
["Align the bottom side of the target with the vertical center of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [241,2,245,3],
module:"bd/css"}
,"bd.css.cornerCalculators.top_tb":{
type:
Tfunction,
sdoc:
["Align the top side of the target with the botom side of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [247,2,251,3],
module:"bd/css"}
,"bd.css.cornerCalculators.top_cb":{
type:
Tfunction,
sdoc:
["Align the vertical center of the target with the bottom side of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [252,2,256,3],
module:"bd/css"}
,"bd.css.cornerCalculators.top_bb":{
type:
Tfunction,
sdoc:
["Align the bottom side of the target with the bottom side of the reference."],
ldoc:
[],
params:
[["target",[]],
["ref",[]]],
src:
"bd/css",
loc: [257,2,261,3],
module:"bd/css"}
,"bd.css.cornerCalculators.getTop":{
type:
Tfunction,
sdoc:
["Returns the top coordinate of targetBox with respect to referenceBox at posit."],
ldoc:
[],
params:
[["posit",[["bd.css.cornerPosit",
["The position to compute targetBox with respect to referenceBox."]]]],
["targetBox",[["bd.css.abbreviatedBox",
["The target box."]]]],
["referenceBox",[["bd.css.abbreviatedBox",
["The reference box."]]]]],
src:
"bd/css",
loc: [263,2,272,5],
module:"bd/css"}
,"bd.css.cornerCalculators.getLeft":{
type:
Tfunction,
sdoc:
["Returns the left coordinate of targetBox with respect to referenceBox at posit."],
ldoc:
[],
params:
[["posit",[["bd.css.cornerPosit",
["The position to compute targetBox with respect to referenceBox."]]]],
["targetBox",[["bd.css.abbreviatedBox",
["The target box."]]]],
["referenceBox",[["bd.css.abbreviatedBox",
["The reference box."]]]]],
src:
"bd/css",
loc: [273,2,282,5],
module:"bd/css"}
,"modules.bd/css":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with CSS convenience functions."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/css",
loc: [0,0,285,2]}
,"resources.bd/cssStateful":{
type:
Tresource,
sdoc:
["Defines the module bd/cssStateful"],
src:
"bd/cssStateful",
modules:
["bd/cssStateful"],
code:
["dojo.def(\"bd/cssStateful\", [",
"  \"bd\"",
"], function(bd) {",
"///",
"// Defines the bd.cssStateful class.",
"",
"bd.declare(",
"  ///",
"  // Mixin class for widgets that mirror certain attribute values in a DOM node class attribute.",
"  ///",
"  // The machinery provided by this mixin watches the set of attributes given in the cssStatefulWatch hash",
"  // and when a change to any attribute is detected, the DOM class attribute for `this.stateNode` or `this.domNode` is",
"  // recalculated and set to reflect the changed attribute value(s).",
"  // ",
"  // The class attribute (call this the \"class string\") calculation formulates a set of state classes that",
"  // reflect the value of the watched attributes.  The set begins with the classes in cssStatefulBases. Then,",
"  // the set of state classes is aggregated to form a valid class string as follows:",
"  // ",
"  // * If the value of a particular watched attribute is 0 in the cssStatefulWatch hash, then the state class",
"  //   associated with that attribute as calculated by cssStatefulGet (if any) is added to the class string.",
"  // ",
"  // * If the value of a particular watched attribute is a positive integer in the cssStatefulWatch hash, then the state class",
"  //   returned by cssStatefulGet is multiplied with any other watched attribute state classes that are also designated to be",
"  //   multiplied. Multiplied means that every possible combination of attributes is calculated. The value of a particular",
"  //   attribute in the cssStatefulWatch hash gives the order of combined state classes.",
"  // ",
"  // For an example, if a particular class defines...",
"  //code",
"  // csssStateBases: {navigateable:0, coolWidget:1}",
"  // cssStatefulWatch: {focus:0, state:2, readOnly:3}",
"  ///",
"  // And cssStatefulGet returns state classes focus->\"focus\", state->\"Error\", readOnly->\"ReadOnly\", then the class string would",
"  // be",
"  //code",
"  // \"navigateable focus coolWidget Error coolWidgetError ReadOnly coolWidgetReadOnly ErrorReadOnly coolWidgetErrorReadOnly\"",
"  ///",
"  // Notice how the values associated with items in cssStatefulBases and cssStatefulWatch completely determine what is multiplied",
"  // and the order of individual class states in multiplied items.",
"  //",
"  // The machinery is careful not to change components of the class string that it does not control.",
"  //warn",
"  // This class requires a postscript process to properly find and connect all non-trivial connection points. Often,",
"  // this class is used in a hierarchy that includes bd.visual which includes a sufficient postscript process. If",
"  // you are using this class in a derivation chain where no other class includes a postscript, then ensure that bd.cssStateful.create is",
"  // applied during the creation process.",
"  ",
"  //class name",
"  \"bd:cssStateful\", ",
"  ",
"  //superclasses",
"  [],",
"",
"  //members",
"  {",
"  cssStatefulBases: ",
"    ///",
"    // A hash of class names to add to the class string unconditionally. //A value of zero indicates the particular class name",
"    // should not be multiplied; a positive value indicates the position relative to other multiplied class names in the class",
"    // string. See bd.cssStateful.",
"    {},",
"",
"  cssStatefulWatch: ",
"    ///",
"    // A hash of the attributes to watch. //A value of zero indicates the class name (as returned by `this.cssStatefulGet`)",
"    // should not be multiplied; a positive value indicates the position relative to other multiplied class names in the class",
"    // string. See bd.cssStateful. See bd.cssStateful. See bd.visual.cssStatefulWatch for an example.",
"    {},",
"",
"  cssStatefulSet: ",
"    ///",
"    // The current set of class names that have been added to the class attribute of the DOM node.",
"    //private",
"    //nosource",
"    [],",
"",
"  postcreateDom: function() {",
"    ///",
"    // Initializes the class attribute of the DOM node with the class names this instance controls.",
"    this.inherited(arguments);  ",
"    bd.forEachHash(this.cssStatefulWatch, function(mx, attribute) {",
"      this.watch(attribute, \"cssStatefulSetClass\", this, attribute);",
"    }, this);",
"    // Set state initially; the mouse states are almost-certainly unpredictable until the mouse is moved *after*",
"    // the new DOM tree is present.",
"    this.cssStatefulSetClass();",
"  },",
"",
"  cssStatefulGet: function(",
"    name, ///(string) Attribute name.",
"    value ///(any) The result of this.get(name).",
"  ) {",
"    ///",
"    // Return the class state (i.e., the class name) for the attribute `name` with value `value`. //`value` is the current value",
"    // of the attribute, but the class state may depend on more than just this item. Falsy implies",
"    // the attribute does not currently have a class state.",
"    // ",
"    // Client classes may override this member in order to expand or change computation of particular attributes.",
"    //return",
"    //(string) The class state of attribute `name`;",
"    //(falsy) There is currently no class state for attribute `name`.",
"    switch (name) {",
"      case \"visible\":",
"        return !value && \"Hidden\";",
"",
"      case \"rtl\":",
"        return !this.isLeftToRight() && \"Rtl\";",
"",
"      case \"selected\":",
"        return value && \"Selected\";",
"",
"      case \"disabled\":",
"        return value && \"Disabled\";",
"",
"      case \"readOnly\":",
"        return value && \"ReadOnly\";",
"",
"      case \"focused\":",
"        return value && \"Focused\";",
"",
"      case \"active\":",
"        return value && \"Active\";",
"",
"      case \"hover\":",
"        return value && (this.cssStatefulWatch.active===undefined || !this.get(\"active\")) && \"Hover\";",
"",
"      default:",
"        //e.g., this.state",
"        return value && value;",
"    }",
"  },",
"",
"  cssStatefulSetClass: function(){",
"    ///",
"    // Sets the class attribute on `this.stateNode` or `this.domNode` to reflect the current value of",
"    // the watched attributes. //Components in the class attribute that are not controlled by this",
"    // machinery are not affected. See bd.cssStateful.",
"    //note",
"    // Typically, client do not apply this method directly (although such an application would be harmless). Instead,",
"    // this method is applied automatically upon modification of a watched attribute.",
"    var ",
"      states= [],",
"      mxStates= [];",
"    bd.forEachHash(this.cssStatefulBases, function(order, base) { ",
"      if (order) {",
"        mxStates.push([base, order]);",
"      } else {",
"        states.push(base);",
"      }",
"    });",
"    bd.forEachHash(this.cssStatefulWatch, function(order, attribute) {",
"      var ",
"        value= this.get(attribute),",
"        state= this.cssStatefulGet(attribute, value);",
"      if (state) {",
"        if (order) {",
"          mxStates.push([state, order]);",
"        } else {",
"          states.push(state);",
"        }",
"      }",
"    }, this);",
"",
"    //do any multiplication",
"    var result= [];",
"    bd.forEach(mxStates.sort(function(lhs, rhs) { return lhs[1]-rhs[2]; }), function(item) {",
"      var state= item[0];",
"      result= result.concat(bd.map(result, function(existing) { return existing + state; }), state);",
"    });",
"    states= states.concat(result);",
"",
"    // Remove old state states and add new ones.",
"    // For performance concerns we only write into domNode.className once.",
"    var ",
"      node= this.stateNode || this.domNode,",
"      classString= bd.trim(node.className),",
"      classHash= {};",
"",
"    // get set of all classes (state and otherwise) for node",
"    if (classString) {",
"      bd.forEach(node.className.split(\" \"), function(item) { classHash[item]= 1; });",
"    }",
"",
"    // delete all the states previously set",
"    bd.forEach(this.cssStatefulSet, function(item) { delete classHash[item]; });",
"",
"    // add all the states just calculated",
"    bd.forEach(states, function(state) { classHash[state]= 1; });",
"",
"    // convert to a proper class string and set",
"    node.className= bd.mapHash(classHash, function(value, name) { return name; }).join(\" \");",
"",
"    // remember what we just did for the next time",
"    this.cssStatefulSet= states;",
"  }",
"});",
"",
"});"]}
,"bd.cssStateful":{
type:
Tclass,
sdoc:
["Mixin class for widgets that mirror certain attribute values in a DOM node class attribute."],
ldoc:
["The machinery provided by this mixin watches the set of attributes given in the cssStatefulWatch hash\nand when a change to any attribute is detected, the DOM class attribute for `this.stateNode` or `this.domNode` is\nrecalculated and set to reflect the changed attribute value(s).\n\nThe class attribute (call this the \"class string\") calculation formulates a set of state classes that\nreflect the value of the watched attributes.  The set begins with the classes in cssStatefulBases. Then,\nthe set of state classes is aggregated to form a valid class string as follows:\n\n* If the value of a particular watched attribute is 0 in the cssStatefulWatch hash, then the state class\n  associated with that attribute as calculated by cssStatefulGet (if any) is added to the class string.\n\n* If the value of a particular watched attribute is a positive integer in the cssStatefulWatch hash, then the state class\n  returned by cssStatefulGet is multiplied with any other watched attribute state classes that are also designated to be\n  multiplied. Multiplied means that every possible combination of attributes is calculated. The value of a particular\n  attribute in the cssStatefulWatch hash gives the order of combined state classes.\n\nFor an example, if a particular class defines...",
[CODE,"csssStateBases: {navigateable:0, coolWidget:1}\ncssStatefulWatch: {focus:0, state:2, readOnly:3}"],
"And cssStatefulGet returns state classes focus->\"focus\", state->\"Error\", readOnly->\"ReadOnly\", then the class string would\nbe",
[CODE,"\"navigateable focus coolWidget Error coolWidgetError ReadOnly coolWidgetReadOnly ErrorReadOnly coolWidgetErrorReadOnly\""],
"Notice how the values associated with items in cssStatefulBases and cssStatefulWatch completely determine what is multiplied\nand the order of individual class states in multiplied items.\n\nThe machinery is careful not to change components of the class string that it does not control.",
[WARN,"This class requires a postscript process to properly find and connect all non-trivial connection points. Often,\nthis class is used in a hierarchy that includes bd.visual which includes a sufficient postscript process. If\nyou are using this class in a derivation chain where no other class includes a postscript, then ensure that bd.cssStateful.create is\napplied during the creation process."]],
src:
"bd/cssStateful",
loc: [6,0,194,2],
module:"bd/cssStateful"}
,"bd.cssStateful.cssStatefulBases":{
type:
Tvariable,
sdoc:
["A hash of class names to add to the class string unconditionally. "],
imember:1,
ldoc:
["A hash of class names to add to the class string unconditionally. A value of zero indicates the particular class name\nshould not be multiplied; a positive value indicates the position relative to other multiplied class names in the class\nstring. See bd.cssStateful."],
loc: [54,2,59,6]}
,"bd.cssStateful.cssStatefulWatch":{
type:
Tvariable,
sdoc:
["A hash of the attributes to watch. "],
imember:1,
ldoc:
["A hash of the attributes to watch. A value of zero indicates the class name (as returned by `this.cssStatefulGet`)\nshould not be multiplied; a positive value indicates the position relative to other multiplied class names in the class\nstring. See bd.cssStateful. See bd.cssStateful. See bd.visual.cssStatefulWatch for an example."],
loc: [61,2,66,6]}
,"bd.cssStateful.cssStatefulSet":{
type:
Tvariable,
sdoc:
["The current set of class names that have been added to the class attribute of the DOM node."],
imember:1,
ldoc:
[],
flags:
[Fnosource,Fprivate],
loc: [68,2,73,6]}
,"bd.cssStateful.postcreateDom":{
type:
Tfunction,
sdoc:
["Initializes the class attribute of the DOM node with the class names this instance controls."],
imember:1,
ldoc:
[],
loc: [75,2,85,3]}
,"bd.cssStateful.cssStatefulGet":{
type:
Tfunction,
sdoc:
["Return the class state (i.e., the class name) for the attribute `name` with value `value`. "],
imember:1,
ldoc:
["Return the class state (i.e., the class name) for the attribute `name` with value `value`. `value` is the current value\nof the attribute, but the class state may depend on more than just this item. Falsy implies\nthe attribute does not currently have a class state.\n\nClient classes may override this member in order to expand or change computation of particular attributes."],
params:
[["name",[["string",
["Attribute name."]]]],
["value",[["any",
["The result of this.get(name)."]]]]],
returns:
[["string",
["The class state of attribute `name`;"]],
["falsy",
["There is currently no class state for attribute `name`."]]],
loc: [87,2,129,3]}
,"bd.cssStateful.cssStatefulSetClass":{
type:
Tfunction,
sdoc:
["Sets the class attribute on `this.stateNode` or `this.domNode` to reflect the current value of\nthe watched attributes. "],
imember:1,
ldoc:
["Sets the class attribute on `this.stateNode` or `this.domNode` to reflect the current value of\nthe watched attributes. Components in the class attribute that are not controlled by this\nmachinery are not affected. See bd.cssStateful.",
[NOTE,"Typically, client do not apply this method directly (although such an application would be harmless). Instead,\nthis method is applied automatically upon modification of a watched attribute."]],
loc: [131,2,193,3]}
,"modules.bd/cssStateful":{
type:
Tmodule,
sdoc:
["Defines the bd.cssStateful class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/cssStateful",
loc: [0,0,196,2]}
,"resources.bd/declare":{
type:
Tresource,
sdoc:
["Defines the module bd/declare"],
src:
"bd/declare",
modules:
["bd/declare"],
docLocs:
[[74,92]],
code:
["dojo.def(\"bd/declare\", [\"bd/kernel\", \"dojo\", \"bd/lang\"], function(bd, dojo) {",
"///",
"// Defines bd.declare.",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load the module bd. See module.bd.",
"",
"bd.declare=",
"  function(",
"    className,    ///(jsName) The location to store the result in context and the `declaredClass` property.",
"    context,      ///(string) The module in which to store result if className is provided.",
"                  //(otherwise) Store result in bd.global if className is provided.",
"    superClasses, ///(array, optional, []) The list of base classes for the new class.",
"    vargs         ///(variableArgs) One or more objects that give properties for prototype for the new constructor",
"  ) {",
"    ///",
"    // Creates a new constructor function. //This is a wrapper around dojo.declare that adds additional capabilities:",
"    // ",
"    // 1. The new class is stored at at `bd.get(className``[``, context``]``)`.",
"    // 2. The new class includes the factory function `create` where `ctor.create(``arguments...``)`, `ctor` a constructor",
"    //    function returned by `bd.declare`, is equivalent",
"    //    to `new ctor(``arguments...``)`, thereby allowing objects to be created by `apply`. This eliminates the requirement",
"    //    for the defective JavaScript `new` operator.",
"    // 3. The prototype may be specified by providing multiple objects compared to just one; an example of the value of this",
"    //    is given below.",
"    // ",
"    // Examples:",
"    //code",
"    //  bd.declare(\"myNamespace.myClassName\", myModule, [], {});",
"    ///",
"    // is equivalent to...",
"    //code",
"    // var temp= dojo.declare([], {});",
"    // bd.set(\"myNamespace.myClassName\", myModule, temp);",
"    // temp.declaredClass= \"myNamespace.myClassName\";",
"    ///",
"    // Notice that context can be a string or falsy with semantics as given by bd.get.",
"    //warn",
"    // If `className` is given and the provided value is *not* a bd.modulePropertyName (i.e., a string containing a \":\"), then",
"    // `context` *must* be provided.",
"    // ",
"    // vargs are mixed to form one object. For example,",
"    //code",
"    // attr= function(name, defaultValue) {",
"    //   var result= {};",
"    //   result[name]= defaultValue;",
"    //   result[name + \"Set\"]= function(value) { this[name]= value; };",
"    //   result[name + \"Get\"]= function() { return this[name]; };",
"    // };",
"    //",
"    // bd.declare(\"myNamespace.myClassName\", myModule, [], {",
"    //   attr(\"x\", 0),",
"    //   attr(\"y\", 0),",
"    //   attr(\"color\", \"red\")",
"    // });",
"    ///",
"    // is equivalent to...",
"    //code",
"    // var temp= dojo.declare([], {",
"    //   x: 0,",
"    //   xSet: function(value) { this[\"x\"]= value; };",
"    //   xGet: function(value) { return this[\"x\"]; };",
"    //   y: 0,",
"    //   ySet: function(value) { this[\"y\"]= value; };",
"    //   yGet: function(value) { return this[\"y\"]; };",
"    //   color: 0,",
"    //   colorSet: function(value) { this[\"color\"]= value; };",
"    //   colorGet: function(value) { return this[\"color\"]; };",
"    // });",
"    // bd.set(\"myNamespace.myClassName\", myModule, temp);",
"    // temp.declaredClass= \"myNamespace.myClassName\";",
"    ///",
"    // This idea allows for writing functions that help build up specialized class machinery. See bd.stateful for",
"    // a canonical example.",
"    bd.docGen(\"overload\",",
"      function(",
"        className, ///(bd.modulePropertyName) The location to store the resulting constructor.",
"        superClasses,",
"        vargs",
"      ) {",
"        ///",
"        // Same as primary signature except that context is derived from className. This signature is recognized by the first argument",
"        // being of type bd.modulePropertyName (i.e., a string containing a \":\").",
"      },",
"      function(",
"        superClasses,",
"        vargs",
"      ) {",
"        ///",
"        // Same as primary signature except that result is not stored and `declaredClass` is not initialized. This signature is recognized",
"        // by the first argument *not* a string.",
"      }",
"    );",
"    var",
"      currentValue,",
"      result,",
"      parts,",
"      getProto= function(base, start, args) {",
"        for (var i= start; i<args.length; i++) {",
"          base= bd.mix(base, args[i]);",
"        }",
"        return base;",
"      };",
" ",
"    if (bd.isString(className)) {",
"      parts= className.split(\":\");",
"      if (parts[0]==className) {",
"        result= dojo.declare(superClasses, getProto(vargs, 4, arguments));",
"        currentValue= bd.get(className, context);",
"      } else {",
"        // className is a bd.modulePropertyName, therefore signature is (className, superClasses, arg0, arg1, ...)",
"        // context holds superClasses; superClasses holds first vargs, ",
"        result= dojo.declare(context, getProto(superClasses, 3, arguments));",
"        context= 0;",
"        currentValue= bd.get(className);",
"      }",
"    } else {",
"      // no className, and therefore, no context",
"      // className holds superClasses, context holds first vargs",
"      return dojo.declare(className, getProto(context, 2, arguments));",
"    }",
"    result.declaredClass= className;",
"",
"    var f= function(){};",
"    f.prototype= result.prototype;;",
"    result.create= function() {",
"      var o= new f();",
"      result.apply(o, bd.array(arguments));",
"      return o;",
"    };",
"",
"    bd.set(className, context, result);",
"    currentValue && bd.mix(result, currentValue);",
"    return result;",
"  };",
"",
"bd.safeMixin= ",
"  ///",
"  // Safely mix properties into objects created with bd.declare; an alias for dojo.safeMixin.",
"  //note",
"  // This function is an alias for dojo.Deferred.",
"  dojo.safeMixin;",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.declare":{
type:
Tfunction,
sdoc:
["Creates a new constructor function. "],
ldoc:
["Creates a new constructor function. This is a wrapper around dojo.declare that adds additional capabilities:\n\n1. The new class is stored at at `bd.get(className``[``, context``]``)`.\n2. The new class includes the factory function `create` where `ctor.create(``arguments...``)`, `ctor` a constructor\n   function returned by `bd.declare`, is equivalent\n   to `new ctor(``arguments...``)`, thereby allowing objects to be created by `apply`. This eliminates the requirement\n   for the defective JavaScript `new` operator.\n3. The prototype may be specified by providing multiple objects compared to just one; an example of the value of this\n   is given below.\n\nExamples:",
[CODE,"bd.declare(\"myNamespace.myClassName\", myModule, [], {});"],
"is equivalent to...",
[CODE,"var temp= dojo.declare([], {});\nbd.set(\"myNamespace.myClassName\", myModule, temp);\ntemp.declaredClass= \"myNamespace.myClassName\";"],
"Notice that context can be a string or falsy with semantics as given by bd.get.",
[WARN,"If `className` is given and the provided value is *not* a bd.modulePropertyName (i.e., a string containing a \":\"), then\n`context` *must* be provided."],
"vargs are mixed to form one object. For example,",
[CODE,"attr= function(name, defaultValue) {\n  var result= {};\n  result[name]= defaultValue;\n  result[name + \"Set\"]= function(value) { this[name]= value; };\n  result[name + \"Get\"]= function() { return this[name]; };\n};\n\nbd.declare(\"myNamespace.myClassName\", myModule, [], {\n  attr(\"x\", 0),\n  attr(\"y\", 0),\n  attr(\"color\", \"red\")\n});"],
"is equivalent to...",
[CODE,"var temp= dojo.declare([], {\n  x: 0,\n  xSet: function(value) { this[\"x\"]= value; };\n  xGet: function(value) { return this[\"x\"]; };\n  y: 0,\n  ySet: function(value) { this[\"y\"]= value; };\n  yGet: function(value) { return this[\"y\"]; };\n  color: 0,\n  colorSet: function(value) { this[\"color\"]= value; };\n  colorGet: function(value) { return this[\"color\"]; };\n});\nbd.set(\"myNamespace.myClassName\", myModule, temp);\ntemp.declaredClass= \"myNamespace.myClassName\";"],
"This idea allows for writing functions that help build up specialized class machinery. See bd.stateful for\na canonical example."],
params:
[["className",[["jsName",
["The location to store the result in context and the `declaredClass` property."]]]],
["context",[["string",
["The module in which to store result if className is provided."]],
["otherwise",
["Store result in bd.global if className is provided."]]]],
["superClasses",[["array, optional, []",
["The list of base classes for the new class."]]]],
["vargs",[["variableArgs",
["One or more objects that give properties for prototype for the new constructor"]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Same as primary signature except that context is derived from className. This signature is recognized by the first argument\nbeing of type bd.modulePropertyName (i.e., a string containing a \":\")."],
ldoc:
[],
params:
[["className",[["bd.modulePropertyName",
["The location to store the resulting constructor."]]]],
["superClasses",[]],
["vargs",[]]],
loc: [75,6,83,7]}
,
{
type:
Tfunction,
sdoc:
["Same as primary signature except that result is not stored and `declaredClass` is not initialized. This signature is recognized\nby the first argument *not* a string."],
ldoc:
[],
params:
[["superClasses",[]],
["vargs",[]]],
loc: [84,6,91,7]}
],
src:
"bd/declare",
loc: [7,0,134,3],
module:"bd/declare"}
,"bd.safeMixin":{
type:
Tvariable,
sdoc:
["Safely mix properties into objects created with bd.declare; an alias for dojo.safeMixin."],
ldoc:
[[NOTE,"This function is an alias for dojo.Deferred."]],
src:
"bd/declare",
loc: [136,0,141,16],
module:"bd/declare"}
,"modules.bd/declare":{
type:
Tmodule,
sdoc:
["Defines bd.declare."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load the module bd. See module.bd."]],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/declare",
loc: [0,0,143,2]}
,"resources.bd/descriptor/cache":{
type:
Tresource,
sdoc:
["Defines the module bd/descriptor/cache"],
src:
"bd/descriptor/cache",
modules:
["bd/descriptor/cache"],
code:
["dojo.def(\"bd/descriptor/cache\", [",
"  \"dojo\", \"bd\",",
"  \"bd/namespace\"",
"], function(dojo, bd) {",
"///",
"// Defines the class bd.decriptor.cache.",
"",
"bd.declare(",
"  ///",
"  // Implements a cache of Backdraft descriptors.",
"",
"  //class name",
"  \"bd:descriptor.cache\",",
"  ",
"  //superclasses",
"  [bd.namespace], ",
"",
"  //members",
"  {",
"",
"  preamble: function(",
"    creator, ///(*bd.descriptor.cache.constructor.creator)",
"    keepRawText ///(*bd.descriptor.cache.constructor.keepRawText)",
"  ){",
"    ///",
"    // Arranges constructor arguments appropriate for the superclass bd.namespace.",
"    return [creator, false];",
"  },",
"",
"  constructor: function(",
"    creator,    ///(*) Function used to retrieve the raw text of a descriptor",
"    keepRawText ///(boolean, optional, false] The raw script text is maintained and available through bd.descriptor.cache.getRaw iff true.",
"  ){",
"    ///",
"    // Initializes a new cache.",
"    this._rawHash={};",
"    this._inFlight= {};",
"    this.keepRawText= !!keepRawText;",
"  },",
"",
"  get: function(",
"    name,   ///(string) Identifies the descriptor to get.",
"    onLoad, ///(function(descriptor)) The function to call back when the descriptor is available.",
"    onError ///(function(error)) The function to call back if an error occures retrieving the descriptor.",
"  ) {",
"    ///",
"    // Retrieves the descriptor given by name calls back onLoad with the result. //Calls back onError",
"    // with the error object in the event the retrieval fails.",
"    //",
"    // Descriptors are cached as they are retrieved. A dojo.Deferred is created that waits for the retriveal",
"    // operation to complete and then calls onLoad. If the descriptor is in the cache, then onLoad is called immediately.",
"    // Canonically, onError is called if retrieving the descriptor results in an error.",
"    //",
"    // Notice that a dojo.Deferred is created and returned that controls calling onLoad/onError whether or not",
"    // the descriptor was already in the cache; this should simplify client code.",
"",
"    var",
"      result= new dojo.Deferred(dojo.hitch(this, \"_onCancel\", name)),",
"      descriptor= this._hash[name];",
"    result.addCallbacks(onLoad||null, onError||null);",
"    if (descriptor) {",
"      result.callback(descriptor);",
"    } else if (this._inFlight[name]) {",
"      this._inFlight[name].push(result);",
"    } else {",
"      this._inFlight[name]= [result];",
"      this.creator(name, dojo.hitch(this, \"_onLoad\", name), dojo.hitch(this, \"_onError\", name));",
"    }",
"    return result; //(dojo.Deferred) The dojo.Deferred object that controls the asynchronous retrieval of the descriptor.",
"  },",
"",
"  getRaw: function(",
"    name /// (*bd.descriptor.cache.constructor.name)",
"  ) {",
"    ///",
"    // Returns the raw text of a descriptor script.",
"    ///",
"    // The cache must be created with bd.descriptor.cache.constructor.keepRawText true in order for raw text to be",
"    // available. Additionally, the descriptor must have been already successfully retrieved by bd.descriptor.get. Failure to meet",
"    // either of these two requirements results in this function returning undefined.",
"",
"    return this._rawHash[name];",
"  },",
"",
"  _onLoad: function(",
"    name,         /// (*bd.descriptor.cache.constructor.name)",
"    rawDescriptor /// (string) The descriptor raw text.",
"  ) {",
"    ///",
"    // Processes a newly arrived descriptor. //dojo.eval the descriptor, store it in the cache, call back all dojo.Deferred objects waiting on the descriptor.",
"    // `private",
"",
"    var descriptor= dojo.eval(rawDescriptor + \"\\r\\n//@ sourceURL=\" + name);",
"    if (!(descriptor instanceof Object)) {",
"      dojo.forEach(this._inFlight[name], function(item) { item.errback(Error(\"Data returned by server was not a descriptor.\")); });",
"    } else {",
"      descriptor.descriptorId= name;",
"      this._hash[name]= descriptor;",
"      if (this.keepRawText) {",
"        this._rawHash[name]= rawDescriptor;",
"      }",
"      dojo.forEach(this._inFlight[name], function(item) { item.callback(descriptor); });",
"    }",
"    delete this._inFlight[name];",
"  },",
"",
"  _onError: function(",
"    name, /// (*bd.descriptor.cache.constructor.name)",
"    error /// (any) The error signaled by the creator.",
"  ) {",
"    ///",
"    // Signals an error to all dojo.Deferred objects waiting on the descriptor.",
"    // `private",
"",
"    dojo.forEach(this._inFlight[name], function(item) { item.errback(error); });",
"    delete this._inFlight[name];",
"  },",
"",
"  _onCancel: function(",
"    name,       /// (*bd.descriptor.cache.constructor.name)",
"    theDeferred /// (dojo.Deferred) The dojo.Deferred to cancel.",
"  ) {",
"    ///",
"    // Cancel a waiting dojo.Deferred.",
"    // `warn This results in the onError handler being called for each waiting dojo.Deferred.",
"    // `private",
"",
"    for (var inFlight= this._inFlight[name], i= 0, end= inFlight.length; i<end; i++) {",
"      if (inFlight[i]===theDeferred) {",
"        inFlight.splice(i, 1);",
"        return;",
"      }",
"    }",
"  }",
"});",
"",
"bd.descriptor.cache.constructor.creator= function(",
"  name, ///(string) Indentifies the descriptor to retrieve.",
"  onLoad, ///(function(desciptorText)) The function to apply to the raw descriptor text upon reception.",
"  onError ///(function(error)) The function to apply to the Error object upon an error during retrieval.",
"){",
"  ///",
"  // Retrieves (asynchronously) the raw decriptor text as given by name and passes the result to onLoad; upon",
"  // failure, passes the error to onError.",
"  // `type",
"};",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.descriptor.cache":{
type:
Tclass,
sdoc:
["Implements a cache of Backdraft descriptors."],
ldoc:
[],
src:
"bd/descriptor/cache",
loc: [7,0,134,2],
supers:
["bd.namespace"],
module:"bd/descriptor/cache"}
,"bd.descriptor.cache.preamble":{
type:
Tfunction,
sdoc:
["Arranges constructor arguments appropriate for the superclass bd.namespace."],
imember:1,
ldoc:
[],
params:
[["creator",[["*bd.descriptor.cache.constructor.creator",
[]]]],
["keepRawText",[["*bd.descriptor.cache.constructor.keepRawText",
[]]]]],
loc: [20,2,27,3]}
,"bd.descriptor.cache.constructor":{
type:
Tfunction,
sdoc:
["Initializes a new cache."],
imember:1,
ldoc:
[],
params:
[["creator",[["*",
["Function used to retrieve the raw text of a descriptor"]]]],
["keepRawText",[["",
["(boolean, optional, false] The raw script text is maintained and available through bd.descriptor.cache.getRaw iff true."]]]]],
loc: [29,2,38,3]}
,"bd.descriptor.cache.get":{
type:
Tfunction,
sdoc:
["Retrieves the descriptor given by name calls back onLoad with the result. "],
imember:1,
ldoc:
["Retrieves the descriptor given by name calls back onLoad with the result. Calls back onError\nwith the error object in the event the retrieval fails.\n\nDescriptors are cached as they are retrieved. A dojo.Deferred is created that waits for the retriveal\noperation to complete and then calls onLoad. If the descriptor is in the cache, then onLoad is called immediately.\nCanonically, onError is called if retrieving the descriptor results in an error.\n\nNotice that a dojo.Deferred is created and returned that controls calling onLoad/onError whether or not\nthe descriptor was already in the cache; this should simplify client code."],
params:
[["name",[["string",
["Identifies the descriptor to get."]]]],
["onLoad",[["function(descriptor)",
["The function to call back when the descriptor is available."]]]],
["onError",[["function(error)",
["The function to call back if an error occures retrieving the descriptor."]]]]],
loc: [40,2,69,3]}
,"bd.descriptor.cache.getRaw":{
type:
Tfunction,
sdoc:
["Returns the raw text of a descriptor script."],
imember:1,
ldoc:
["The cache must be created with bd.descriptor.cache.constructor.keepRawText true in order for raw text to be\navailable. Additionally, the descriptor must have been already successfully retrieved by bd.descriptor.get. Failure to meet\neither of these two requirements results in this function returning undefined."],
params:
[["name",[["",
["(*bd.descriptor.cache.constructor.name)"]]]]],
loc: [71,2,82,3]}
,"bd.descriptor.cache._onLoad":{
type:
Tfunction,
sdoc:
["Processes a newly arrived descriptor. "],
imember:1,
ldoc:
["Processes a newly arrived descriptor. dojo.eval the descriptor, store it in the cache, call back all dojo.Deferred objects waiting on the descriptor."],
flags:
[Fprivate],
params:
[["name",[["",
["(*bd.descriptor.cache.constructor.name)"]]]],
["rawDescriptor",[["",
["(string) The descriptor raw text."]]]]],
loc: [84,2,104,3]}
,"bd.descriptor.cache._onError":{
type:
Tfunction,
sdoc:
["Signals an error to all dojo.Deferred objects waiting on the descriptor."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
params:
[["name",[["",
["(*bd.descriptor.cache.constructor.name)"]]]],
["error",[["",
["(any) The error signaled by the creator."]]]]],
loc: [106,2,116,3]}
,"bd.descriptor.cache._onCancel":{
type:
Tfunction,
sdoc:
["Cancel a waiting dojo.Deferred."],
imember:1,
ldoc:
[[WARN,"This results in the onError handler being called for each waiting dojo.Deferred."]],
flags:
[Fprivate],
params:
[["name",[["",
["(*bd.descriptor.cache.constructor.name)"]]]],
["theDeferred",[["",
["(dojo.Deferred) The dojo.Deferred to cancel."]]]]],
loc: [118,2,133,3]}
,"bd.descriptor.cache.constructor.creator":{
type:
Ttype,
sdoc:
["Retrieves (asynchronously) the raw decriptor text as given by name and passes the result to onLoad; upon\nfailure, passes the error to onError."],
ldoc:
[],
flags:
[Ffunction],
params:
[["name",[["string",
["Indentifies the descriptor to retrieve."]]]],
["onLoad",[["function(desciptorText)",
["The function to apply to the raw descriptor text upon reception."]]]],
["onError",[["function(error)",
["The function to apply to the Error object upon an error during retrieval."]]]]],
src:
"bd/descriptor/cache",
loc: [136,0,145,1],
module:"bd/descriptor/cache"}
,"modules.bd/descriptor/cache":{
type:
Tmodule,
sdoc:
["Defines the class bd.decriptor.cache."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/descriptor/cache",
loc: [0,0,147,2]}
,"resources.bd/descriptor/processor":{
type:
Tresource,
sdoc:
["Defines the module bd/descriptor/processor"],
src:
"bd/descriptor/processor",
modules:
["bd/descriptor/processor"],
docLocs:
[[11,26]],
code:
["dojo.def(\"bd/descriptor/processor\", [",
"  \"dojo\", \"bd\"",
"], function(dojo, bd) {",
"///",
"// Defines various machinery to process bd.descriptor objects.",
"",
"bd.descriptor=",
"  ///namespace",
"  // Contains a set of functions for manipulating bd.descriptor objects.",
"  bd.descriptor || {};",
"",
"bd.docGen(\"bd.descriptor\", {",
"  program:",
"    ///type",
"    // An array of functions that transform a descriptor. //Each item in the array may be one of:",
"    // ",
"    // 1. a string that specifies a property of bd.descriptor.processor",
"    // 2. an array of a string that specifies a property of bd.descriptor.processor",
"    //    and additional arguments to apply when that function is applied to a descriptor",
"    // 3. a function",
"    // ",
"    // When a transform function is applied to a descriptor, the descriptor is always the first argument. Additional",
"    // arguments can be provided by providing the transform via variant [2] above,  or variant [3] above with the aid",
"    // of bd.partial. See bd.descriptor.processor.",
"    //",
"    0",
"});",
"",
"bd.descriptor.processor= function(",
"  descriptor, ///(bd.descriptor) the descriptor to transform",
"  program     ///(array of bd.descriptor.program) the transforms and required arguments to apply to descriptor",
") {",
"  ///",
"  // Applies each function given in program to descriptor. ",
"  ///",
"  // Transform functions allow convenient shorthand notation when defining a bd.descriptor object. For example, the",
"  // transform function bd.descriptor.processor.autotab sets the tab order while executing a depth-first traversal",
"  // of the descriptor\'s children (see bd.descriptor.processor.autotab for details).",
"  //",
"  dojo.forEach(program, function(item) {",
"    var",
"      fp,",
"      args= [descriptor];",
"    if (dojo.isString(item)) {",
"      fp= bd.descriptor.processor[item];",
"    } else {",
"      fp= bd.descriptor.processor[item[0]];",
"      args= args.concat(item.slice(1));",
"    }",
"    try {",
"      fp.apply(descriptor, args);",
"    } catch (e) {",
"      console.error(\"exception in bd.descriptor.processor (item=%o) (exception=%o)\", item, e);",
"    }",
"  });",
"};",
"",
"dojo.mix(bd.descriptor.processor, {",
"  traverse: function(",
"    descriptor, ///(bd.descriptor) The descriptor to traverse.",
"    proc        ///(function) The transform function to apply to descriptor and its children.",
"  ) {",
"    ///",
"    // Applies proc to descriptor, then recurses into each child of descriptor (if any).",
"    proc(descriptor);",
"    if (!descriptor.children) {",
"      return;",
"    }",
"    for (var children= descriptor.children, i= 0, end= children.length; i<end; i++) {",
"      arguments.callee(children[i], proc);",
"    }",
"  },",
"",
"  traverseChildren: function(",
"    descriptor, ///(bd.descriptor) The descriptor to transform.",
"    proc        ///(function) The transform function to apply to each of descriptor\'s children.",
"  ) {",
"    ///",
"    // Applies proc to each child, grandchild, etc.,  of descriptor.",
"    if (descriptor.children) for (var children= descriptor.children, i= 0, end= children.length; i<end; i++) {",
"      bd.descriptor.processor.traverse(children[i], proc);",
"    }",
"  },",
"",
"  mixin: function(",
"    descriptor, ///(bd.descriptor) The descriptor to transform.",
"    props       ///(hash) Properties to mix into descriptor.",
"  ) {",
"    ///",
"    // Mixes props into descriptor.",
"    dojo.mix(descriptor, props);",
"  },",
"",
"  setTabs: function(",
"    descriptor, ///(bd.descriptor) The descriptor to transform",
"    start       ///(integer) The tab order number to start numbering.",
"  ) {",
"    ///",
"    // Sets the tab order in descriptor by a depth-first traversal.",
"    var order= start || 1;",
"    bd.descriptor.processor.traverseChildren(descriptor, function(child) {",
"      child.tabIndex= order++;",
"    });",
"  },",
"",
"  setClass: function(",
"    descriptor",
"  ) {",
"    if (descriptor.name) {",
"      var s= descriptor[\"class\"];",
"      descriptor[\"class\"]= (s ? s + \" \" : \"\") + descriptor.name;",
"    }",
"    bd.descriptor.processor.traverseChildren(descriptor, bd.descriptor.processor.setClass);",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.descriptor":{
type:
Tnamespace,
sdoc:
["Contains a set of functions for manipulating bd.descriptor objects."],
ldoc:
[],
src:
"bd/descriptor/processor",
loc: [6,0,9,21],
module:"bd/descriptor/processor"}
,"bd.descriptor.program":{
type:
Ttype,
sdoc:
["An array of functions that transform a descriptor. "],
ldoc:
["An array of functions that transform a descriptor. Each item in the array may be one of:\n\n1. a string that specifies a property of bd.descriptor.processor\n2. an array of a string that specifies a property of bd.descriptor.processor\n   and additional arguments to apply when that function is applied to a descriptor\n3. a function\n\nWhen a transform function is applied to a descriptor, the descriptor is always the first argument. Additional\narguments can be provided by providing the transform via variant [2] above,  or variant [3] above with the aid\nof bd.partial. See bd.descriptor.processor."],
src:
"bd/descriptor/processor",
loc: [12,2,25,5],
module:"bd/descriptor/processor"}
,"bd.descriptor.processor":{
type:
Tfunction,
sdoc:
["Applies each function given in program to descriptor."],
ldoc:
["Transform functions allow convenient shorthand notation when defining a bd.descriptor object. For example, the\ntransform function bd.descriptor.processor.autotab sets the tab order while executing a depth-first traversal\nof the descriptor\'s children (see bd.descriptor.processor.autotab for details)."],
params:
[["descriptor",[["bd.descriptor",
["the descriptor to transform"]]]],
["program",[["array of bd.descriptor.program",
["the transforms and required arguments to apply to descriptor"]]]]],
src:
"bd/descriptor/processor",
loc: [28,0,55,1],
module:"bd/descriptor/processor"}
,"bd.descriptor.processor.traverse":{
type:
Tfunction,
sdoc:
["Applies proc to descriptor, then recurses into each child of descriptor (if any)."],
ldoc:
[],
params:
[["descriptor",[["bd.descriptor",
["The descriptor to traverse."]]]],
["proc",[["function",
["The transform function to apply to descriptor and its children."]]]]],
src:
"bd/descriptor/processor",
loc: [58,2,71,3],
module:"bd/descriptor/processor"}
,"bd.descriptor.processor.traverseChildren":{
type:
Tfunction,
sdoc:
["Applies proc to each child, grandchild, etc.,  of descriptor."],
ldoc:
[],
params:
[["descriptor",[["bd.descriptor",
["The descriptor to transform."]]]],
["proc",[["function",
["The transform function to apply to each of descriptor\'s children."]]]]],
src:
"bd/descriptor/processor",
loc: [73,2,82,3],
module:"bd/descriptor/processor"}
,"bd.descriptor.processor.mixin":{
type:
Tfunction,
sdoc:
["Mixes props into descriptor."],
ldoc:
[],
params:
[["descriptor",[["bd.descriptor",
["The descriptor to transform."]]]],
["props",[["hash",
["Properties to mix into descriptor."]]]]],
src:
"bd/descriptor/processor",
loc: [84,2,91,3],
module:"bd/descriptor/processor"}
,"bd.descriptor.processor.setTabs":{
type:
Tfunction,
sdoc:
["Sets the tab order in descriptor by a depth-first traversal."],
ldoc:
[],
params:
[["descriptor",[["bd.descriptor",
["The descriptor to transform"]]]],
["start",[["integer",
["The tab order number to start numbering."]]]]],
src:
"bd/descriptor/processor",
loc: [93,2,103,3],
module:"bd/descriptor/processor"}
,"modules.bd/descriptor/processor":{
type:
Tmodule,
sdoc:
["Defines various machinery to process bd.descriptor objects."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/descriptor/processor",
loc: [0,0,116,2]}
,"resources.bd/dijit/accordionContainer":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/accordionContainer"],
src:
"bd/dijit/accordionContainer",
modules:
["bd/dijit/accordionContainer"],
code:
["dojo.def(\"bd/dijit/accordionContainer\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/AccordionContainer\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.accordionContainer.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.AccordionContainer wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.accordionContainer\", [",
"  dijit.AccordionContainer,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.accordionContainer":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.AccordionContainer wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.AccordionContainer wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/accordionContainer",
loc: [10,7,27,28],
supers:
["dijit.AccordionContainer","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/accordionContainer"}
,"modules.bd/dijit/accordionContainer":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.accordionContainer."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/accordionContainer",
loc: [0,0,29,2]}
,"resources.bd/dijit/accordionPane":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/accordionPane"],
src:
"bd/dijit/accordionPane",
modules:
["bd/dijit/accordionPane"],
code:
["dojo.def(\"bd/dijit/accordionPane\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/AccordionPane\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.accordionPane.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.AccordionPane wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.accordionPane\", [",
"  dijit.AccordionPane,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.accordionPane":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.AccordionPane wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.AccordionPane wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/accordionPane",
loc: [10,7,27,28],
supers:
["dijit.AccordionPane","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/accordionPane"}
,"modules.bd/dijit/accordionPane":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.accordionPane."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/accordionPane",
loc: [0,0,29,2]}
,"resources.bd/dijit/button":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/button"],
src:
"bd/dijit/button",
modules:
["bd/dijit/button"],
code:
["dojo.def(\"bd/dijit/button\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/Button\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.button.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.Button wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.button\", [",
"  dijit.form.Button,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor,",
"  bd.containable",
"], {",
"",
"	postCreate: function(){",
"    if (this.width) {",
"      dojo.style(this.titleNode, this.width);",
"    }",
"    this.inherited(arguments);",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.button":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.Button wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.Button wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/button",
loc: [10,7,35,2],
supers:
["dijit.form.Button","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor","bd.containable"],
module:"bd/dijit/button"}
,"modules.bd/dijit/button":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.button."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/button",
loc: [0,0,37,2]}
,"resources.bd/dijit/calendar":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/calendar"],
src:
"bd/dijit/calendar",
modules:
["bd/dijit/calendar"],
code:
["dojo.def(\"bd/dijit/calendar\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/Calendar\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.calendar.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.Calendar wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.calendar\", [",
"  dijit.Calendar,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.calendar":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.Calendar wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.Calendar wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/calendar",
loc: [10,7,27,28],
supers:
["dijit.Calendar","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/calendar"}
,"modules.bd/dijit/calendar":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.calendar."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/calendar",
loc: [0,0,29,2]}
,"resources.bd/dijit/checkBox":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/checkBox"],
src:
"bd/dijit/checkBox",
modules:
["bd/dijit/checkBox"],
code:
["dojo.def(\"bd/dijit/checkBox\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/CheckBox\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.checkBox.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.CheckBox wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.checkBox\", [",
"  dijit.form.CheckBox,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.checkBox":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.CheckBox wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.CheckBox wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/checkBox",
loc: [10,7,26,28],
supers:
["dijit.form.CheckBox","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/checkBox"}
,"modules.bd/dijit/checkBox":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.checkBox."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/checkBox",
loc: [0,0,28,2]}
,"resources.bd/dijit/colorPalette":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/colorPalette"],
src:
"bd/dijit/colorPalette",
modules:
["bd/dijit/colorPalette"],
code:
["dojo.def(\"bd/dijit/colorPalette\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/ColorPalette\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.colorPalette.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.ColorPalette wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.colorPalette\", [",
"  dijit.ColorPalette,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.colorPalette":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.ColorPalette wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.ColorPalette wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/colorPalette",
loc: [10,7,27,28],
supers:
["dijit.ColorPalette","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/colorPalette"}
,"modules.bd/dijit/colorPalette":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.colorPalette."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/colorPalette",
loc: [0,0,29,2]}
,"resources.bd/dijit/comboBox":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/comboBox"],
src:
"bd/dijit/comboBox",
modules:
["bd/dijit/comboBox"],
code:
["dojo.def(\"bd/dijit/comboBox\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/ComboBox\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.comboBox.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.ComboBox wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.comboBox\", [",
"  dijit.form.ComboBox,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.comboBox":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.ComboBox wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.ComboBox wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/comboBox",
loc: [10,7,26,28],
supers:
["dijit.form.ComboBox","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/comboBox"}
,"modules.bd/dijit/comboBox":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.comboBox."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/comboBox",
loc: [0,0,28,2]}
,"resources.bd/dijit/comboButton":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/comboButton"],
src:
"bd/dijit/comboButton",
modules:
["bd/dijit/comboButton"],
code:
["dojo.def(\"bd/dijit/comboButton\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/ComboButton\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.comboButton.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.ComboButton wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.comboButton\", [",
"  dijit.form.ComboButton,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.comboButton":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.ComboButton wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.ComboButton wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/comboButton",
loc: [10,7,26,28],
supers:
["dijit.form.ComboButton","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/comboButton"}
,"modules.bd/dijit/comboButton":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.comboButton."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/comboButton",
loc: [0,0,28,2]}
,"resources.bd/dijit/compat":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/compat"],
src:
"bd/dijit/compat",
modules:
["bd/dijit/compat"],
code:
["dojo.def(\"bd/dijit/compat\", [",
"  \"bd\", ",
"  \"dojo\"",
"], function(bd, dojo) {",
"///",
"// Defines the bd.dijit.disabled, bd.dijit.visible, bd.dijit.focusable, and bd.dijit.constructor mixin classes.",
"",
"bd.dijit= ",
"  ///namespace",
"  // Contains the Dojo widgets wrapped for use with the Backdraft framework.",
"  bd.dijit || {};",
"",
"// switch out the real bd.attr--we want the documentation generator to work but",
"// don\'t want to actually define Backdraft-style attributes.",
"var saveBdAttr= bd.attr, saveBdConstAttr= bd.constAttr;",
"bd.attr= bd.constAttr= bd.noop;",
"",
"bd.declare(",
"  ///",
"  // Mixin class that uniformily provides a `disabled` attribute for dojo widgets.",
"",
"//TODO: don\'t mix this into dijit classes that already have a disabled attribute",
"//TODO: add the bdDisabledCurtain CSS attributes for z-order, position, height, width",
"",
"  //class name",
"  \"bd:dijit.disabled\",",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  bd.attr(",
"    ///",
"    // Controls whether or not the widget will respond to user input.  //When set true, a \"curtain\" is drawn over ",
"    // the widget instance at a higher z-order than the instance. Although the curtain",
"    // is semitransparent, it effectively blocks all user input (keyboard and mouse) from reaching the instance.",
"    ///",
"    //(boolean, optional, false) Causes the underlying widget to be disabled from all user input iff true; no",
"    // affect on widget otherwise.",
"",
"    \"disabled\",",
"",
"     false",
"  ),",
"",
"  {",
"  disabled: false,",
"",
"  _setDisabledAttr: function(value) { //setter",
"    if (value && this.domNode && !this.disabledCurtain) {",
"      this.disabledCurtain= dojo.create(\"div\", {\"class\":\"bdDisabledCurtain\"}, this.domNode, \"first\");",
"    } else if (!value && this.disabledCurtain) {",
"      dojo.destroy(this.disabledCurtain);",
"      delete this.disabledCurtain;",
"    }",
"    var oldValue= this.disabled;",
"    this.disabled= value;",
"    return oldValue;",
"  },",
"",
"  destroy: function() {",
"    if (this.disabledCurtain) {",
"      dojo.destroy(this.disabledCurtain);",
"      delete this.disabledCurtain;",
"    }",
"    this.inherited(arguments);",
"  }",
"});",
"",
"bd.declare(",
"  ///",
"  // Mixin class that provides a `visible` attribute for dojo widgets.",
"",
"  //class name",
"  \"bd:dijit.visible\",",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  bd.attr(",
"    ///",
"    // Controls whether or not the widget is visible.  //Changes the z-index attribute on the underlying widget instance to be set to -100 iff false; no",
"    // affect on widget otherwise. //This has the net effect of hiding the widget without changing other styling (display, size,",
"    // position, and so on).",
"    ///",
"    //(boolean, optional, true)  true if this widget is visible; false otherwise.",
"",
"    \"visible\",",
"",
"     true",
"  ),",
"  ",
"  {",
"  visible: true,",
"",
"  _setVisibleAttr: function(value) {",
"    if (!value && this.domNode && !this.invisible) {",
"      dojo.style(this.domNode, {zIndex:-100});",
"      this.invisible= true;",
"    } else if (value && this.invisible) {",
"      dojo.style(this.domNode, {zIndex:\"\"});",
"      this.invisible= false;",
"    }",
"    var oldValue= this.visible;",
"    this.visible= value;",
"    return oldValue;",
"  }",
"});",
"",
"bd.declare(",
"  ///",
"  // Mixin class that provides a `focusable` attribute (getter only) for dojo widgets.",
"",
"  //class name",
"  \"bd:dijit.focusable\",",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  bd.constAttr(",
"    ///",
"    // Indicates whether or not the widget will accept the focus.",
"    // ",
"    //(boolean) false is the widget and all of its decendents has/have no use for the focus; true otherwise.",
"",
"    \"focusable\"",
"  ),",
"",
"  {",
"  _getFocusableAttr: function() {",
"    // Returns true if this widget can receive the focus; false otherwise.",
"    return this.get(\"visible\") && !this.get(\"disabled\");",
"  }",
"});",
"",
"bd.declare(",
"  ///",
"  // Mixin class that changes constructor signature so that dojo widgets are compatible with bd.createWidget.",
"  ",
"  //class name",
"  \"bd:dijit.constructor\",",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  {",
"  preamble:function(",
"    kwargs //(bd.createWidget.kwargs) Describes how to create an instance.",
"  ) {",
"    return [kwargs.descriptor];",
"  },",
"",
"  postscript: function(",
"    kwargs //(bd.createWidget.kwargs) Describes how to create an instance.",
"  ) {",
"    this.create(kwargs.descriptor);",
"    this.parent= kwargs.parent;",
"  }",
"});",
"",
"bd.attr= saveBdAttr;",
"bd.constAttr= saveBdConstAttr;",
"",
"});"]}
,"bd.dijit":{
type:
Tnamespace,
sdoc:
["Contains the Dojo widgets wrapped for use with the Backdraft framework."],
ldoc:
[],
src:
"bd/dijit/compat",
loc: [7,0,10,16],
module:"bd/dijit/compat"}
,"bd.dijit.disabled":{
type:
Tclass,
sdoc:
["Mixin class that uniformily provides a `disabled` attribute for dojo widgets."],
ldoc:
[],
src:
"bd/dijit/compat",
loc: [17,0,67,2],
module:"bd/dijit/compat"}
,"bd.dijit.disabled.disabled":{
type:
Tvariable,
sdoc:
["Controls whether or not the widget will respond to user input.  "],
imember:1,
ldoc:
["Controls whether or not the widget will respond to user input.  When set true, a \"curtain\" is drawn over\nthe widget instance at a higher z-order than the instance. Although the curtain\nis semitransparent, it effectively blocks all user input (keyboard and mouse) from reaching the instance."],
flags:
[Fattr],
loc: [31,2,43,3],
types:
[["boolean, optional, false",
["Causes the underlying widget to be disabled from all user input iff true; no\n affect on widget otherwise."]]]}
,"bd.dijit.visible":{
type:
Tclass,
sdoc:
["Mixin class that provides a `visible` attribute for dojo widgets."],
ldoc:
[],
src:
"bd/dijit/compat",
loc: [69,0,108,2],
module:"bd/dijit/compat"}
,"bd.dijit.visible.visible":{
type:
Tvariable,
sdoc:
["Controls whether or not the widget is visible.  "],
imember:1,
ldoc:
["Controls whether or not the widget is visible.  Changes the z-index attribute on the underlying widget instance to be set to -100 iff false; no\naffect on widget otherwise. //This has the net effect of hiding the widget without changing other styling (display, size,\nposition, and so on)."],
flags:
[Fattr],
loc: [80,2,91,3],
types:
[["boolean, optional, true",
["true if this widget is visible; false otherwise."]]]}
,"bd.dijit.focusable":{
type:
Tclass,
sdoc:
["Mixin class that provides a `focusable` attribute (getter only) for dojo widgets."],
ldoc:
[],
src:
"bd/dijit/compat",
loc: [110,0,135,2],
module:"bd/dijit/compat"}
,"bd.dijit.focusable.focusable":{
type:
Tvariable,
sdoc:
["Indicates whether or not the widget will accept the focus."],
imember:1,
ldoc:
[],
flags:
[Froattr],
loc: [121,2,128,3],
types:
[["boolean",
["false is the widget and all of its decendents has/have no use for the focus; true otherwise."]]]}
,"bd.dijit.constructor":{
type:
Tclass,
sdoc:
["Mixin class that changes constructor signature so that dojo widgets are compatible with bd.createWidget."],
ldoc:
[],
src:
"bd/dijit/compat",
loc: [137,0,161,2],
module:"bd/dijit/compat"}
,"modules.bd/dijit/compat":{
type:
Tmodule,
sdoc:
["Defines the bd.dijit.disabled, bd.dijit.visible, bd.dijit.focusable, and bd.dijit.constructor mixin classes."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/dijit/compat",
loc: [0,0,166,2]}
,"resources.bd/dijit/contentPane":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/contentPane"],
src:
"bd/dijit/contentPane",
modules:
["bd/dijit/contentPane"],
code:
["dojo.def(\"bd/dijit/contentPane\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/ContentPane\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.contentPane.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.ContentPane wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.contentPane\", [",
"  dijit.ContentPane,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.contentPane":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.ContentPane wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.ContentPane wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/contentPane",
loc: [10,7,27,28],
supers:
["dijit.ContentPane","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/contentPane"}
,"modules.bd/dijit/contentPane":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.contentPane."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/contentPane",
loc: [0,0,29,2]}
,"resources.bd/dijit/currencyTextBox":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/currencyTextBox"],
src:
"bd/dijit/currencyTextBox",
modules:
["bd/dijit/currencyTextBox"],
code:
["dojo.def(\"bd/dijit/currencyTextBox\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/CurrencyTextBox\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.currencyTextBox.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.CurrencyTextBox wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.currencyTextBox\", [",
"  dijit.form.CurrencyTextBox,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.currencyTextBox":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.CurrencyTextBox wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.CurrencyTextBox wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/currencyTextBox",
loc: [10,7,26,28],
supers:
["dijit.form.CurrencyTextBox","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/currencyTextBox"}
,"modules.bd/dijit/currencyTextBox":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.currencyTextBox."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/currencyTextBox",
loc: [0,0,28,2]}
,"resources.bd/dijit/dateTextBox":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/dateTextBox"],
src:
"bd/dijit/dateTextBox",
modules:
["bd/dijit/dateTextBox"],
code:
["dojo.def(\"bd/dijit/dateTextBox\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/DateTextBox\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.dateTextBox.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.DateTextBox wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.dateTextBox\", [",
"  dijit.form.DateTextBox,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.dateTextBox":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.DateTextBox wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.DateTextBox wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/dateTextBox",
loc: [10,7,26,28],
supers:
["dijit.form.DateTextBox","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/dateTextBox"}
,"modules.bd/dijit/dateTextBox":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.dateTextBox."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/dateTextBox",
loc: [0,0,28,2]}
,"resources.bd/dijit/dropDownButton":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/dropDownButton"],
src:
"bd/dijit/dropDownButton",
modules:
["bd/dijit/dropDownButton"],
code:
["dojo.def(\"bd/dijit/dropDownButton\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/DropDownButton\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.dropDownButton.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.DropDownButton wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.dropDownButton\", [",
"  dijit.form.DropDownButton,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.dropDownButton":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.DropDownButton wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.DropDownButton wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/dropDownButton",
loc: [10,7,26,28],
supers:
["dijit.form.DropDownButton","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/dropDownButton"}
,"modules.bd/dijit/dropDownButton":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.dropDownButton."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/dropDownButton",
loc: [0,0,28,2]}
,"resources.bd/dijit/editor":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/editor"],
src:
"bd/dijit/editor",
modules:
["bd/dijit/editor"],
code:
["dojo.def(\"bd/dijit/editor\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/Editor\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.editor.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.Editor wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.editor\", [",
"  dijit.Editor,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.editor":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.Editor wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.Editor wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/editor",
loc: [10,7,27,28],
supers:
["dijit.Editor","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/editor"}
,"modules.bd/dijit/editor":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.editor."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/editor",
loc: [0,0,29,2]}
,"resources.bd/dijit/filteringSelect":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/filteringSelect"],
src:
"bd/dijit/filteringSelect",
modules:
["bd/dijit/filteringSelect"],
code:
["dojo.def(\"bd/dijit/filteringSelect\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/FilteringSelect\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.filteringSelect.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.FilteringSelect wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.filteringSelect\", [",
"  dijit.form.FilteringSelect,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.filteringSelect":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.FilteringSelect wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.FilteringSelect wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/filteringSelect",
loc: [10,7,26,28],
supers:
["dijit.form.FilteringSelect","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/filteringSelect"}
,"modules.bd/dijit/filteringSelect":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.filteringSelect."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/filteringSelect",
loc: [0,0,28,2]}
,"resources.bd/dijit/horizontalRule":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/horizontalRule"],
src:
"bd/dijit/horizontalRule",
modules:
["bd/dijit/horizontalRule"],
code:
["dojo.def(\"bd/dijit/horizontalRule\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/HorizontalRule\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.horizontalRule.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.HorizontalRule wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.horizontalRule\", [",
"  dijit.form.HorizontalRule,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.horizontalRule":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.HorizontalRule wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.HorizontalRule wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/horizontalRule",
loc: [10,7,26,28],
supers:
["dijit.form.HorizontalRule","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/horizontalRule"}
,"modules.bd/dijit/horizontalRule":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.horizontalRule."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/horizontalRule",
loc: [0,0,28,2]}
,"resources.bd/dijit/horizontalRuleLabels":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/horizontalRuleLabels"],
src:
"bd/dijit/horizontalRuleLabels",
modules:
["bd/dijit/horizontalRuleLabels"],
code:
["dojo.def(\"bd/dijit/horizontalRuleLabels\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/HorizontalRuleLabels\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.horizontalRuleLabels.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.HorizontalRuleLabels wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.horizontalRuleLabels\", [",
"  dijit.form.HorizontalRuleLabels,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.horizontalRuleLabels":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.HorizontalRuleLabels wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.HorizontalRuleLabels wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/horizontalRuleLabels",
loc: [10,7,26,28],
supers:
["dijit.form.HorizontalRuleLabels","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/horizontalRuleLabels"}
,"modules.bd/dijit/horizontalRuleLabels":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.horizontalRuleLabels."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/horizontalRuleLabels",
loc: [0,0,28,2]}
,"resources.bd/dijit/horizontalSlider":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/horizontalSlider"],
src:
"bd/dijit/horizontalSlider",
modules:
["bd/dijit/horizontalSlider"],
code:
["dojo.def(\"bd/dijit/horizontalSlider\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/HorizontalSlider\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.horizontalSlider.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.HorizontalSlider wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.horizontalSlider\", [",
"  dijit.form.HorizontalSlider,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.horizontalSlider":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.HorizontalSlider wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.HorizontalSlider wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/horizontalSlider",
loc: [10,7,26,28],
supers:
["dijit.form.HorizontalSlider","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/horizontalSlider"}
,"modules.bd/dijit/horizontalSlider":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.horizontalSlider."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/horizontalSlider",
loc: [0,0,28,2]}
,"resources.bd/dijit/inlineEditBox":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/inlineEditBox"],
src:
"bd/dijit/inlineEditBox",
modules:
["bd/dijit/inlineEditBox"],
code:
["dojo.def(\"bd/dijit/inlineEditBox\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/InlineEditBox\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.inlineEditBox.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.InlineEditBox wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.inlineEditBox\", [",
"  dijit.InlineEditBox,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.inlineEditBox":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.InlineEditBox wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.InlineEditBox wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/inlineEditBox",
loc: [10,7,27,28],
supers:
["dijit.InlineEditBox","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/inlineEditBox"}
,"modules.bd/dijit/inlineEditBox":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.inlineEditBox."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/inlineEditBox",
loc: [0,0,29,2]}
,"resources.bd/dijit/layoutContainer":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/layoutContainer"],
src:
"bd/dijit/layoutContainer",
modules:
["bd/dijit/layoutContainer"],
code:
["dojo.def(\"bd/dijit/layoutContainer\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/LayoutContainer\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.layoutContainer.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.LayoutContainer wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.layoutContainer\", [",
"  dijit.LayoutContainer,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.layoutContainer":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.LayoutContainer wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.LayoutContainer wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/layoutContainer",
loc: [10,7,27,28],
supers:
["dijit.LayoutContainer","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/layoutContainer"}
,"modules.bd/dijit/layoutContainer":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.layoutContainer."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/layoutContainer",
loc: [0,0,29,2]}
,"resources.bd/dijit/linkPane":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/linkPane"],
src:
"bd/dijit/linkPane",
modules:
["bd/dijit/linkPane"],
code:
["dojo.def(\"bd/dijit/linkPane\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/LinkPane\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.linkPane.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.LinkPane wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.linkPane\", [",
"  dijit.LinkPane,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.linkPane":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.LinkPane wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.LinkPane wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/linkPane",
loc: [10,7,27,28],
supers:
["dijit.LinkPane","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/linkPane"}
,"modules.bd/dijit/linkPane":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.linkPane."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/linkPane",
loc: [0,0,29,2]}
,"resources.bd/dijit/mappedTextBox":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/mappedTextBox"],
src:
"bd/dijit/mappedTextBox",
modules:
["bd/dijit/mappedTextBox"],
code:
["dojo.def(\"bd/dijit/mappedTextBox\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/MappedTextBox\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.mappedTextBox.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.MappedTextBox wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.mappedTextBox\", [",
"  dijit.form.MappedTextBox,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.mappedTextBox":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.MappedTextBox wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.MappedTextBox wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/mappedTextBox",
loc: [10,7,26,28],
supers:
["dijit.form.MappedTextBox","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/mappedTextBox"}
,"modules.bd/dijit/mappedTextBox":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.mappedTextBox."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/mappedTextBox",
loc: [0,0,28,2]}
,"resources.bd/dijit/multiSelect":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/multiSelect"],
src:
"bd/dijit/multiSelect",
modules:
["bd/dijit/multiSelect"],
code:
["dojo.def(\"bd/dijit/multiSelect\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/MultiSelect\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.multiSelect.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.MultiSelect wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.multiSelect\", [",
"  dijit.form.MultiSelect,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.multiSelect":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.MultiSelect wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.MultiSelect wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/multiSelect",
loc: [10,7,26,28],
supers:
["dijit.form.MultiSelect","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/multiSelect"}
,"modules.bd/dijit/multiSelect":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.multiSelect."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/multiSelect",
loc: [0,0,28,2]}
,"resources.bd/dijit/numberSpinner":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/numberSpinner"],
src:
"bd/dijit/numberSpinner",
modules:
["bd/dijit/numberSpinner"],
code:
["dojo.def(\"bd/dijit/numberSpinner\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/NumberSpinner\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.numberSpinner.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.NumberSpinner wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.numberSpinner\", [",
"  dijit.form.NumberSpinner,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.numberSpinner":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.NumberSpinner wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.NumberSpinner wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/numberSpinner",
loc: [10,7,26,28],
supers:
["dijit.form.NumberSpinner","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/numberSpinner"}
,"modules.bd/dijit/numberSpinner":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.numberSpinner."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/numberSpinner",
loc: [0,0,28,2]}
,"resources.bd/dijit/numberTextBox":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/numberTextBox"],
src:
"bd/dijit/numberTextBox",
modules:
["bd/dijit/numberTextBox"],
code:
["dojo.def(\"bd/dijit/numberTextBox\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/NumberTextBox\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.numberTextBox.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.NumberTextBox wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.numberTextBox\", [",
"  dijit.form.NumberTextBox,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.numberTextBox":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.NumberTextBox wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.NumberTextBox wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/numberTextBox",
loc: [10,7,26,28],
supers:
["dijit.form.NumberTextBox","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/numberTextBox"}
,"modules.bd/dijit/numberTextBox":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.numberTextBox."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/numberTextBox",
loc: [0,0,28,2]}
,"resources.bd/dijit/progressBar":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/progressBar"],
src:
"bd/dijit/progressBar",
modules:
["bd/dijit/progressBar"],
code:
["dojo.def(\"bd/dijit/progressBar\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/ProgressBar\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.progressBar.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.ProgressBar wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.progressBar\", [",
"  dijit.ProgressBar,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.progressBar":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.ProgressBar wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.ProgressBar wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/progressBar",
loc: [10,7,27,28],
supers:
["dijit.ProgressBar","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/progressBar"}
,"modules.bd/dijit/progressBar":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.progressBar."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/progressBar",
loc: [0,0,29,2]}
,"resources.bd/dijit/radioButton":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/radioButton"],
src:
"bd/dijit/radioButton",
modules:
["bd/dijit/radioButton"],
code:
["dojo.def(\"bd/dijit/radioButton\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/RadioButton\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.radioButton.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.RadioButton wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.radioButton\", [",
"  dijit.form.RadioButton,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.radioButton":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.RadioButton wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.RadioButton wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/radioButton",
loc: [10,7,26,28],
supers:
["dijit.form.RadioButton","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/radioButton"}
,"modules.bd/dijit/radioButton":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.radioButton."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/radioButton",
loc: [0,0,28,2]}
,"resources.bd/dijit/rangeBoundTextBox":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/rangeBoundTextBox"],
src:
"bd/dijit/rangeBoundTextBox",
modules:
["bd/dijit/rangeBoundTextBox"],
code:
["dojo.def(\"bd/dijit/rangeBoundTextBox\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/RangeBoundTextBox\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.rangeBoundTextBox.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.RangeBoundTextBox wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.rangeBoundTextBox\", [",
"  dijit.form.RangeBoundTextBox,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.rangeBoundTextBox":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.RangeBoundTextBox wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.RangeBoundTextBox wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/rangeBoundTextBox",
loc: [10,7,26,28],
supers:
["dijit.form.RangeBoundTextBox","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/rangeBoundTextBox"}
,"modules.bd/dijit/rangeBoundTextBox":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.rangeBoundTextBox."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/rangeBoundTextBox",
loc: [0,0,28,2]}
,"resources.bd/dijit/scrollingTabController":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/scrollingTabController"],
src:
"bd/dijit/scrollingTabController",
modules:
["bd/dijit/scrollingTabController"],
code:
["dojo.def(\"bd/dijit/scrollingTabController\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/ScrollingTabController\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.scrollingTabController.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.ScrollingTabController wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.scrollingTabController\", [",
"  dijit.ScrollingTabController,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.scrollingTabController":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.ScrollingTabController wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.ScrollingTabController wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/scrollingTabController",
loc: [10,7,27,28],
supers:
["dijit.ScrollingTabController","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/scrollingTabController"}
,"modules.bd/dijit/scrollingTabController":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.scrollingTabController."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/scrollingTabController",
loc: [0,0,29,2]}
,"resources.bd/dijit/select":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/select"],
src:
"bd/dijit/select",
modules:
["bd/dijit/select"],
code:
["dojo.def(\"bd/dijit/select\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/Select\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.select.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.Select wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.select\", [",
"  dijit.form.Select,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.select":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.Select wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.Select wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/select",
loc: [10,7,26,28],
supers:
["dijit.form.Select","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/select"}
,"modules.bd/dijit/select":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.select."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/select",
loc: [0,0,28,2]}
,"resources.bd/dijit/simpleTextArea":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/simpleTextArea"],
src:
"bd/dijit/simpleTextArea",
modules:
["bd/dijit/simpleTextArea"],
code:
["dojo.def(\"bd/dijit/simpleTextArea\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/SimpleTextarea\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.simpleTextArea.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.SimpleTextarea wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.simpleTextArea\", [",
"  dijit.form.SimpleTextarea,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.simpleTextArea":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.SimpleTextarea wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.SimpleTextarea wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/simpleTextArea",
loc: [10,7,26,28],
supers:
["dijit.form.SimpleTextarea","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/simpleTextArea"}
,"modules.bd/dijit/simpleTextArea":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.simpleTextArea."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/simpleTextArea",
loc: [0,0,28,2]}
,"resources.bd/dijit/stackContainer":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/stackContainer"],
src:
"bd/dijit/stackContainer",
modules:
["bd/dijit/stackContainer"],
code:
["dojo.def(\"bd/dijit/stackContainer\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/StackContainer\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.stackContainer.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.StackContainer wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.stackContainer\", [",
"  dijit.StackContainer,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.stackContainer":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.StackContainer wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.StackContainer wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/stackContainer",
loc: [10,7,27,28],
supers:
["dijit.StackContainer","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/stackContainer"}
,"modules.bd/dijit/stackContainer":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.stackContainer."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/stackContainer",
loc: [0,0,29,2]}
,"resources.bd/dijit/stackController":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/stackController"],
src:
"bd/dijit/stackController",
modules:
["bd/dijit/stackController"],
code:
["dojo.def(\"bd/dijit/stackController\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/StackController\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.stackController.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.StackController wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.stackController\", [",
"  dijit.StackController,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.stackController":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.StackController wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.StackController wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/stackController",
loc: [10,7,27,28],
supers:
["dijit.StackController","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/stackController"}
,"modules.bd/dijit/stackController":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.stackController."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/stackController",
loc: [0,0,29,2]}
,"resources.bd/dijit/tabContainer":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/tabContainer"],
src:
"bd/dijit/tabContainer",
modules:
["bd/dijit/tabContainer"],
code:
["dojo.def(\"bd/dijit/tabContainer\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/TabContainer\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.tabContainer.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.TabContainer wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.tabContainer\", [",
"  dijit.TabContainer,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.tabContainer":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.TabContainer wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.TabContainer wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/tabContainer",
loc: [10,7,27,28],
supers:
["dijit.TabContainer","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/tabContainer"}
,"modules.bd/dijit/tabContainer":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.tabContainer."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/tabContainer",
loc: [0,0,29,2]}
,"resources.bd/dijit/tabController":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/tabController"],
src:
"bd/dijit/tabController",
modules:
["bd/dijit/tabController"],
code:
["dojo.def(\"bd/dijit/tabController\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/TabController\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.tabController.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.TabController wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.tabController\", [",
"  dijit.TabController,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.tabController":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.TabController wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.TabController wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/tabController",
loc: [10,7,27,28],
supers:
["dijit.TabController","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/tabController"}
,"modules.bd/dijit/tabController":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.tabController."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/tabController",
loc: [0,0,29,2]}
,"resources.bd/dijit/textArea":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/textArea"],
src:
"bd/dijit/textArea",
modules:
["bd/dijit/textArea"],
code:
["dojo.def(\"bd/dijit/textArea\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/Textarea\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.textArea.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.Textarea wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.textArea\", [",
"  dijit.form.Textarea,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.textArea":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.Textarea wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.Textarea wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/textArea",
loc: [10,7,26,28],
supers:
["dijit.form.Textarea","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/textArea"}
,"modules.bd/dijit/textArea":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.textArea."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/textArea",
loc: [0,0,28,2]}
,"resources.bd/dijit/textBox":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/textBox"],
src:
"bd/dijit/textBox",
modules:
["bd/dijit/textBox"],
code:
["dojo.def(\"bd/dijit/textBox\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/TextBox\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.textBox.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.TextBox wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.textBox\", [",
"  dijit.form.TextBox,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.textBox":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.TextBox wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.TextBox wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/textBox",
loc: [10,7,26,28],
supers:
["dijit.form.TextBox","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/textBox"}
,"modules.bd/dijit/textBox":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.textBox."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/textBox",
loc: [0,0,28,2]}
,"resources.bd/dijit/timeTextBox":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/timeTextBox"],
src:
"bd/dijit/timeTextBox",
modules:
["bd/dijit/timeTextBox"],
code:
["dojo.def(\"bd/dijit/timeTextBox\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/TimeTextBox\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.timeTextBox.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.TimeTextBox wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.timeTextBox\", [",
"  dijit.form.TimeTextBox,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.timeTextBox":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.TimeTextBox wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.TimeTextBox wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/timeTextBox",
loc: [10,7,26,28],
supers:
["dijit.form.TimeTextBox","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/timeTextBox"}
,"modules.bd/dijit/timeTextBox":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.timeTextBox."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/timeTextBox",
loc: [0,0,28,2]}
,"resources.bd/dijit/titlePane":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/titlePane"],
src:
"bd/dijit/titlePane",
modules:
["bd/dijit/titlePane"],
code:
["dojo.def(\"bd/dijit/titlePane\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/TitlePane\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.titlePane.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.TitlePane wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.titlePane\", [",
"  dijit.TitlePane,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.titlePane":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.TitlePane wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.TitlePane wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/titlePane",
loc: [10,7,27,28],
supers:
["dijit.TitlePane","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/titlePane"}
,"modules.bd/dijit/titlePane":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.titlePane."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/titlePane",
loc: [0,0,29,2]}
,"resources.bd/dijit/toggleButton":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/toggleButton"],
src:
"bd/dijit/toggleButton",
modules:
["bd/dijit/toggleButton"],
code:
["dojo.def(\"bd/dijit/toggleButton\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/ToggleButton\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.toggleButton.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.ToggleButton wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.toggleButton\", [",
"  dijit.form.ToggleButton,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.toggleButton":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.ToggleButton wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.ToggleButton wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/toggleButton",
loc: [10,7,26,28],
supers:
["dijit.form.ToggleButton","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/toggleButton"}
,"modules.bd/dijit/toggleButton":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.toggleButton."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/toggleButton",
loc: [0,0,28,2]}
,"resources.bd/dijit/toolbar":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/toolbar"],
src:
"bd/dijit/toolbar",
modules:
["bd/dijit/toolbar"],
code:
["dojo.def(\"bd/dijit/toolbar\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/Toolbar\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.toolbar.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.Toolbar wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.toolbar\", [",
"  dijit.Toolbar,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.toolbar":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.Toolbar wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.Toolbar wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/toolbar",
loc: [10,7,27,28],
supers:
["dijit.Toolbar","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/toolbar"}
,"modules.bd/dijit/toolbar":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.toolbar."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/toolbar",
loc: [0,0,29,2]}
,"resources.bd/dijit/toolbarSeparator":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/toolbarSeparator"],
src:
"bd/dijit/toolbarSeparator",
modules:
["bd/dijit/toolbarSeparator"],
code:
["dojo.def(\"bd/dijit/toolbarSeparator\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/ToolbarSeparator\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.toolbarSeparator.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.ToolbarSeparator wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.toolbarSeparator\", [",
"  dijit.ToolbarSeparator,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.toolbarSeparator":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.ToolbarSeparator wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.ToolbarSeparator wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/toolbarSeparator",
loc: [10,7,27,28],
supers:
["dijit.ToolbarSeparator","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/toolbarSeparator"}
,"modules.bd/dijit/toolbarSeparator":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.toolbarSeparator."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/toolbarSeparator",
loc: [0,0,29,2]}
,"resources.bd/dijit/tooltip":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/tooltip"],
src:
"bd/dijit/tooltip",
modules:
["bd/dijit/tooltip"],
code:
["dojo.def(\"bd/dijit/tooltip\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/Tooltip\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.tooltip.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.Tooltip wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.tooltip\", [",
"  dijit.Tooltip,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.tooltip":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.Tooltip wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.Tooltip wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/tooltip",
loc: [10,7,27,28],
supers:
["dijit.Tooltip","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/tooltip"}
,"modules.bd/dijit/tooltip":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.tooltip."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/tooltip",
loc: [0,0,29,2]}
,"resources.bd/dijit/tree":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/tree"],
src:
"bd/dijit/tree",
modules:
["bd/dijit/tree"],
code:
["dojo.def(\"bd/dijit/tree\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/Tree\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.tree.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.Tree wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.tree\", [",
"  dijit.Tree,",
"  bd.containable,",
"  bd.dijit.disabled,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.tree":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.Tree wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.Tree wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/tree",
loc: [10,7,27,28],
supers:
["dijit.Tree","bd.containable","bd.dijit.disabled","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/tree"}
,"modules.bd/dijit/tree":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.tree."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/tree",
loc: [0,0,29,2]}
,"resources.bd/dijit/validationTextBox":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/validationTextBox"],
src:
"bd/dijit/validationTextBox",
modules:
["bd/dijit/validationTextBox"],
code:
["dojo.def(\"bd/dijit/validationTextBox\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/ValidationTextBox\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.validationTextBox.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.ValidationTextBox wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.validationTextBox\", [",
"  dijit.form.ValidationTextBox,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.validationTextBox":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.ValidationTextBox wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.ValidationTextBox wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/validationTextBox",
loc: [10,7,26,28],
supers:
["dijit.form.ValidationTextBox","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/validationTextBox"}
,"modules.bd/dijit/validationTextBox":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.validationTextBox."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/validationTextBox",
loc: [0,0,28,2]}
,"resources.bd/dijit/verticalRule":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/verticalRule"],
src:
"bd/dijit/verticalRule",
modules:
["bd/dijit/verticalRule"],
code:
["dojo.def(\"bd/dijit/verticalRule\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/VerticalRule\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.verticalRule.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.VerticalRule wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.verticalRule\", [",
"  dijit.form.VerticalRule,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.verticalRule":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.VerticalRule wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.VerticalRule wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/verticalRule",
loc: [10,7,26,28],
supers:
["dijit.form.VerticalRule","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/verticalRule"}
,"modules.bd/dijit/verticalRule":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.verticalRule."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/verticalRule",
loc: [0,0,28,2]}
,"resources.bd/dijit/verticalRuleLabels":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/verticalRuleLabels"],
src:
"bd/dijit/verticalRuleLabels",
modules:
["bd/dijit/verticalRuleLabels"],
code:
["dojo.def(\"bd/dijit/verticalRuleLabels\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compaty\",",
"  \"dijit/form/VerticalRuleLabels\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.verticalRuleLabels.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.VerticalRuleLabels wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.verticalRuleLabels\", [",
"  dijit.form.VerticalRuleLabels,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.verticalRuleLabels":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.VerticalRuleLabels wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.VerticalRuleLabels wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/verticalRuleLabels",
loc: [10,7,26,28],
supers:
["dijit.form.VerticalRuleLabels","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/verticalRuleLabels"}
,"modules.bd/dijit/verticalRuleLabels":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.verticalRuleLabels."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/verticalRuleLabels",
loc: [0,0,28,2]}
,"resources.bd/dijit/verticalSlider":{
type:
Tresource,
sdoc:
["Defines the module bd/dijit/verticalSlider"],
src:
"bd/dijit/verticalSlider",
modules:
["bd/dijit/verticalSlider"],
code:
["dojo.def(\"bd/dijit/verticalSlider\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/form/VerticalSlider\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.dijit.verticalSlider.",
"",
"return bd.declare(",
"  ///",
"  // Dojo\'s dijit.form.VerticalSlider wrapped for use with the Backdraft framework. //Includes the following features:",
"  // ",
"  // * A constructor compatible with bd.createWidget.",
"  // * A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.",
"  // * A `visible` attribute that shows/hides the widget.",
"  // * A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.",
"  // * The bd.containable mixin.",
"  // ",
"  // All of these features are implemented uniformily through several mixin classes.",
"  \"bd:dijit.verticalSlider\", [",
"  dijit.form.VerticalSlider,",
"  bd.containable,",
"  bd.dijit.visible,",
"  bd.dijit.focusable,",
"  bd.dijit.constructor], {});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.dijit.verticalSlider":{
type:
Tclass,
sdoc:
["Dojo\'s dijit.form.VerticalSlider wrapped for use with the Backdraft framework. "],
ldoc:
["Dojo\'s dijit.form.VerticalSlider wrapped for use with the Backdraft framework. Includes the following features:\n\n* A constructor compatible with bd.createWidget.\n* A `disabled` attribute that prevents all user interaction is true and has no effect otherwise.\n* A `visible` attribute that shows/hides the widget.\n* A `focusable` attribute that computes the whether or not the widget can receive the focus based in enabled/visible status.\n* The bd.containable mixin.\n\nAll of these features are implemented uniformily through several mixin classes."],
src:
"bd/dijit/verticalSlider",
loc: [10,7,26,28],
supers:
["dijit.form.VerticalSlider","bd.containable","bd.dijit.visible","bd.dijit.focusable","bd.dijit.constructor"],
module:"bd/dijit/verticalSlider"}
,"modules.bd/dijit/verticalSlider":{
type:
Tmodule,
sdoc:
["Defines the class bd.dijit.verticalSlider."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/dijit/verticalSlider",
loc: [0,0,28,2]}
,"resources.bd/dom":{
type:
Tresource,
sdoc:
["Defines the module bd/dom"],
src:
"bd/dom",
modules:
["bd/dom"],
code:
["dojo.def(\"bd/dom\", [",
"  \"dojo\", \"bd\"",
"], function(dojo, bd) {",
"///",
"// Augments the bd namespace with DOM-related convenience functions.",
"",
"bd.isDomNode= function(",
"  node ///(any) The object to test.",
") {",
"  ///",
"  // Tests node to see if it is a DOM node. //",
"  //return",
"  //(true) node is a DOM node.",
"  //(false) node is not a DOM node.",
"  ///",
"  return !!(node && (node.addEventListener || node.attachEvent));",
"};",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.isDomNode":{
type:
Tfunction,
sdoc:
["Tests node to see if it is a DOM node. "],
ldoc:
["Tests node to see if it is a DOM node. "],
params:
[["node",[["any",
["The object to test."]]]]],
returns:
[["true",
["node is a DOM node."]],
["false",
["node is not a DOM node."]]],
src:
"bd/dom",
loc: [6,0,16,1],
module:"bd/dom"}
,"modules.bd/dom":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with DOM-related convenience functions."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/dom",
loc: [0,0,18,2]}
,"resources.bd/equal":{
type:
Tresource,
sdoc:
["Defines the module bd/equal"],
src:
"bd/equal",
modules:
["bd/equal"],
code:
["dojo.def(\"bd/equal\", [\"bd/kernel\", \"dojo\", \"bd/hash\"], function(bd, dojo) {",
"///",
"// Defines the function bd.equal.",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load the module bd. See module.bd.",
"",
"bd.equal= function(",
"  lhs,     ///(any) The left-hand-side object",
"  rhs,     ///(any) The right-hand-side object",
"  watchdog ///(integer, optional, 10) The maximum nesting depth of structures before a circular structure is assumed.",
") {",
"  ///",
"  // Compute if lhs has the same type and value as rhs. //Works correctly with numbers, ",
"  // strings, booleans, null, Dates, Errors, RegExps, as well as arrays of and objects containing these types, ",
"  // including most objects created by a constructor function. Specialized objects (for example, objects who\'s",
"  // value is influenced by the result of executing a function) can be accommodated by adding to the bd.equal.comparators hash.",
"",
"  if (lhs===rhs) {",
"    return true;",
"  }",
"",
"  if ((lhs===null && rhs!==null) || (rhs===null && lhs!==null)) {",
"    return false;",
"  }",
"",
"  if (typeof lhs !== \"object\" || typeof rhs !== \"object\") {",
"    return false;",
"  }",
"",
"  if (lhs.constructor!==rhs.constructor) {",
"    return false;",
"  }",
"",
"  if (watchdog===0) {",
"    //TODO: warn or exception?",
"    return true;",
"  }",
"",
"  if (!watchdog) {",
"    watchdog= 10;",
"  }",
"",
"  var comp= bd.equal.comparators.get(lhs.constructor);",
"  if (comp!==bd.notFound) {",
"    return comp(lhs, rhs, watchdog);",
"  }",
"",
"  var count= 0;",
"  for (var p in lhs) {",
"    count++;",
"  }",
"  for (p in rhs) {",
"    if (--count<0 || !bd.equal(lhs[p], rhs[p], watchdog-1)) {",
"      return false;",
"    }",
"  }",
"  return count===0;",
"};",
"",
"bd.equal.comparators=",
"  ///",
"  // An instance of bd.hash that gives a map from constructor function to compare function for use with bd.equal. //",
"  // The compare function must take two arguments and return true if the arguments are equal",
"  // by value, false otherwise.",
"  //",
"  // bd.equal.comparators is initialized to handle Arrays, Dates, Errors, and RegExps. Client",
"  // code can augment the hash to handle other, client-defined types.",
"  (new bd.hash()).",
"    set(Array, function(lhs, rhs, watchdog) {",
"        if (lhs.length!=rhs.length) {",
"          return false;",
"        }",
"        for (var i= 0, end= lhs.length; i<end; i++) {",
"          if (!bd.equal(lhs[i], rhs[i], watchdog-1)){",
"              return false;",
"          }",
"        }",
"        return true;",
"      }).",
"    set(Date, function(lhs, rhs) {",
"        return lhs.valueOf()==rhs.valueOf();",
"      }).",
"    set(Error, function(lhs, rhs) {",
"        return lhs.message==rhs.message;",
"      }).",
"    set(RegExp, function(lhs, rhs) {",
"        return lhs.source===rhs.source && lhs.global===rhs.global && lhs.ignoreCase===rhs.ignoreCase && lhs.multiline===rhs.multiline;",
"      }",
"    );",
"",
"bd.equivP= function(",
"  target ///(any) The reference target.",
") {",
"  ///",
"  // Returns a function that takes a single argument, `test`, and returns `target===test`.",
"  return function(test) {",
"    return test===target;",
"  };",
"};",
"",
"bd.equalP= function(",
"  target,  ///(any) The reference target.",
"  watchdog ///(integer, optional, 10) The maximum nesting depth of structures before a circular structure is assumed.",
") {",
"  ///",
"  // Returns a function that takes a single argument, `test`, and returns `bd.equal(target, test, watchdog)`.",
"  watchdog= watchdog || 10;",
"  var equal= bd.equal;",
"  return function(test) {",
"    return equal(target, test, watchdog);",
"  };",
"};",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.equal":{
type:
Tfunction,
sdoc:
["Compute if lhs has the same type and value as rhs. "],
ldoc:
["Compute if lhs has the same type and value as rhs. Works correctly with numbers,\nstrings, booleans, null, Dates, Errors, RegExps, as well as arrays of and objects containing these types,\nincluding most objects created by a constructor function. Specialized objects (for example, objects who\'s\nvalue is influenced by the result of executing a function) can be accommodated by adding to the bd.equal.comparators hash."],
params:
[["lhs",[["any",
["The left-hand-side object"]]]],
["rhs",[["any",
["The right-hand-side object"]]]],
["watchdog",[["integer, optional, 10",
["The maximum nesting depth of structures before a circular structure is assumed."]]]]],
src:
"bd/equal",
loc: [7,0,58,1],
module:"bd/equal"}
,"bd.equal.comparators":{
type:
Tvariable,
sdoc:
["An instance of bd.hash that gives a map from constructor function to compare function for use with bd.equal. "],
ldoc:
["An instance of bd.hash that gives a map from constructor function to compare function for use with bd.equal. \nThe compare function must take two arguments and return true if the arguments are equal\nby value, false otherwise.\n\nbd.equal.comparators is initialized to handle Arrays, Dates, Errors, and RegExps. Client\ncode can augment the hash to handle other, client-defined types."],
src:
"bd/equal",
loc: [60,0,89,5],
module:"bd/equal"}
,"bd.equivP":{
type:
Tfunction,
sdoc:
["Returns a function that takes a single argument, `test`, and returns `target===test`."],
ldoc:
[],
params:
[["target",[["any",
["The reference target."]]]]],
src:
"bd/equal",
loc: [91,0,99,1],
module:"bd/equal"}
,"bd.equalP":{
type:
Tfunction,
sdoc:
["Returns a function that takes a single argument, `test`, and returns `bd.equal(target, test, watchdog)`."],
ldoc:
[],
params:
[["target",[["any",
["The reference target."]]]],
["watchdog",[["integer, optional, 10",
["The maximum nesting depth of structures before a circular structure is assumed."]]]]],
src:
"bd/equal",
loc: [101,0,112,1],
module:"bd/equal"}
,"modules.bd/equal":{
type:
Tmodule,
sdoc:
["Defines the function bd.equal."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load the module bd. See module.bd."]],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/equal",
loc: [0,0,114,2]}
,"resources.bd/focusable":{
type:
Tresource,
sdoc:
["Defines the module bd/focusable"],
src:
"bd/focusable",
modules:
["bd/focusable"],
code:
["dojo.def(\"bd/focusable\", [",
"  \"bd\", ",
"  \"dojo\",",
"  \"bd/interactive\",",
"  \"bd/async\", ",
"  \"dojo/window\"",
"], function(bd, dojo) {",
"///",
"// Defines the bd.focusable class.",
"",
"bd.declare(",
"  ///",
"  // Mixin class for objects (widgets) that interact with the keyboard. //Provides",
"  // machinery to track, inspect, watch, and set the focus and a getter/setter for",
"  // the DOM tabIndex attribute.",
"",
"  //class name",
"  \"bd:focusable\",",
"",
"  //superclasses",
"  [bd.interactive],",
"",
"  //members",
"  bd.attr(",
"    ///",
"    //(integer) The DOM `tabIndex` attribute.",
"    //(undefined) Remove the DOM `tabIndex` attribute from the target node.",
"    ///",
"    // The DOM `tabIndex` attribute (integer or undefined) for this DOM subtree. //The ",
"    // target node is given by `this.focusNode` or `this.domNode`. If",
"    // `tabIndex` is falsy but not zero, then the tabIndex attribute is removed from",
"    // the target node; otherwise, tabIndex must be an integer, and the tabIndex attribute of",
"    // the target node is set accordingly.",
"",
"    \"tabIndex\",",
"",
"    -1, //initial value",
"",
"    function(value) { //setter",
"      var oldValue= this.tabIndex;",
"      //tabIndex is either an integer or falsy...",
"      this.tabIndex= value= (value===0 ? 0 : ((!value || isNaN(value)) ? undefined : Number(value)));",
"      var node= this.focusNode || this.domNode;",
"      if (node && !this.get(\"disabled\")) {",
"        if (value===undefined) {",
"          node.removeAttribute(\"tabIndex\");",
"        } else {",
"          node.setAttribute(\"tabIndex\", value);",
"        }",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    //(boolean) true if the widget is disabled; false otherwise.",
"    ///",
"    // Overrides the bd.interactive.disabled setter.  //Includes additional functionality to add/removed the tabIndex",
"    // attribute to/from the focus node upon entering the enabled/disabled state. Further, if the instance is",
"    // currently focused and the diabled attribute set true, then the onFocus connection",
"    // point of the parent is signaled (typically, parents should adjust the focus).",
"    \"disabled\",",
"  ",
"    bd.noValue, //use the default given by bd.interactive",
"",
"    function(value) { //setter",
"      var oldValue= this.inherited(arguments);",
"      if (value && !oldValue) {",
"        //going from !disabled to disabled",
"        var node= this.focusNode || this.domNode;",
"        node && node.removeAttribute(\"tabIndex\");",
"        this.focused && this.parent.focus();",
"      } else if (!value && oldValue) {",
"        this.set(\"tabIndex\", this.get(\"tabIndex\"));",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.constAttr(",
"    ///",
"    //(boolean) true if this widget can receive the focus; false otherwise. ",
"    ///",
"    // Indicates whether or not this object can recieve the focus.",
"    ///",
"    // The default calculation requires the object must be visible, not disabled, and have a tabIndex value defined",
"    // in order to receive the focus.",
"",
"    \"focusable\", ",
"",
"    bd.noValue, // The value is always calculated, never stored.",
"",
"    function() { //getter",
"      return this.tabIndex!==undefined && this.get(\"visible\") && !this.get(\"disabled\");",
"    }",
"  ),",
"",
"  bd.makeDeferredConnects(",
"    ///",
"    // Declares connection points.",
"    {",
"    onKeyDown:[\"keydown\", \"domNode\"],",
"    onKeyPress:[\"keypress\", \"domNode\"],",
"    onKeyUp:[\"keyup\", \"domNode\"]",
"  }),  ",
"",
"  {",
"    focus: function() {",
"      ///",
"      // Sets the focus to this widget iff `this.get(\"focusable\")` returns true.",
"      //warn",
"      // Focus is set asynchronously. This ensures focus will be set correctly under all circumstances",
"      // (e.g., from a blur event handler); however, the focus will not have moved before this",
"      // function returns.",
"      if (this.focusableGet()) {",
"        var node= this.focusNode || this.domNode;",
"        if (node) {",
"          dojo.window.scrollIntoView(node);",
"          bd.async.setFocus(node);",
"        }",
"      }",
"    },",
"",
"    onFocus: function(by) {",
"      // Connection for called when this DOM subtree gets the focus as triggered by the dijit focus manager.",
"      // `connectionPoint",
"      if (!this.focusableGet()) {",
"        //should never get here; ping the parent in hopes that it will take our focus away",
"        this.parent.focus();",
"      }",
"    },",
"",
"    onBlur: function(by) {",
"      // Connection for called when this DOM subtree loses the focus as triggered by the dijit focus manager.",
"      // `connectionPoint",
"    },",
"",
"    onKeydown: function(e) {",
"      // Connection point for DOM keydown event on `this.domNode`.",
"      // `connectionPoint",
"    },",
"",
"    onKeypress: function(e) {",
"      // Connection point for DOM keypress event on `this.domNode`.",
"      // `connectionPoint",
"    },",
"",
"    onKeyup: function(e) {",
"      // Connection point for DOM keyup event on `this.domNode`.",
"      // `connectionPoint",
"    },",
"",
"    _onFocus: function(",
"      by ///(\"mouse\" or undefined) Says what caused dijit focus manager to pass message.",
"    ) {",
"      ///",
"      // Watches the dijit focus manager; triggers the onFocus connection point.",
"      // `private",
"      if (!this.focused) {",
"        this.focused= true;",
"        this.adviseWatchers && this.adviseWatchers(\"focused\", false, true);",
"        this.onFocus(by);",
"      }",
"    },",
"",
"    _onBlur: function(",
"      by ///(\"mouse\" or undefined) Says what caused dijit focus manager to pass message.",
"    ) {",
"      ///",
"      // Watches the dijit focus manager; triggers the onBlur connection point.",
"      // `private",
"      if (this.focused) {",
"        this.focused= false;",
"        this.adviseWatchers && this.adviseWatchers(\"focused\", true, false);",
"        this.onBlur(by);",
"      }",
"    }",
"  }",
");",
"",
"});",
""]}
,"bd.focusable":{
type:
Tclass,
sdoc:
["Mixin class for objects (widgets) that interact with the keyboard. "],
ldoc:
["Mixin class for objects (widgets) that interact with the keyboard. Provides\nmachinery to track, inspect, watch, and set the focus and a getter/setter for\nthe DOM tabIndex attribute."],
src:
"bd/focusable",
loc: [10,0,179,1],
supers:
["bd.interactive"],
module:"bd/focusable"}
,"bd.focusable.deferredConnects":{
type:
Tvariable,
sdoc:
["Declares connection points."],
imember:1,
ldoc:
[],
loc: [98,2,105,4]}
,"bd.focusable.focusable":{
type:
Tvariable,
sdoc:
["Indicates whether or not this object can recieve the focus."],
imember:1,
ldoc:
["The default calculation requires the object must be visible, not disabled, and have a tabIndex value defined\nin order to receive the focus."],
flags:
[Froattr],
loc: [80,2,96,3],
types:
[["boolean",
["true if this widget can receive the focus; false otherwise."]]]}
,"bd.focusable.disabled":{
type:
Tvariable,
sdoc:
["Overrides the bd.interactive.disabled setter.  "],
imember:1,
ldoc:
["Overrides the bd.interactive.disabled setter.  Includes additional functionality to add/removed the tabIndex\nattribute to/from the focus node upon entering the enabled/disabled state. Further, if the instance is\ncurrently focused and the diabled attribute set true, then the onFocus connection\npoint of the parent is signaled (typically, parents should adjust the focus)."],
flags:
[Fattr],
loc: [54,2,78,3],
types:
[["boolean",
["true if the widget is disabled; false otherwise."]]]}
,"bd.focusable.tabIndex":{
type:
Tvariable,
sdoc:
["The DOM `tabIndex` attribute (integer or undefined) for this DOM subtree. "],
imember:1,
ldoc:
["The DOM `tabIndex` attribute (integer or undefined) for this DOM subtree. The\ntarget node is given by `this.focusNode` or `this.domNode`. If\n`tabIndex` is falsy but not zero, then the tabIndex attribute is removed from\nthe target node; otherwise, tabIndex must be an integer, and the tabIndex attribute of\nthe target node is set accordingly."],
flags:
[Fattr],
loc: [23,2,52,3],
types:
[["integer",
["The DOM `tabIndex` attribute."]],
["undefined",
["Remove the DOM `tabIndex` attribute from the target node."]]]}
,"bd.focusable.focus":{
type:
Tfunction,
sdoc:
["Sets the focus to this widget iff `this.get(\"focusable\")` returns true."],
imember:1,
ldoc:
[[WARN,"Focus is set asynchronously. This ensures focus will be set correctly under all circumstances\n(e.g., from a blur event handler); however, the focus will not have moved before this\nfunction returns."]],
loc: [108,4,122,5]}
,"bd.focusable._onFocus":{
type:
Tfunction,
sdoc:
["Watches the dijit focus manager; triggers the onFocus connection point."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
params:
[["by",[["\"mouse\" or undefined",
["Says what caused dijit focus manager to pass message."]]]]],
loc: [153,4,164,5]}
,"bd.focusable._onBlur":{
type:
Tfunction,
sdoc:
["Watches the dijit focus manager; triggers the onBlur connection point."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
params:
[["by",[["\"mouse\" or undefined",
["Says what caused dijit focus manager to pass message."]]]]],
loc: [166,4,177,5]}
,"modules.bd/focusable":{
type:
Tmodule,
sdoc:
["Defines the bd.focusable class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/focusable",
loc: [0,0,181,2]}
,"resources.bd/frenzy":{
type:
Tresource,
sdoc:
["Defines the module bd/frenzy"],
src:
"bd/frenzy",
modules:
["bd/frenzy"],
docLocs:
[[299,413]],
code:
["dojo.def(\"bd/frenzy\", [",
"  \"dojo\", \"bd\"",
"], function(dojo, bd) {",
"///",
"// Augments the bd namespace with the bd.frenzy class.",
"",
"//TODO improve documentation.",
"",
"bd.declare(",
"  ///",
"  // Implements a proxy to a Frenzy service.",
"",
"  //class name",
"  \"bd:frenzyProxy\", ",
"",
"  //superclasses",
"  [], ",
"",
"  //members",
"  {",
"  maxLiveTransactions:",
"    ///",
"    // The maximum number of concurrent requests than may be issued to the server. (integer)",
"    2,",
"",
"  delay:",
"    /// ",
"    // Milliseconds to wait before sending a queued request to the server. (integer)",
"    // `note Changes to this attribute will not take place until the next scheduled transaction with the server.",
"    20,",
"",
"  circulate:",
"    /// ",
"    // Require that at least one request always be issued. (boolean) //This allows the server to send messages to the client immediately.",
"    // `warn",
"    // Do not access this property directly; use bd.frenzyProxy.start and bd.frenzyProxy.stop.",
"    // `private ",
"    false,",
"",
"  stopped:",
"    /// ",
"    // Indicates the instance has stopped processing transactions. (boolean)",
"    // `warn ",
"    // Do not access this property direction; use bd.frenzyProxy.start and bd.frenzyProxy.stop.",
"    // `private ",
"    false,",
"",
"  constructor: function(",
"    args ///(kwargs) Configuration properties for new frenzy service instance.",
"  ) {",
"    /// ",
"    // Creates a new instance.",
"    dojo.mix(this, args, {",
"      callCounter:0,",
"      transactionCounter:0,",
"      liveTransactionCount:0,",
"      pendingCalls:{},",
"      queuedCalls:[],",
"      messageHandlers:{}",
"    });",
"    if (this.circulate) {",
"      //let this object fully construct and possibly let clients get some initial calls made, but start circulating within 10ms",
"      this.timer= setTimeout(dojo.hitch(this, \"startTransaction\"), 10);",
"    }",
"  },",
"",
"  call: function(",
"    procName, ///(string) The name of the procedure to call at the Frenzy service.",
"    args,     ///(any) The single argument to pass to the Frenzy procedure; multiple arguments are passed in an array or hash.",
"    onResult, ///(bd.frenzyProxy.onResult) Function that\'s called upon successful completion of the service request.",
"    onError   ///(bd.frenzyProxy.onError) Function that\'s called upon encountering an error during a service request.",
"  ) {",
"    /// ",
"    // Calls a service procedure. //Return successful result to onResult; call onError in the event of XHR failure.",
"",
"    if (this.stopped) {",
"      throw Error(\"Attempt to call stopped frenzy instance.\");///(error) If this frenzy proxy instance is stopped.",
"    }",
"",
"    var",
"      callId= ++this.callCounter,",
"      callInfo= {",
"        params: {",
"	  callId:callId,",
"	  procName:procName,",
"	  args:args",
"        },",
"        deferred:new dojo.Deferred(dojo.hitch(this, \"cancelCall\", callId))",
"      };",
"    callInfo.deferred.addCallbacks(onResult||null, onError||null);",
"    this.pendingCalls[\"_\"+callId]= callInfo;",
"    this.queuedCalls.push(callId);",
"    this.scheduleTransaction();",
"    return callInfo; ///(bd.frenzyProxy.callInfo) Contains all information about this call.",
"  },",
"",
"  cancelCall: function(",
"    callId ///(interger) A bd.frenzyProxy.callId previously returned by bd.frenzyProxy.call.",
"  ) {",
"    /// ",
"    // Cancels a call if it is still pending,",
"",
"    this.queuedCalls= dojo.filter(this.queuedCalls, function(queuedCallId) {",
"      return queuedCallId!=callId;",
"    });",
"    this.deletePendingCall(callId);",
"    return new Error(\"Frenzy call cancelled.\");",
"  },",
"",
"  connect: function(",
"    message, ///(string) Identifies the server message.",
"    proc     ///(bd.frenzyProxy.serverMessageHandler) The callback function.",
"  ){",
"    /// ",
"    // Connects a handler to a server message. //Once connected, upon receipt of the message `message` consequent to",
"    // a frenzy transaction, proc is called.",
"",
"    if (!this.messageHandlers[message]) {",
"      this.messageHandlers[message]= [proc];",
"    } else {",
"      this.messageHandlers[message].push(proc);",
"    }",
"  },",
"",
"  disconnect: function(",
"    message, ///(string) Identifies the server message.",
"    proc     ///(bd.frenzyProxy.serverMessageHandler) A callback function that was previously connected.",
"  ){",
"    /// ",
"    // Disconnects a handler from a server message. //See bd.frenzy.connect.",
"",
"    for (var handlers= this.messageHandlers[message], i= 0, end= handlers.length; i<end; i++) {",
"      if (handlers[i]===proc) {",
"        handlers.splice(i, 1);",
"        return;",
"      }",
"    }",
"  },",
"",
"  stop: function(",
"    cancelAll ///(boolean, optional, false) If true, then cancel all incomplete calls.",
"  ) {",
"    /// ",
"    // Stops all outgoing calls; optionally cancel all pending calls.",
"",
"    this.stopped= true;",
"    this.circulate= false;",
"    if (cancelAll) {",
"      var callList= [];",
"      for (var p in this.pendingCalls) {",
"        callList.push(p);",
"      }",
"      for (var i= 0, end= callList.length; i<end; i++) {",
"        this.pendingCalls[callList[i]].deferred.cancel();",
"      }",
"    }",
"  },",
"",
"  start: function(",
"    circulate ///(*bd.frenzyProxy.circulate)",
"  ) {",
"    /// ",
"    // Restarts outgoing calls and, optionally, circulation.",
"    // `note Harmless if already \"started\".",
"",
"    this.stopped= false;",
"    if (circulate) {",
"      this.circulate= true;",
"      this.timer= setTimeout(dojo.hitch(this, \"startTransaction\"), 10);",
"    }",
"  },",
"",
"  getServiceInfo: function(",
"    id ///(integer) The transaction number.",
"  ) {",
"    /// ",
"    // Returns the serviceInfo property of a service request object. //Override this method",
"    // to include special data (e.g., cookies) that is meaningful to the particular frenzy server.",
"",
"    return {",
"      transactionId: id,",
"      timeClientTx: bd.getTime()",
"    };",
"  },",
"",
"  scheduleTransaction: function() {",
"    ///",
"    // Sets a timer to call the server if required.",
"    // `private",
"",
"    if (this.stopped || this.timer) {",
"      return;",
"    }",
"    var resultsPending= this.queuedCalls.length;",
"    if (!resultsPending && this.liveTransactionCount==0) {",
"      for (var p in this.pendingCalls) {",
"        resultsPending= true;",
"        break;",
"      }",
"    }",
"    if (",
"      this.liveTransactionCount < this.maxLiveTransactions &&",
"      (resultsPending || (this.circulate && this.liveTransactionCount==0))",
"    ) {",
"      this.timer= setTimeout(dojo.hitch(this, \"startTransaction\"), this.delay);",
"      console.log(\"just set frenzy delay, t= \" + bd.getTime());",
"    }",
"  },",
"",
"  startTransaction: function() {",
"    ///",
"    // Constructs a service request object and sends the request to the Frenzy service.",
"    // `private",
"    this.timer= 0;",
"    if (this.stopped) {",
"      return;",
"    }",
"    console.log(\"frenzy.call server, t= \" + bd.getTime());",
"",
"    var content= {",
"      serviceInfo:this.getServiceInfo(++this.transactionCounter),",
"      calls:dojo.map(this.queuedCalls, function(callId) { return this.getPendingCall(callId).params; }, this)",
"    };",
"",
"    var callList= this.queuedCalls;",
"    this.queuedCalls= [];",
"",
"    this.liveTransactionCount++;",
"    var xhrDeferred= dojo.xhrPost(dojo.mix({}, this.xhrArgs, {postData: dojo.toJson(content)}));",
"    xhrDeferred.addCallbacks(",
"      dojo.hitch(this, \"onTransactionComplete\"),",
"      dojo.hitch(this, \"onTransactionError\", callList)",
"    );",
"  },",
"",
"  onTransactionComplete: function(",
"    result///(JSON) The result of a service request.",
"  ) {",
"    ///",
"    // Processes the result of a service request.",
"    // `private",
"    result= dojo.fromJson(result);",
"    var serviceInfo= result.serviceInfo;",
"    serviceInfo.timeClientRx= bd.getTime();",
"    dojo.forEach(result.results, function(result) {",
"      var callInfo= this.getPendingCall(result.callId);",
"      if (callInfo) {",
"        callInfo.result= result.result;",
"        callInfo.serviceInfo= serviceInfo;",
"        callInfo.deferred.callback(callInfo);",
"        this.deletePendingCall(result.callId);",
"      } else if (this.messageHandlers[result.serverMessage]) {",
"        for (var handlers= this.messageHandlers[result.serverMessage], i= 0, end= handlers.length; i<end; i++) {",
"          handlers[i](result.result, serviceInfo);",
"        }",
"      }",
"    }, this);",
"    this.liveTransactionCount--;",
"    this.scheduleTransaction();",
"    return result;",
"  },",
"",
"  onTransactionError: function(",
"    callList, ///(array of bd.frenzyProxy.callId) The set of calls upon which to signal an error.",
"    error     ///(any) The error to signal.",
"  ) {",
"    ///",
"    // Processes an error generated by a service request.",
"    // `private",
"    dojo.forEach(callList, function(callId) {",
"      var callInfo= this.getPendingCall(callId);",
"      callInfo.error= error;",
"      callInfo.serviceInfo= serviceInfo;",
"      callInfo.deferred.errback(callInfo);",
"      this.deletePendingCall(callId);",
"    }, this);",
"    this.liveTransactionCount--;",
"    this.scheduleTransaction();",
"  },",
"",
"  getPendingCall: function(",
"    callId ///(integer) The callId that identifies the call to return",
"  ){",
"    ///",
"    // Gets the bd.frenzyProxy.callInfo for callId from the pendingCalls cache.",
"    // `private",
"    return callId ? this.pendingCalls[\"_\"+callId] : undefined;",
"  },",
"",
"  deletePendingCall: function (",
"    callId ///(integer) The callId that identifies the call to return",
"  ){",
"    ///",
"    // Deletes the bd.frenzyProxy.callInfo for callId from the pendingCalls cache.",
"    // `private",
"    delete this.pendingCalls[\"_\"+callId];",
"  }",
"});",
"",
"bd.docGen(\"bd.frenzyProxy\", {",
"  \"constructor.kwargs\": {",
"    ///",
"    // Describes how to initialize a bd.frenzyProxy instance.",
"    xhrArgs: ",
"      ///(hash) The argument to provide to dojo.xhr in order to initiate a Frenzy transaction.",
"      undefined,",
"    maxLiveTransactions: ",
"      ///(integer, optional) Initial value for bd.frenzyProxy.maxLiveTransactions.",
"      undefined,",
"    circulate: ",
"      ///(boolean, optional) Override bd.frenzyProxy.circulate.",
"      undefined,",
"    delay:",
"      ///(integer, optional) Override bd.frenzyProxy.delay.",
"      undefined,",
"    getServiceInfo:",
"      ///(bd.frenzyProxy.serviceInfo, optional) Override getServiceInfo.",
"      undefined",
"  },",
"",
"  callId:",
"    ///type",
"    // An integer that uniquely indentifies a service request made through bd.frenzyProxy.call. //Also",
"    // see bd.frenzyProxy.cancelCall.",
"    ///",
"    // Each service request initiated via bd.frenzyProxy.call results in generating a",
"    // sequential callId. This can be used to untangle calls when they finish out of order.",
"    bd.noDefault,",
"",
"  transactionId:",
"    ///type",
"    // An integer that identifies a single single send-receive transaction with the server. //Several service ",
"    // requests as initialized through bd.frenzyProxy.call may be bundled into a single transaction (indeed,",
"    // this is one of the key purposes of the frenzy protocol.",
"    bd.noDefault,",
"",
"  callInfo: {",
"    ///type",
"    // Information about a particular Frenzy call.",
"    params:",
"      ///(bd.frenzyProxy.callParams) Provides the outgoing call parameters.",
"      0,",
"    deferred:",
"      ///(dojo.Deferred) The dojo.Deferred instance that controls the call.",
"      0,",
"    serviceInfo:",
"      ///(bd.frenzyProxy.serviceInfo) Provides call sequencing and timing information.",
"      0,",
"    result:",
"      ///(any) The service response to the call.",
"      0",
"  },",
"",
"  callParams: {",
"    ///type",
"    // Contains the outgoing call parameters.",
"    callId:",
"      ///(bd.frenzyProxy.callId) The callId for this call.",
"      bd.noDefault,",
"    procName:",
"      ///(string) The service name requested.",
"      bd.noDefault,",
"    args:",
"      ///(any) Arguments to accompany the service request",
"      null",
"  },",
"",
"  serviceInfo: {",
"    ///type",
"    // Contains service request (call) sequencing and timing information.",
"    transactionId:",
"      ///(bd.frenzyProxy.transactionId) The sequence number of this transaction.",
"      bd.noDefault,",
"    timeClientTx:",
"      ///(integer) Date in milliseconds this service request was made by the client.",
"      bd.noDefault,",
"    timeClientRx:",
"      ///(integer) Date in milliseconds this service request was received from the service.",
"      bd.noDefault,",
"    timeServiceRx:",
"      ///(integer) Date in milliseconds this service received the request.",
"      bd.noDefault,",
"    timeServiceTx:",
"      ///(integer) Date in milliseconds this service transmitted the response.",
"      bd.noDefault",
"  },",
"",
"  onResult: function(",
"    result,     ///(any) The result (after applying eval) of the response received consequent to a service request.",
"    serviceInfo ///(bd.frenzyProxy.serviceInfo) Information about this particular Frenzy transaction.",
"  ) {",
"    ///type",
"    // Client-provided function that\'s called upon successful completion of a Frenzy service request. //",
"    // ",
"    // The return value, if any, will be passed up the continuation change for the dojo.Deferred object that controls this particular Frenzy service request",
"  },",
"",
"  onError: function(",
"    result ///(error) The Error object.",
"  ) {",
"    ///type",
"    // Client-provided function that\'s called upon failure of a Frenzy service request. //",
"    // The return value, if any, will be passed up the continuation change for the dojo.Deferred object that controls this particular Frenzy service request",
"  },",
"",
"  serverMessageHandler: function(",
"    result, ///(any) The result sent with the service message as defined by the server.",
"    serviceInfo ///(bd.frenzyProxy.serviceInfo) Information about this particular Frenzy transaction.",
"  ) {",
"    ///type",
"    // Client-provided functions that may be connected to a known service message. //See bd.frenzyProxy.connect.",
"  }",
"   ",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.frenzyProxy":{
type:
Tclass,
sdoc:
["Implements a proxy to a Frenzy service."],
ldoc:
[],
src:
"bd/frenzy",
loc: [8,0,297,2],
module:"bd/frenzy"}
,"bd.frenzyProxy.maxLiveTransactions":{
type:
Tvariable,
sdoc:
["The maximum number of concurrent requests than may be issued to the server. (integer)"],
imember:1,
ldoc:
[],
loc: [20,2,23,5]}
,"bd.frenzyProxy.delay":{
type:
Tvariable,
sdoc:
["Milliseconds to wait before sending a queued request to the server. (integer)"],
imember:1,
ldoc:
[[NOTE,"Changes to this attribute will not take place until the next scheduled transaction with the server."]],
loc: [25,2,29,6]}
,"bd.frenzyProxy.circulate":{
type:
Tvariable,
sdoc:
["Require that at least one request always be issued. (boolean) "],
imember:1,
ldoc:
["Require that at least one request always be issued. (boolean) This allows the server to send messages to the client immediately.",
[WARN,"Do not access this property directly; use bd.frenzyProxy.start and bd.frenzyProxy.stop."]],
flags:
[Fprivate],
loc: [31,2,37,9]}
,"bd.frenzyProxy.stopped":{
type:
Tvariable,
sdoc:
["Indicates the instance has stopped processing transactions. (boolean)"],
imember:1,
ldoc:
[[WARN,"Do not access this property direction; use bd.frenzyProxy.start and bd.frenzyProxy.stop."]],
flags:
[Fprivate],
loc: [39,2,45,9]}
,"bd.frenzyProxy.constructor":{
type:
Tfunction,
sdoc:
["Creates a new instance."],
imember:1,
ldoc:
[],
params:
[["args",[["kwargs",
["Configuration properties for new frenzy service instance."]]]]],
loc: [47,2,64,3]}
,"bd.frenzyProxy.call":{
type:
Tfunction,
sdoc:
["Calls a service procedure. "],
imember:1,
ldoc:
["Calls a service procedure. Return successful result to onResult; call onError in the event of XHR failure."],
params:
[["procName",[["string",
["The name of the procedure to call at the Frenzy service."]]]],
["args",[["any",
["The single argument to pass to the Frenzy procedure; multiple arguments are passed in an array or hash."]]]],
["onResult",[["bd.frenzyProxy.onResult",
["Function that\'s called upon successful completion of the service request."]]]],
["onError",[["bd.frenzyProxy.onError",
["Function that\'s called upon encountering an error during a service request."]]]]],
returns:
[["bd.frenzyProxy.callInfo",
["Contains all information about this call."]]],
loc: [66,2,94,3]}
,"bd.frenzyProxy.cancelCall":{
type:
Tfunction,
sdoc:
["Cancels a call if it is still pending,"],
imember:1,
ldoc:
[],
params:
[["callId",[["interger",
["A bd.frenzyProxy.callId previously returned by bd.frenzyProxy.call."]]]]],
loc: [96,2,107,3]}
,"bd.frenzyProxy.connect":{
type:
Tfunction,
sdoc:
["Connects a handler to a server message. "],
imember:1,
ldoc:
["Connects a handler to a server message. Once connected, upon receipt of the message `message` consequent to\na frenzy transaction, proc is called."],
params:
[["message",[["string",
["Identifies the server message."]]]],
["proc",[["bd.frenzyProxy.serverMessageHandler",
["The callback function."]]]]],
loc: [109,2,122,3]}
,"bd.frenzyProxy.disconnect":{
type:
Tfunction,
sdoc:
["Disconnects a handler from a server message. "],
imember:1,
ldoc:
["Disconnects a handler from a server message. See bd.frenzy.connect."],
params:
[["message",[["string",
["Identifies the server message."]]]],
["proc",[["bd.frenzyProxy.serverMessageHandler",
["A callback function that was previously connected."]]]]],
loc: [124,2,137,3]}
,"bd.frenzyProxy.stop":{
type:
Tfunction,
sdoc:
["Stops all outgoing calls; optionally cancel all pending calls."],
imember:1,
ldoc:
[],
params:
[["cancelAll",[["boolean, optional, false",
["If true, then cancel all incomplete calls."]]]]],
loc: [139,2,156,3]}
,"bd.frenzyProxy.start":{
type:
Tfunction,
sdoc:
["Restarts outgoing calls and, optionally, circulation."],
imember:1,
ldoc:
[[NOTE,"Harmless if already \"started\"."]],
params:
[["circulate",[["*bd.frenzyProxy.circulate",
[]]]]],
loc: [158,2,170,3]}
,"bd.frenzyProxy.getServiceInfo":{
type:
Tfunction,
sdoc:
["Returns the serviceInfo property of a service request object. "],
imember:1,
ldoc:
["Returns the serviceInfo property of a service request object. Override this method\nto include special data (e.g., cookies) that is meaningful to the particular frenzy server."],
params:
[["id",[["integer",
["The transaction number."]]]]],
loc: [172,2,183,3]}
,"bd.frenzyProxy.scheduleTransaction":{
type:
Tfunction,
sdoc:
["Sets a timer to call the server if required."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
loc: [185,2,207,3]}
,"bd.frenzyProxy.startTransaction":{
type:
Tfunction,
sdoc:
["Constructs a service request object and sends the request to the Frenzy service."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
loc: [209,2,233,3]}
,"bd.frenzyProxy.onTransactionComplete":{
type:
Tfunction,
sdoc:
["Processes the result of a service request."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
params:
[["result",[["JSON",
["The result of a service request."]]]]],
loc: [235,2,260,3]}
,"bd.frenzyProxy.onTransactionError":{
type:
Tfunction,
sdoc:
["Processes an error generated by a service request."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
params:
[["callList",[["array of bd.frenzyProxy.callId",
["The set of calls upon which to signal an error."]]]],
["error",[["any",
["The error to signal."]]]]],
loc: [262,2,278,3]}
,"bd.frenzyProxy.getPendingCall":{
type:
Tfunction,
sdoc:
["Gets the bd.frenzyProxy.callInfo for callId from the pendingCalls cache."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
params:
[["callId",[["integer",
["The callId that identifies the call to return"]]]]],
loc: [280,2,287,3]}
,"bd.frenzyProxy.deletePendingCall":{
type:
Tfunction,
sdoc:
["Deletes the bd.frenzyProxy.callInfo for callId from the pendingCalls cache."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
params:
[["callId",[["integer",
["The callId that identifies the call to return"]]]]],
loc: [289,2,296,3]}
,"bd.frenzyProxy.constructor.kwargs":{
type:
Tvariable,
sdoc:
["Describes how to initialize a bd.frenzyProxy instance."],
ldoc:
[],
props:
["xhrArgs",{
type:
Tvariable,
loc: [305,6,305,15],
types:
[["hash",
["The argument to provide to dojo.xhr in order to initiate a Frenzy transaction."]]]}
,
"maxLiveTransactions",{
type:
Tvariable,
loc: [308,6,308,15],
types:
[["integer, optional",
["Initial value for bd.frenzyProxy.maxLiveTransactions."]]]}
,
"circulate",{
type:
Tvariable,
loc: [311,6,311,15],
types:
[["boolean, optional",
["Override bd.frenzyProxy.circulate."]]]}
,
"delay",{
type:
Tvariable,
loc: [314,6,314,15],
types:
[["integer, optional",
["Override bd.frenzyProxy.delay."]]]}
,
"getServiceInfo",{
type:
Tvariable,
loc: [317,6,317,15],
types:
[["bd.frenzyProxy.serviceInfo, optional",
["Override getServiceInfo."]]]}
],
src:
"bd/frenzy",
loc: [300,2,318,3],
module:"bd/frenzy"}
,"bd.frenzyProxy.callId":{
type:
Ttype,
sdoc:
["An integer that uniquely indentifies a service request made through bd.frenzyProxy.call. "],
ldoc:
["An integer that uniquely indentifies a service request made through bd.frenzyProxy.call. Also\nsee bd.frenzyProxy.cancelCall.",
"Each service request initiated via bd.frenzyProxy.call results in generating a\nsequential callId. This can be used to untangle calls when they finish out of order."],
src:
"bd/frenzy",
loc: [320,2,327,16],
module:"bd/frenzy"}
,"bd.frenzyProxy.transactionId":{
type:
Ttype,
sdoc:
["An integer that identifies a single single send-receive transaction with the server. "],
ldoc:
["An integer that identifies a single single send-receive transaction with the server. Several service\nrequests as initialized through bd.frenzyProxy.call may be bundled into a single transaction (indeed,\nthis is one of the key purposes of the frenzy protocol."],
src:
"bd/frenzy",
loc: [329,2,334,16],
module:"bd/frenzy"}
,"bd.frenzyProxy.callInfo":{
type:
Ttype,
sdoc:
["Information about a particular Frenzy call."],
ldoc:
[],
props:
["params",{
type:
Tvariable,
loc: [341,6,341,7],
types:
[["bd.frenzyProxy.callParams",
["Provides the outgoing call parameters."]]]}
,
"deferred",{
type:
Tvariable,
loc: [344,6,344,7],
types:
[["dojo.Deferred",
["The dojo.Deferred instance that controls the call."]]]}
,
"serviceInfo",{
type:
Tvariable,
loc: [347,6,347,7],
types:
[["bd.frenzyProxy.serviceInfo",
["Provides call sequencing and timing information."]]]}
,
"result",{
type:
Tvariable,
loc: [350,6,350,7],
types:
[["any",
["The service response to the call."]]]}
],
src:
"bd/frenzy",
loc: [336,2,351,3],
module:"bd/frenzy"}
,"bd.frenzyProxy.callParams":{
type:
Ttype,
sdoc:
["Contains the outgoing call parameters."],
ldoc:
[],
props:
["callId",{
type:
Tvariable,
loc: [358,6,358,18],
types:
[["bd.frenzyProxy.callId",
["The callId for this call."]]]}
,
"procName",{
type:
Tvariable,
loc: [361,6,361,18],
types:
[["string",
["The service name requested."]]]}
,
"args",{
type:
Tvariable,
loc: [364,6,364,10],
types:
[["any",
["Arguments to accompany the service request"]]]}
],
src:
"bd/frenzy",
loc: [353,2,365,3],
module:"bd/frenzy"}
,"bd.frenzyProxy.serviceInfo":{
type:
Ttype,
sdoc:
["Contains service request (call) sequencing and timing information."],
ldoc:
[],
props:
["transactionId",{
type:
Tvariable,
loc: [372,6,372,18],
types:
[["bd.frenzyProxy.transactionId",
["The sequence number of this transaction."]]]}
,
"timeClientTx",{
type:
Tvariable,
loc: [375,6,375,18],
types:
[["integer",
["Date in milliseconds this service request was made by the client."]]]}
,
"timeClientRx",{
type:
Tvariable,
loc: [378,6,378,18],
types:
[["integer",
["Date in milliseconds this service request was received from the service."]]]}
,
"timeServiceRx",{
type:
Tvariable,
loc: [381,6,381,18],
types:
[["integer",
["Date in milliseconds this service received the request."]]]}
,
"timeServiceTx",{
type:
Tvariable,
loc: [384,6,384,18],
types:
[["integer",
["Date in milliseconds this service transmitted the response."]]]}
],
src:
"bd/frenzy",
loc: [367,2,385,3],
module:"bd/frenzy"}
,"bd.frenzyProxy.onResult":{
type:
Ttype,
sdoc:
["Client-provided function that\'s called upon successful completion of a Frenzy service request. "],
ldoc:
["Client-provided function that\'s called upon successful completion of a Frenzy service request. \n\nThe return value, if any, will be passed up the continuation change for the dojo.Deferred object that controls this particular Frenzy service request"],
flags:
[Ffunction],
params:
[["result",[["any",
["The result (after applying eval) of the response received consequent to a service request."]]]],
["serviceInfo",[["bd.frenzyProxy.serviceInfo",
["Information about this particular Frenzy transaction."]]]]],
src:
"bd/frenzy",
loc: [387,2,395,3],
module:"bd/frenzy"}
,"bd.frenzyProxy.onError":{
type:
Ttype,
sdoc:
["Client-provided function that\'s called upon failure of a Frenzy service request. "],
ldoc:
["Client-provided function that\'s called upon failure of a Frenzy service request. \nThe return value, if any, will be passed up the continuation change for the dojo.Deferred object that controls this particular Frenzy service request"],
flags:
[Ffunction],
params:
[["result",[["error",
["The Error object."]]]]],
src:
"bd/frenzy",
loc: [397,2,403,3],
module:"bd/frenzy"}
,"bd.frenzyProxy.serverMessageHandler":{
type:
Ttype,
sdoc:
["Client-provided functions that may be connected to a known service message. "],
ldoc:
["Client-provided functions that may be connected to a known service message. See bd.frenzyProxy.connect."],
flags:
[Ffunction],
params:
[["result",[["any",
["The result sent with the service message as defined by the server."]]]],
["serviceInfo",[["bd.frenzyProxy.serviceInfo",
["Information about this particular Frenzy transaction."]]]]],
src:
"bd/frenzy",
loc: [405,2,411,3],
module:"bd/frenzy"}
,"modules.bd/frenzy":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with the bd.frenzy class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/frenzy",
loc: [0,0,415,2]}
,"resources.bd/hash":{
type:
Tresource,
sdoc:
["Defines the module bd/hash"],
src:
"bd/hash",
modules:
["bd/hash"],
code:
["dojo.def(\"bd/hash\", [\"bd/kernel\", \"bd/declare\"], function(bd) {",
"///",
"// Defines the class bd.hash.",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load the module bd. See module.bd.",
"",
"bd.declare(",
"  ///",
"  // Implements a generalized hash. //Unlike a standard JavaScript object, this class can use any type for a key.",
" ",
"  //class name",
"  \"bd:hash\", ",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  {",
"  constructor: ",
"    function(",
"      compareFunction ///(bd.predicate2, optional, JavaScript operator ===) Function to use to compare keys.",
"    ) {",
"      ///",
"      // Creates a new hash instance. //If compareKeysByValue is provided, then that function",
"      // is used to compare keys; otherwise, keys are compared with operator ===.",
"      this.keys= [];",
"      this.values= [];",
"      this.compareFunction= compareFunction || false;",
"    },",
"",
"  set:",
"    function(",
"      key,  ///(any) Key for value in hash.",
"      value ///(any) Value to be associated with key in hash.",
"    ) {",
"      ///",
"      // Sets the value for `key` in the hash.",
"      var comp= this.compareFunction;",
"      for (var keys= this.keys, i= keys.length; i--;) {",
"        if ((comp && comp(keys[i], key)) || keys[i]===key) {",
"          this.values[i]= value;",
"        }",
"      }",
"      keys.push(key);",
"      this.values.push(value);",
"      return this;",
"    },",
"",
"  del:",
"    function(",
"      key ///(any) Key to be deleted.",
"    ) {",
"      ///",
"      // Deletes the entry for `key` in the hash.",
"      var comp= this.compareFunction;",
"      for (var keys= this.keys, i= keys.length; i--;) {",
"        if ((comp && comp(keys[i], key)) || keys[i]===key) {",
"          keys.splice(i, 1);",
"          this.values.splice(i, 1);",
"          return true;",
"        }",
"      }",
"      return false;",
"    },",
"",
"  get: ",
"    function(",
"      key ///(any) Key that identifies value to be retrieved.",
"    ) {",
"      ///",
"      // Returns the value associated with `key` in the hash; returns bd.notFound if",
"      // no value has been entered for `key`.",
"      var comp= this.compareFunction;",
"      for (var keys= this.keys, i= keys.length; i--;) {",
"        if ((comp && comp(keys[i], key)) || keys[i]===key) {",
"          return this.values[i];",
"        }",
"      }",
"      return bd.notFound;",
"    },",
"",
"  forEach:",
"    function(",
"      callback, ///(function(key, value)) Function to call with each (key, value) pair in the hash.",
"                //(string) Function name in context to call with each (key,value) pair in the hash.",
"      context,  ///(object, optional) Context in which to apply callback.",
"      vargs     ///(variableArgs, optional) Zero or more arguments for application of function.",
"    ) {",
"      ///",
"      // Iterates over key key in the hash and passes (key, value) to callback. //As with all Backdraft ",
"      // functions that take a callback-like function argument, `(callback, context, vargs)`",
"      // is transformed to `bd.hitch(context, callback, arg1, arg2, ...)`.",
"",
"      if (arguments.length>1) {",
"        callback= bd.hitch.apply(bd, bd.array(arguments));",
"      }",
"      for (var keys= this.keys, values= this.values, i= keys.length; i--;) {",
"        callback.call(null, keys[i], values[i]);",
"      }",
"    }",
"});",
"",
"//TODO implement other collection functions",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.hash":{
type:
Tclass,
sdoc:
["Implements a generalized hash. "],
ldoc:
["Implements a generalized hash. Unlike a standard JavaScript object, this class can use any type for a key."],
src:
"bd/hash",
loc: [7,0,101,2],
module:"bd/hash"}
,"bd.hash.constructor":{
type:
Tfunction,
sdoc:
["Creates a new hash instance. "],
imember:1,
ldoc:
["Creates a new hash instance. If compareKeysByValue is provided, then that function\nis used to compare keys; otherwise, keys are compared with operator ===."],
params:
[["compareFunction",[["bd.predicate2, optional, JavaScript operator ===",
["Function to use to compare keys."]]]]],
loc: [19,2,29,5]}
,"bd.hash.set":{
type:
Tfunction,
sdoc:
["Sets the value for `key` in the hash."],
imember:1,
ldoc:
[],
params:
[["key",[["any",
["Key for value in hash."]]]],
["value",[["any",
["Value to be associated with key in hash."]]]]],
loc: [31,2,47,5]}
,"bd.hash.del":{
type:
Tfunction,
sdoc:
["Deletes the entry for `key` in the hash."],
imember:1,
ldoc:
[],
params:
[["key",[["any",
["Key to be deleted."]]]]],
loc: [49,2,64,5]}
,"bd.hash.get":{
type:
Tfunction,
sdoc:
["Returns the value associated with `key` in the hash; returns bd.notFound if\nno value has been entered for `key`."],
imember:1,
ldoc:
[],
params:
[["key",[["any",
["Key that identifies value to be retrieved."]]]]],
loc: [66,2,80,5]}
,"bd.hash.forEach":{
type:
Tfunction,
sdoc:
["Iterates over key key in the hash and passes (key, value) to callback. "],
imember:1,
ldoc:
["Iterates over key key in the hash and passes (key, value) to callback. As with all Backdraft\nfunctions that take a callback-like function argument, `(callback, context, vargs)`\nis transformed to `bd.hitch(context, callback, arg1, arg2, ...)`."],
params:
[["callback",[["function(key, value)",
["Function to call with each (key, value) pair in the hash."]],
["string",
["Function name in context to call with each (key,value) pair in the hash."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of function."]]]]],
loc: [82,2,100,5]}
,"modules.bd/hash":{
type:
Tmodule,
sdoc:
["Defines the class bd.hash."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load the module bd. See module.bd."]],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/hash",
loc: [0,0,105,2]}
,"resources.bd/htmlGen":{
type:
Tresource,
sdoc:
["Defines the module bd/htmlGen"],
src:
"bd/htmlGen",
modules:
["bd/htmlGen"],
code:
["dojo.def(\"bd/htmlGen\", [\"bd\"], function(bd) {",
"///",
"// Augments the bd namespace with the Backdraft HTML template functions.",
"",
"var",
"  escapeString= function(s) {",
"    if (bd.isString(s)) {",
"      return s.replace(/\"/g, \"\\\\\\\"\");",
"    } else {",
"      return s + \"\";",
"    }",
"  };",
"",
"bd.compileHtmlTemplate= function(element) {",
"  ///",
"  // Compiles a Backdraft HTML template for use with bd.generateHtmlTemplage.",
"  var",
"    attachPoint,",
"    connects,",
"    children,",
"    text= \"\", ",
"    tag, ",
"    contents, ",
"    attributes,",
"    a, ",
"    pairs= [], ",
"    childResult, ",
"    childrenHaveProcessing= 0, ",
"    i= 0, ",
"    length,",
"    result;",
"  if (bd.isString(element)) {",
"    return {text:element};",
"  }",
"  for (tag in element) {",
"    //there\'s always exactly one tag in element",
"    contents= element[tag];",
"    length= contents.length;",
"    //contents [i==0] holds the attributes",
"    attributes= contents[i++];",
"    for (a in attributes) {",
"      if (a==\"dclass\") {",
"        pairs.push(\"class=\\\"\" + attributes[a] + \"\\\"\");",
"      } else {",
"        pairs.push(a + \"=\\\"\" + escapeString(attributes[a]) + \"\\\"\");",
"      }",
"    }",
"    attributes= (pairs.length ? (\" \" + pairs.join(\" \")) : \"\");",
"    text+= \"<\" + tag + attributes + \">\";",
"    //contents[next] holds the attach point (if any)",
"    if (i<length && bd.isString(contents[i])) {",
"      attachPoint= contents[i++];",
"    }",
"    //contents[next] holds the connect hash (if any)",
"    if (i<length && !bd.isArray(contents[i])) {",
"      connects= contents[i++];",
"    }",
"    //contents[next] holds the children array (if any)",
"    if (i<length) {",
"      children= [];",
"      bd.forEach(contents[i], function(element, childIndex) {",
"        childResult= bd.compileHtmlTemplate(element);",
"        text+= childResult.text;",
"        if (childResult.attachPoint || childResult.connects || childResult.children) {",
"          childrenHaveProcessing= true;",
"          children.push({attachPoint: childResult.attachPoint, connects: childResult.connects, children:childResult.children});",
"        } else {",
"          children.push(0);",
"        }",
"      });",
"      if (!childrenHaveProcessing) {",
"        children= 0;",
"      }",
"    }",
"    text+= \"</\" + tag + \">\";",
"  }",
"  result= {text:text};",
"  attachPoint && (result.attachPoint= attachPoint);",
"  connects && (result.connects= connects);",
"  children && (result.children= children);",
"  return result;",
"};",
"",
"bd.connectHtmlTemplate= function(",
"  domNode,  ///(DOM node) The DOM subtree.",
"  template,   ///(object) A Backdraft template previously compiled by bd.compileHtmlTemplate.",
"  context    ///(object) The context the informs the connections.",
") {",
"  ///",
"  // Connects a new DOM subtree to properties as given in context.",
"  if (template.attachPoint) {",
"    context[template.attachPoint]= domNode;",
"  }",
"  bd.forEachHash(template.connects, function(listener, event) {",
"    bd.connect(domNode, event, listener, context);",
"  });",
"  bd.forEach(template.children, function(childTemplate, i) {",
"    childTemplate && bd.connectHtmlTemplate(domNode.childNodes[i], childTemplate, context);",
"  });",
"};",
"",
"bd.generateHtmlTemplate= function(",
"  template,   ///(object) A Backdraft template previously compiled by bd.compileHtmlTemplate.",
"  context,    ///(object) The context in which to build the DOM tree.",
"  replacements ///(hash) A hash of replacement text referenced by template.",
") {",
"  ///",
"  // Generates and connects a DOM subtree given a compiled Backdraft HTML template.",
"  var innerHTML= (replacements ? template.text.replace(/([^\\\\])\\{([^\\}]+)\\}/g, function(theMatch, c, name) { return c+ replacements[name]; }) : template.text);",
"  getSandbox().innerHTML= innerHTML;",
"  bd.connectHtmlTemplate(sandbox.firstChild, template, context);",
"  return sandbox.removeChild(sandbox.firstChild);",
"};",
"",
"var ",
"  sandbox= 0,",
"  getSandbox= function() {",
"    return sandbox || (sandbox= dojo.create(\"div\"));",
"  };",
"",
"});"]}
,"bd.compileHtmlTemplate":{
type:
Tfunction,
sdoc:
["Compiles a Backdraft HTML template for use with bd.generateHtmlTemplage."],
ldoc:
[],
params:
[["element",[]]],
src:
"bd/htmlGen",
loc: [13,0,81,1],
module:"bd/htmlGen"}
,"bd.connectHtmlTemplate":{
type:
Tfunction,
sdoc:
["Connects a new DOM subtree to properties as given in context."],
ldoc:
[],
params:
[["domNode",[["DOM node",
["The DOM subtree."]]]],
["template",[["object",
["A Backdraft template previously compiled by bd.compileHtmlTemplate."]]]],
["context",[["object",
["The context the informs the connections."]]]]],
src:
"bd/htmlGen",
loc: [83,0,99,1],
module:"bd/htmlGen"}
,"bd.generateHtmlTemplate":{
type:
Tfunction,
sdoc:
["Generates and connects a DOM subtree given a compiled Backdraft HTML template."],
ldoc:
[],
params:
[["template",[["object",
["A Backdraft template previously compiled by bd.compileHtmlTemplate."]]]],
["context",[["object",
["The context in which to build the DOM tree."]]]],
["replacements",[["hash",
["A hash of replacement text referenced by template."]]]]],
src:
"bd/htmlGen",
loc: [101,0,112,1],
module:"bd/htmlGen"}
,"modules.bd/htmlGen":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with the Backdraft HTML template functions."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/htmlGen",
loc: [0,0,120,2]}
,"resources.bd/id":{
type:
Tresource,
sdoc:
["Defines the module bd/id"],
src:
"bd/id",
modules:
["bd/id"],
code:
["dojo.def(\"bd/id\", [",
"  \"bd\"",
"], function(bd) {",
"///",
"// Defines the bd.id class.",
"",
"bd.declare(",
"  ///",
"  // Mixin class that provides a read-only id attribute that holds an page-wide unique identifier and registers new",
"  // instances with the bd.object registry.",
"	",
"  //class name",
"  \"bd:id\",",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  bd.constAttr(",
"    ///",
"    //(string) The id attribute value",
"    ///",
"    // A document-wide unique identifier. // If an identifier is not provided at construction (the usual case), then",
"    // an identifier is generated by bd.uid. Recall that bd.uid generates identifiers that are legal JavaScript identifiers.",
"    \"id\",",
"",
"    undefined //default value ",
"  ),",
" ",
"  {",
"  precreateDom: function() {",
"    ///",
"    // Initializes the id attribute and registers this object with the bd.object registry.",
"    this.inherited(arguments);",
"    this.id= this.id || bd.uid();",
"    bd.object.set(this);",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.id":{
type:
Tclass,
sdoc:
["Mixin class that provides a read-only id attribute that holds an page-wide unique identifier and registers new\ninstances with the bd.object registry."],
ldoc:
[],
src:
"bd/id",
loc: [6,0,37,2],
module:"bd/id"}
,"bd.id.id":{
type:
Tvariable,
sdoc:
["A document-wide unique identifier. "],
imember:1,
ldoc:
["A document-wide unique identifier.  If an identifier is not provided at construction (the usual case), then\nan identifier is generated by bd.uid. Recall that bd.uid generates identifiers that are legal JavaScript identifiers."],
flags:
[Froattr],
loc: [18,2,27,3],
types:
[["string",
["The id attribute value"]]]}
,"bd.id.precreateDom":{
type:
Tfunction,
sdoc:
["Initializes the id attribute and registers this object with the bd.object registry."],
imember:1,
ldoc:
[],
loc: [30,2,36,3]}
,"modules.bd/id":{
type:
Tmodule,
sdoc:
["Defines the bd.id class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/id",
loc: [0,0,39,2]}
,"resources.bd/interactive":{
type:
Tresource,
sdoc:
["Defines the module bd/interactive"],
src:
"bd/interactive",
modules:
["bd/interactive"],
code:
["dojo.def(\"bd/interactive\", [",
"  \"bd\", ",
"  \"bd/visual\"",
"], function(bd) {",
"///",
"// Defines the bd.interactive class.",
"",
"bd.declare(",
"  ///",
"  // Mixin class for objects (widgets) that are interactive and can therefore be disabled.",
"  ///",
"  // Recall that bd.visual provides a constant attribute value of `true` for disabled since bd.visual",
"  // does not provide any kind of user interaction capabilities. This class is usually mixed when deriving classes from bd.visual",
"  // that add interaction capabilities.",
"",
"  //class name",
"  \"bd:interactive\",",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  bd.attr(",
"    ///",
"    //(boolean) true if the widget is disabled; false otherwise.",
"    ///",
"    // Indicates whether or not the widget or any of its decendents can accept the focus. //True indicates the widget",
"    // iwill not react to any user input (keyboard or mouse); false indicates the widget is capable of and will react",
"    // to some kinds of user interaction.",
"    \"disabled\",",
"  ",
"    false //default value",
"  )",
");",
"",
"});"]}
,"bd.interactive":{
type:
Tclass,
sdoc:
["Mixin class for objects (widgets) that are interactive and can therefore be disabled."],
ldoc:
["Recall that bd.visual provides a constant attribute value of `true` for disabled since bd.visual\ndoes not provide any kind of user interaction capabilities. This class is usually mixed when deriving classes from bd.visual\nthat add interaction capabilities."],
src:
"bd/interactive",
loc: [7,0,33,1],
module:"bd/interactive"}
,"bd.interactive.disabled":{
type:
Tvariable,
sdoc:
["Indicates whether or not the widget or any of its decendents can accept the focus. "],
imember:1,
ldoc:
["Indicates whether or not the widget or any of its decendents can accept the focus. True indicates the widget\niwill not react to any user input (keyboard or mouse); false indicates the widget is capable of and will react\nto some kinds of user interaction."],
flags:
[Fattr],
loc: [22,2,32,3],
types:
[["boolean",
["true if the widget is disabled; false otherwise."]]]}
,"modules.bd/interactive":{
type:
Tmodule,
sdoc:
["Defines the bd.interactive class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/interactive",
loc: [0,0,35,2]}
,"resources.bd/kernel":{
type:
Tresource,
sdoc:
["Defines the module bd/kernel"],
src:
"bd/kernel",
modules:
["bd/kernel"],
docLocs:
[[405,412],[363,374],[281,288],[206,212]],
code:
["dojo.def(\"bd/kernel\", [",
"  \"dojo\", ",
"  \"dijit\", ",
"  \"dijit/_base\"",
"], function(dojo, dijit) {",
"///",
"// Creates and minimally initializes the object that holds the bd namespace.",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load the module bd. See module.bd.",
"",
"var bd= ",
"  ///namespace",
"  // The top-level namespace for the Backdraft browser application framework. //The bd namespace",
"  // is identical to the bd module. All objects defined by Backdraft are decendent properties of bd.",
"  {};",
"",
"dojo.modules.bd.result= bd; // a trick to make `bd.get(\"bd\")` work before the module is formally defined by the dojo loader.",
"",
"bd.widget=",
"  ///namespace",
"  // Contains the Backdraft widget classes.",
"  {};",
"",
"bd.mixDeep= ",
"  function(",
"    vargs ///(variableArgs, optional) Two or more objects to mix.",
"  ) {",
"    ///",
"    // Deep-mixes arguments into a new object and returns result. //Arguments are",
"    // mixed left to right (i.e., if two or more object contain the same property, then the right-most",
"    // object wins).",
"    ///",
"    // Deep mixing means that if two objects both define a particular property, and the value",
"    // of each property is of type Object, then the contents of each value is mixed rather than",
"    // just overwriting the left value with the right value.",
"    for (var o, result= arguments[0], i= 1; i<arguments.length; i++) {",
"      o= arguments[i];",
"      for (var p in o) {",
"        if (!(p in result)) {",
"          result[o]= o[p];",
"        } else if (result[p].constructor===Object && o[p].constructor===Object) {",
"          result[p]= bd.mixDeep(result[p], o[p]);",
"        } else {",
"          result[p]= o[p];",
"        }",
"      }",
"    }",
"    return result;",
"  };",
"",
"bd.config=",
"  {",
"    ///",
"    // Holds configuration values that control how the framework is initialized and operates.",
"    ///",
"    // Configuration properties can be customized in a couple of ways. For properties",
"    // that affect processing after a certain point (for example, after bd.start is called),",
"    // client code can can edit the contents of bd.config directly before a particular",
"    // point in execution.",
"    // ",
"    // Alternatively, client code can define the module bd/user/config to define configuration",
"    // property values before loading the Backdraft framework. If present when the bd/kernel module",
"    // is loaded, the value of the bd/user/config module will be deep mixed into ",
"    // bd.config. For example, a particular application could change the className of the root ",
"    // widget, by writing...",
"    //code",
"    // // Customize the value of some configuration properties...",
"    // dojo.def(\"bd/user/config\", function() {",
"    //   return {",
"    //     rootCreateArgs: {",
"    //       descriptor: {",
"    //         className:\"app:my.custom.root\"",
"    //       }",
"    //     }",
"    //   };",
"    // });",
"    // ",
"    // // now load the Backdraft framework...",
"    // dojo.req(\"bd\");",
"    ///",
"    // Notice carefully in the example above, when the Backdraft framework is loaded, *just* the property",
"    // bd.config.rootCreateArgs.descriptor.className is changed from it\'s default value. In particular,",
"    // (e.g.), bd.config.rootCreateArgs.descriptor.id retains it\'s default value of \"root\" because",
"    // the user configuration properties are *deep mixed*; see bd.mixDeep.",
"    rootCreateArgs: ",
"      {",
"        ///",
"        // Describes how bd.start should create the root widget.",
"        //(bd.createWidget.kwargs) The arguments to pass to bd.createWidget.",
"        ///",
"        // See bd.start",
"        descriptor:{",
"          className:\"bd:widget.root\",",
"          id:\"root\"",
"        }",
"      },",
"  ",
"    topCreateArgs:",
"        ///",
"        // Describes how bd.start should create the top widget.",
"        //(bd.createWidget.kwargs) The arguments to pass to bd.createWidget.",
"        ///",
"        // See bd.start",
"        undefined,",
"  ",
"    root:",
"      ///",
"      // The root widget of the application.",
"      ///",
"      // Backdraft models the DOM tree as a tree of widgets; this is the root widget. If not already created independently ",
"      // by client code, this widget is created when bd.start executes. Backdraft assumes that the DOM node associated with ",
"      // bd.root is the body element. Note that in this context, \"created\" means a widget class is attached to the document",
"      // body element--the DOM node is likely already created.",
"      undefined,",
"",
"    breakOnAssert:",
"      ///",
"      // Instructs bd.assert to break into the debugger upon assert failure. See bd.assert.",
"      true",
"  };",
"",
"var clientConfig= dojo.module(\"bd/config\");",
"clientConfig && bd.mixDeep(bd.config, clientConfig);",
"",
"// bd references some of dojo base so that the code isn\'t so tightly coupled to dojo--",
"// theoretically, the following could be changed to reference another library with",
"// identical semantics and everything would still work.",
"bd.eval= dojo.eval;",
"bd.deprecated= dojo.deprecated;",
"bd.experimental= dojo.experimental;",
"",
"//TODO: deal with i18n (locale) and text plugins",
"",
"bd.docGen=",
"  function() {",
"    ///",
"    // Documentation generator hook.",
"    ///",
"    // Facilitates generating documentation for named entities that have no place in normal",
"    // JavaScriptcode such as keyword arguments and types.",
"    // ",
"    // bd.docGen has no actual run-time function; if called it simply execute a no-op. All bd.doc",
"    // calls are removed by the Backdraft build utility for release versions of the code.  See ",
"    // the js-proc manual for further details.",
"  };",
"",
"bd.assert=",
"  function(",
"    condition, ///(boolean) The expected condition (truthy implies the assert passed).",
"    message    ///(string, \"bd.assert detected a fail condition\") The message to write to the console.",
"  ) {",
"    ///",
"    // Logs a message to the error console and optionally break into the debugger iff condition is not truthy. //A",
"    // break into the debugger is executed iff bd.config.breakOnAssert is true.",
"    /// ",
"    // All bd.assert calls are removed by the Backdraft build utility for release verions of the ",
"    if (!condition) {",
"      console.log(message || \"bd.assert detected a fail condition\");",
"      if (bd.config.breakOnAssert) {",
"        debugger;",
"      }",
"    }",
"  };",
"",
"(function() {",
"  function t() {",
"    bd.global=",
"      ///",
"      // The JavaScript global namespace.",
"      this;",
"  }",
"  t.call(null);",
"})();",
"",
"bd.doc=",
"  ///",
"  // The browser document",
"  document;",
"",
"bd.head=",
"  ///",
"  // The head element of the browser document",
"  dojo.head;",
"",
"bd.body=",
"  ///",
"  // The body element of the browser document",
"  dojo.body();",
"",
"var uid= 1;",
"bd.uid= function() {",
"  ///",
"  // Manufactures a JavaScript identifier that is unique within this current process. //The",
"  // name has the form `_bdUid``counting-number```.",
"  return \"_bdUid\" + (uid++); ///(name) Unique, legal JavaScript identifier within the current process.",
"};",
"",
"bd.node= function(",
"  id ///(string) The value of the id attribute of the target DOM node.",
") {",
"  ///",
"  // Returns the DOM node with the id attribute==id.",
"  ///",
"  //note",
"  // This is a synonym for the function dojo.byId.",
"  bd.docGen(\"overload\",",
"    function(",
"      node ///(DOM node) A DOM node.",
"    ) {",
"      /// Returns node.",
"    }",
"  );",
"};",
"bd.node= dojo.byId;",
"",
"bd.defaultValue=",
"  ///const",
"  // Unique object with no properties. //Useful for signalling \"default values\"",
"  // without stepping on potential real values like nil, 0, false, etc.",
"  {};",
"",
"bd.notFound=",
"  ///const",
"  // Unique object with no properties. //Useful for signalling \"not found\"",
"  // without stepping on potential real values like nil, 0, false, etc.",
"  {};",
"",
"bd.nodoc=",
"  ///const",
"  // Unique object with no properties. //Interpreted by the documentation generator to say",
"  // a value must be supplied for particular variable/argument/property. Typically, this is",
"  // used to indicate a member property value must be supplied to the constructor or is derived",
"  // during construction (i.e., it can not have a default value).",
"  {};",
"",
"",
"bd.failed= ",
"  ///const",
"  // Unique object with no properties. //Useful for signalling failure. For a",
"  // canonical example, see the disabled setter in bd.interactive.",
"  {};",
"",
"",
"bd.object=",
"  ///namespace",
"  // Holds the Backdraft object machinery.",
"  {};",
"",
"bd.object.set=",
"  function(",
"    object ///(any) Some object with the property `id` (a string that is a page-unique identifier).",
"  ) {",
"    ///",
"    // Adds object associated with id to the object registry.",
"    ///",
"    // See bd.object.get, bd.object.byId, bd.object.del.",
"    dijit.registry.add(object);",
"  };",
"",
"bd.object.get=",
"  function(",
"    id ///(string) A a page-unique identifier that has previously been added to the object registry.",
"  ) {",
"    ///",
"    // Returns the object associated with id previously added by bd.object.set (if any); otherwise, returns undefined.",
"    ///",
"    // See bd.object.get, bd.object.byId, bd.object.del.",
"    return dijit.byId(id);",
"  };",
"",
"bd.object.byId=",
"  function(",
"    id ///(string) A page-unique identifier that has previously been added to the object registry.",
"  ) {",
"    ///",
"    // Returns bd.object.get(id).",
"    ///",
"    // Convenience function analogous to dojo.byId and dijit.byId.",
"    ///",
"    // See bd.object.set, bd.object.get, bd.object.del.",
"    bd.docGen(\"overload\",",
"      function(",
"        object ///(any)",
"      ) {",
"        ///",
"        // Returns object (identity function).",
"      }",
"    );",
"    return bd.isString(id) ? dijit.byId(id) : id;",
"  };",
"",
"bd.object.byName= ",
"  function(",
"    name",
"  ) {",
"    ///",
"    //TODOC",
"    var hash= dijit.registry._hash;",
"      for (var p in hash) {",
"        if (hash[p].name==name) {",
"          return hash[p];",
"        }",
"      }",
"    return 0;",
"  };",
"",
"bd.object.del=",
"  function(",
"    object",
"  ) {",
"    ///",
"    // Remove object from object registry.",
"    ///",
"    // See bd.object.set, bd.object.get, bd.object.byId.",
"    dijit.registry.remove(object.id);",
"  };",
"",
"",
"bd.noop=",
"  function() {",
"    ///",
"    // Function that executes no statements and returns undefined. //Useful for",
"    // required default function argument.",
"  };",
"",
"bd.getOptionalProp=",
"  function(",
"    src, ///(object) The source object.",
"    prop, ///(string) The name of the property to retrieve from source.",
"    defaultValue ///(any) The value to return iff src[prop] does not exist.",
"  ) {",
"    ///",
"    // Return the value of src[prop] iff src[prop] exists; otherwise returns default value.",
"    ///",
"    // This function is useful for finding optional values that may be falsy when provided.",
"    // For example, a common JavaScript idiom is something like:",
"    //",
"    //code",
"    // someObject.someProperty || someDefault",
"    ///",
"    // Note that this will *not* work if someObject.someProperty can carry a falsy value: the result",
"    // will always be someDefault. However, writing:",
"    //",
"    //code",
"    // bd.getOptionalProp(someObject, \"someProperty\", someDefault)",
"    ///",
"    // will return any value stored in someObject[\"someProperty\"], even if that value is falsy.",
"    if (src.hasOwnProperty(prop)) {",
"      return src[prop];",
"    } else {",
"      return defaultValue;",
"    }",
"};",
"",
"bd.getTime=",
"  function(",
"  ) {",
"    ///",
"    // Calculates and returns the current time in milliseconds.",
"    return (new Date()).getTime(); ///(integer) Current time in milliseconds.",
"  };",
"",
"bd.docGen(\"bd\", {",
"  \"modulePropertyName\":",
"    ///type",
"    // A string that implies a property name nested in a module.",
"    ///",
"    // The string must be of the form `\"``module-name``:``jsName``\"` and implies the ",
"    // property `dojo.module(``module-name``).``jsName```. For example, `\"acme:widgets.coolbar\"` resolves ",
"    // to `dojo.module(\"acme\").widgets.coolbar`.",
"    //",
"    // See bd.get.",
"    0",
"});",
"",
"bd.moduleName= ",
"  function(",
"    name ///(string) Some name that implies a module.",
"  ) {",
"    ///",
"    // Returns the module name implied by name. //Typically, name is a jsName (e.g., \"acme.widgets.coolbar\")",
"    // and the default resolver returns the name in the form of a module name (e.g., \"acme/widgets/coolbar\").",
"    // However, the result of the name can be affected by one of two methods. First, an explicit transform",
"    // for name ``name`` can set by providing a value for `bd.moduleName[``name``]`. For example,",
"    // ",
"    //code",
"    // bd.moduleName[\"acme.widgets.coolbar\"]= \"acme/widgets\";",
"    ///",
"    // would cause `bd.moduleName(\"acme.widgets.coolbar\")` to return `\"acme/widgets\"`",
"    ///",
"    // This is termed an explicit transform. More general transforms can be given by adding a function ",
"    // to `bd.moduleName.resolvers`, an array of functions that take a name and return the module name (if ",
"    // resolved), or falsy (otherwise). For example",
"    //code",
"    // bd.moduleName.resolvers.push(function(name) {",
"    //   var match= name.match(/^(acme\\.widgets)\\.\\w+/);",
"    //   return match && \"acme/widgets\";",
"    // }",
"    ///",
"    // Now bd.moduleName would resolve \"acme.widgets.coolbar\", \"acme.widgets.coolcombo\", and so on into \"acme/widgets\".",
"    //",
"    // Naturally, explicit transforms take precedence over general transforms. General transforms are checked starting from the back",
"    // of the bd.moduleName.resolvers array. Typically, new transforms are pushed into the array resulting in the newer",
"    // transforms being checked before older transforms.",
"    bd.docGen(\"overload\",",
"      function(",
"        name ///(bd.modulePropertyName) Name that implies a module name.",
"      ) {",
"        ///",
"        // Returns the module name implied by name.",
"      }",
"    );",
"    var",
"      callee= arguments.callee,",
"      result= callee[name];",
"    if (result) {",
"      return result;",
"    }",
"    for (var resolvers= callee.resolvers, i= resolvers.length; i--;) {",
"      if ((result= resolvers[i](name))) {",
"        return result;",
"      }",
"    }",
"    return name;",
"  };",
"bd.moduleName.resolvers= ",
"  ///variable",
"  // Holds an array of functions that map names to a module names.",
"  ///",
"  // Functions must accept a single argument (the  name to map) and",
"  // return the module name (if successful) or falsy (otherwise). See bd.moduleName.",
"  [",
"    function(name) {",
"      return name.replace(/\\./g, \"/\").replace(/:/, \"/\"); ",
"    }",
"  ];",
"",
"return bd;",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd":{
type:
Tnamespace,
sdoc:
["The top-level namespace for the Backdraft browser application framework. "],
ldoc:
["The top-level namespace for the Backdraft browser application framework. The bd namespace\nis identical to the bd module. All objects defined by Backdraft are decendent properties of bd."],
src:
"bd/kernel",
module:"bd/kernel"}
,"bd.widget":{
type:
Tnamespace,
sdoc:
["Contains the Backdraft widget classes."],
ldoc:
[],
src:
"bd/kernel",
loc: [19,0,22,4],
module:"bd/kernel"}
,"bd.mixDeep":{
type:
Tfunction,
sdoc:
["Deep-mixes arguments into a new object and returns result. "],
ldoc:
["Deep-mixes arguments into a new object and returns result. Arguments are\nmixed left to right (i.e., if two or more object contain the same property, then the right-most\nobject wins).",
"Deep mixing means that if two objects both define a particular property, and the value\nof each property is of type Object, then the contents of each value is mixed rather than\njust overwriting the left value with the right value."],
params:
[["vargs",[["variableArgs, optional",
["Two or more objects to mix."]]]]],
src:
"bd/kernel",
loc: [24,0,49,3],
module:"bd/kernel"}
,"bd.config":{
type:
Tvariable,
sdoc:
["Holds configuration values that control how the framework is initialized and operates."],
ldoc:
["Configuration properties can be customized in a couple of ways. For properties\nthat affect processing after a certain point (for example, after bd.start is called),\nclient code can can edit the contents of bd.config directly before a particular\npoint in execution.\n\nAlternatively, client code can define the module bd/user/config to define configuration\nproperty values before loading the Backdraft framework. If present when the bd/kernel module\nis loaded, the value of the bd/user/config module will be deep mixed into\nbd.config. For example, a particular application could change the className of the root\nwidget, by writing...",
[CODE,"// Customize the value of some configuration properties...\ndojo.def(\"bd/user/config\", function() {\n  return {\n    rootCreateArgs: {\n      descriptor: {\n        className:\"app:my.custom.root\"\n      }\n    }\n  };\n});\n\n// now load the Backdraft framework...\ndojo.req(\"bd\");"],
"Notice carefully in the example above, when the Backdraft framework is loaded, *just* the property\nbd.config.rootCreateArgs.descriptor.className is changed from it\'s default value. In particular,\n(e.g.), bd.config.rootCreateArgs.descriptor.id retains it\'s default value of \"root\" because\nthe user configuration properties are *deep mixed*; see bd.mixDeep."],
props:
["rootCreateArgs",{
type:
Tvariable,
sdoc:
["Describes how bd.start should create the root widget."],
ldoc:
["See bd.start"],
props:
["descriptor",{loc: [92,19,95,9]}],
loc: [86,6,96,7],
types:
[["bd.createWidget.kwargs",
["The arguments to pass to bd.createWidget."]]]}
,
"topCreateArgs",{
type:
Tvariable,
sdoc:
["Describes how bd.start should create the top widget."],
ldoc:
["See bd.start"],
loc: [104,8,104,17],
types:
[["bd.createWidget.kwargs",
["The arguments to pass to bd.createWidget."]]]}
,
"root",{
type:
Tvariable,
sdoc:
["The root widget of the application."],
ldoc:
["Backdraft models the DOM tree as a tree of widgets; this is the root widget. If not already created independently\nby client code, this widget is created when bd.start executes. Backdraft assumes that the DOM node associated with\nbd.root is the body element. Note that in this context, \"created\" means a widget class is attached to the document\nbody element--the DOM node is likely already created."],
loc: [114,6,114,15]}
,
"breakOnAssert",{
type:
Tvariable,
sdoc:
["Instructs bd.assert to break into the debugger upon assert failure. See bd.assert."],
ldoc:
[],
loc: [119,6,119,10]}
],
src:
"bd/kernel",
loc: [51,0,120,3],
module:"bd/kernel"}
,"bd.docGen":{
type:
Tfunction,
sdoc:
["Documentation generator hook."],
ldoc:
["Facilitates generating documentation for named entities that have no place in normal\nJavaScriptcode such as keyword arguments and types.\n\nbd.docGen has no actual run-time function; if called it simply execute a no-op. All bd.doc\ncalls are removed by the Backdraft build utility for release versions of the code.  See\nthe js-proc manual for further details."],
src:
"bd/kernel",
loc: [134,0,145,3],
module:"bd/kernel"}
,"bd.assert":{
type:
Tfunction,
sdoc:
["Logs a message to the error console and optionally break into the debugger iff condition is not truthy. "],
ldoc:
["Logs a message to the error console and optionally break into the debugger iff condition is not truthy. A\nbreak into the debugger is executed iff bd.config.breakOnAssert is true.",
"All bd.assert calls are removed by the Backdraft build utility for release verions of the"],
params:
[["condition",[["boolean",
["The expected condition (truthy implies the assert passed)."]]]],
["message",[["string, \"bd.assert detected a fail condition\"",
["The message to write to the console."]]]]],
src:
"bd/kernel",
loc: [147,0,163,3],
module:"bd/kernel"}
,"bd.global":{
type:
Tvariable,
sdoc:
["The JavaScript global namespace."],
ldoc:
[],
src:
"bd/kernel",
loc: [167,4,170,10],
module:"bd/kernel"}
,"bd.doc":{
type:
Tvariable,
sdoc:
["The browser document"],
ldoc:
[],
src:
"bd/kernel",
loc: [175,0,178,10],
module:"bd/kernel"}
,"bd.head":{
type:
Tvariable,
sdoc:
["The head element of the browser document"],
ldoc:
[],
src:
"bd/kernel",
loc: [180,0,183,11],
module:"bd/kernel"}
,"bd.body":{
type:
Tvariable,
sdoc:
["The body element of the browser document"],
ldoc:
[],
src:
"bd/kernel",
loc: [185,0,188,13],
module:"bd/kernel"}
,"bd.uid":{
type:
Tfunction,
sdoc:
["Manufactures a JavaScript identifier that is unique within this current process. "],
ldoc:
["Manufactures a JavaScript identifier that is unique within this current process. The\nname has the form `_bdUid``counting-number```."],
returns:
[["name",
["Unique, legal JavaScript identifier within the current process."]]],
src:
"bd/kernel",
loc: [191,0,196,1],
module:"bd/kernel"}
,"bd.node":{
type:
Tfunction,
sdoc:
["Returns the DOM node with the id attribute==id."],
ldoc:
[[NOTE,"This is a synonym for the function dojo.byId."]],
params:
[["id",[["string",
["The value of the id attribute of the target DOM node."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Returns node."],
ldoc:
[],
params:
[["node",[["DOM node",
["A DOM node."]]]]],
loc: [207,4,211,5]}
],
src:
"bd/kernel",
loc: [198,0,213,1],
module:"bd/kernel"}
,"bd.defaultValue":{
type:
Tconst,
sdoc:
["Unique object with no properties. "],
ldoc:
["Unique object with no properties. Useful for signalling \"default values\"\nwithout stepping on potential real values like nil, 0, false, etc."],
src:
"bd/kernel",
loc: [216,0,220,4],
module:"bd/kernel"}
,"bd.notFound":{
type:
Tconst,
sdoc:
["Unique object with no properties. "],
ldoc:
["Unique object with no properties. Useful for signalling \"not found\"\nwithout stepping on potential real values like nil, 0, false, etc."],
src:
"bd/kernel",
loc: [222,0,226,4],
module:"bd/kernel"}
,"bd.nodoc":{
type:
Tconst,
sdoc:
["Unique object with no properties. "],
ldoc:
["Unique object with no properties. Interpreted by the documentation generator to say\na value must be supplied for particular variable/argument/property. Typically, this is\nused to indicate a member property value must be supplied to the constructor or is derived\nduring construction (i.e., it can not have a default value)."],
src:
"bd/kernel",
loc: [228,0,234,4],
module:"bd/kernel"}
,"bd.failed":{
type:
Tconst,
sdoc:
["Unique object with no properties. "],
ldoc:
["Unique object with no properties. Useful for signalling failure. For a\ncanonical example, see the disabled setter in bd.interactive."],
src:
"bd/kernel",
loc: [237,0,241,4],
module:"bd/kernel"}
,"bd.object":{
type:
Tnamespace,
sdoc:
["Holds the Backdraft object machinery."],
ldoc:
[],
src:
"bd/kernel",
loc: [244,0,247,4],
module:"bd/kernel"}
,"bd.object.set":{
type:
Tfunction,
sdoc:
["Adds object associated with id to the object registry."],
ldoc:
["See bd.object.get, bd.object.byId, bd.object.del."],
params:
[["object",[["any",
["Some object with the property `id` (a string that is a page-unique identifier)."]]]]],
src:
"bd/kernel",
loc: [249,0,258,3],
module:"bd/kernel"}
,"bd.object.get":{
type:
Tfunction,
sdoc:
["Returns the object associated with id previously added by bd.object.set (if any); otherwise, returns undefined."],
ldoc:
["See bd.object.get, bd.object.byId, bd.object.del."],
params:
[["id",[["string",
["A a page-unique identifier that has previously been added to the object registry."]]]]],
src:
"bd/kernel",
loc: [260,0,269,3],
module:"bd/kernel"}
,"bd.object.byId":{
type:
Tfunction,
sdoc:
["Returns bd.object.get(id)."],
ldoc:
["Convenience function analogous to dojo.byId and dijit.byId.",
"See bd.object.set, bd.object.get, bd.object.del."],
params:
[["id",[["string",
["A page-unique identifier that has previously been added to the object registry."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Returns object (identity function)."],
ldoc:
[],
params:
[["object",[["any",
[]]]]],
loc: [282,6,287,7]}
],
src:
"bd/kernel",
loc: [271,0,290,3],
module:"bd/kernel"}
,"bd.object.byName":{
type:
Tfunction,
sdoc:
["TODOC"],
ldoc:
[],
params:
[["name",[]]],
src:
"bd/kernel",
loc: [292,0,305,3],
module:"bd/kernel"}
,"bd.object.del":{
type:
Tfunction,
sdoc:
["Remove object from object registry."],
ldoc:
["See bd.object.set, bd.object.get, bd.object.byId."],
params:
[["object",[]]],
src:
"bd/kernel",
loc: [307,0,316,3],
module:"bd/kernel"}
,"bd.noop":{
type:
Tfunction,
sdoc:
["Function that executes no statements and returns undefined. "],
ldoc:
["Function that executes no statements and returns undefined. Useful for\nrequired default function argument."],
src:
"bd/kernel",
loc: [319,0,324,3],
module:"bd/kernel"}
,"bd.getOptionalProp":{
type:
Tfunction,
sdoc:
["Return the value of src[prop] iff src[prop] exists; otherwise returns default value."],
ldoc:
["This function is useful for finding optional values that may be falsy when provided.\nFor example, a common JavaScript idiom is something like:",
[CODE,"someObject.someProperty || someDefault"],
"Note that this will *not* work if someObject.someProperty can carry a falsy value: the result\nwill always be someDefault. However, writing:",
[CODE,"bd.getOptionalProp(someObject, \"someProperty\", someDefault)"],
"will return any value stored in someObject[\"someProperty\"], even if that value is falsy."],
params:
[["src",[["object",
["The source object."]]]],
["prop",[["string",
["The name of the property to retrieve from source."]]]],
["defaultValue",[["any",
["The value to return iff src[prop] does not exist."]]]]],
src:
"bd/kernel",
loc: [326,0,353,1],
module:"bd/kernel"}
,"bd.getTime":{
type:
Tfunction,
sdoc:
["Calculates and returns the current time in milliseconds."],
ldoc:
[],
returns:
[["integer",
["Current time in milliseconds."]]],
src:
"bd/kernel",
loc: [355,0,361,3],
module:"bd/kernel"}
,"bd.modulePropertyName":{
type:
Ttype,
sdoc:
["A string that implies a property name nested in a module."],
ldoc:
["The string must be of the form `\"``module-name``:``jsName``\"` and implies the\nproperty `dojo.module(``module-name``).``jsName```. For example, `\"acme:widgets.coolbar\"` resolves\nto `dojo.module(\"acme\").widgets.coolbar`.\n\nSee bd.get."],
src:
"bd/kernel",
loc: [364,2,373,5],
module:"bd/kernel"}
,"bd.moduleName":{
type:
Tfunction,
sdoc:
["Returns the module name implied by name. "],
ldoc:
["Returns the module name implied by name. Typically, name is a jsName (e.g., \"acme.widgets.coolbar\")\nand the default resolver returns the name in the form of a module name (e.g., \"acme/widgets/coolbar\").\nHowever, the result of the name can be affected by one of two methods. First, an explicit transform\nfor name ``name`` can set by providing a value for `bd.moduleName[``name``]`. For example,",
[CODE,"bd.moduleName[\"acme.widgets.coolbar\"]= \"acme/widgets\";"],
"would cause `bd.moduleName(\"acme.widgets.coolbar\")` to return `\"acme/widgets\"`",
"This is termed an explicit transform. More general transforms can be given by adding a function\nto `bd.moduleName.resolvers`, an array of functions that take a name and return the module name (if\nresolved), or falsy (otherwise). For example",
[CODE,"bd.moduleName.resolvers.push(function(name) {\n  var match= name.match(/^(acme\\.widgets)\\.\\w+/);\n  return match && \"acme/widgets\";\n}"],
"Now bd.moduleName would resolve \"acme.widgets.coolbar\", \"acme.widgets.coolcombo\", and so on into \"acme/widgets\".\n\nNaturally, explicit transforms take precedence over general transforms. General transforms are checked starting from the back\nof the bd.moduleName.resolvers array. Typically, new transforms are pushed into the array resulting in the newer\ntransforms being checked before older transforms."],
params:
[["name",[["string",
["Some name that implies a module."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Returns the module name implied by name."],
ldoc:
[],
params:
[["name",[["bd.modulePropertyName",
["Name that implies a module name."]]]]],
loc: [406,6,411,7]}
],
src:
"bd/kernel",
loc: [376,0,425,3],
module:"bd/kernel"}
,"bd.moduleName.resolvers":{
type:
Tvariable,
sdoc:
["Holds an array of functions that map names to a module names."],
ldoc:
["Functions must accept a single argument (the  name to map) and\nreturn the module name (if successful) or falsy (otherwise). See bd.moduleName."],
src:
"bd/kernel",
loc: [426,0,436,3],
module:"bd/kernel"}
,"modules.bd/kernel":{
type:
Tmodule,
sdoc:
["Creates and minimally initializes the object that holds the bd namespace."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load the module bd. See module.bd."]],
flags:
[Fmodule],
params:
[["dojo",[]],
["dijit",[]]],
src:
"bd/kernel",
loc: [0,0,440,2]}
,"resources.bd/lang":{
type:
Tresource,
sdoc:
["Defines the module bd/lang"],
src:
"bd/lang",
modules:
["bd/lang"],
docLocs:
[[371,378],[318,330],[292,299],[244,253],[13,58],[34,45]],
code:
["dojo.def(\"bd/lang\", [\"bd/kernel\", \"dojo\"], function(bd, dojo) {",
"///",
"// Augments the bd namespace with several functions that provide basic JavaScript language features.",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load the module bd. See module.bd.",
"",
"// bd references some of dojo base so that the code isn\'t so tightly coupled to dojo--",
"// theoretically, the following could be changed to reference another library with",
"// identical semantics and everything would still work.",
"bd.hitch= dojo.hitch;",
"bd.Deferred= dojo.Deferred;",
"",
"bd.docGen(\"bd\", {",
"  hitch:",
"    function (",
"      context, ///(object) Context in which to apply func.",
"      func,    ///(function) Function to apply. ",
"      vargs    ///(variableArgs, optional) Zero or more arguments for application of function.",
"    ) {",
"      ///",
"      // Returns a function equivalent to `function() { func.apply(context, bd.array(arguments, 2)); }`. //If",
"      // context is falsy, context is taken to imply bd.global. When there are no vargs,",
"      // the function returned is equivalent to `function() { func.call(context); }`.",
"      // ",
"      // The key purpose of this function is to generate functions that will operate equivalently irrespective ",
"      // of the calling context.",
"      //note",
"      // This function is an alias to dojo.hitch",
"      //warn",
"      // Notice that bd.hitch, dojo.hitch, and dojo.connect order function, context, and vargs as (context, function, vargs)",
"      // whereas every other function that takes similar arguments (e.g., bd.forEach, bd.schedule, dojo.forEach, etc.)",
"      // order the same arguments as (function, context, vargs).",
"      //nosource",
"      bd.docGen(\"overload\",",
"        function(",
"          context,",
"          functionName, ///(string) The name of a function property in context.",
"          vargs",
"        ) {",
"          ///",
"          // Returns a function equivalent to `function() { context[functionName].apply(context, bd.array(arguments, 0, args)); }`.  //If",
"          // context is falsy, context is taken to imply bd.global. When args are missing,",
"          // the function returned is equivalent to `function() { context\\[functionName](); }`.",
"        }",
"      );",
"    },",
"",
"  Deferred:",
"    function(",
"      canceler ///(function) Function to call if the instance is canceled.",
"    ) {",
"      ///",
"      // Controls a chain of asynchronous execution.",
"      ///",
"      //note",
"      // This function is an alias for dojo.Deferred.",
"    }",
"});",
"",
"bd.isString=",
"  function(",
"    test ///(any) Item to test.",
"  ) {",
"    ///",
"    // Returns true iff test is a string literal or string object.",
"    return (typeof test == \"string\" || test instanceof String);",
"  };",
"",
"bd.isArray= ",
"  function(",
"    test ///(any) Item to test.",
"  ) {",
"    ///",
"    // Returns true iff test is an Array.",
"    return test instanceof Array;",
"  };",
"",
"bd.isFunction=",
"  function(",
"    test ///(any) Item to test.",
"  ) {",
"    ///",
"    // Returns true iff test is a Function.",
"    return test instanceof Function;",
"  };",
"",
"bd.isObject= ",
"  function(",
"    test ///(any) Item to test.",
"  ) {",
"    ///",
"    // Returns true iff test has Object at the end of its prototype chain. //In particular, object literals, instances of Object,",
"    // instances of String, array literals, instances of Array, function literals, instances of Function, regex literals and",
"    // instances of RegExp, instances of Date,",
"    // and all instances from user-defined constructor functions are considered objects by this function. Conversely, numbers ",
"    // literals, boolean literals, string literals, null, and undefined are not considered objects by this function.",
"    //warn",
"    // null is not considered an object by this function which is different the JavaScript typeof operator.",
"    return test instanceof Object;",
"  };",
"",
"var arrayPrototypeSlice= Array.prototype.slice;",
"bd.array= ",
"  function(",
"    src,   ///(array-like object) Some aggregate object that presents a continuous, integer-indexed interface to its",
"           // contents and a length property to say how many components it contains.",
"    start, ///(integer, optional, 0) The first item in src to move to the result.",
"    dest   ///(array, optional, []) The initial value of result before src is copied.",
"  ) {",
"    ///",
"    // Concatenates src[start..src.length-1] to dest and returns result.  //Typically, this function is used to convert array-like",
"    // objects--like the JavaScript arguments variable--to a proper array.",
"    return (dest||[]).concat(arrayPrototypeSlice.call(src, start||0));",
"  };",
"",
"bd.hitchCallback= function(",
"  args,  ///(arguments) The arguments object of a particular function application.",
"  offset ///(integer) The position in arguments that (callback, context, vargs) starts.",
") {",
"  ///",
"  // Hitches callback, context, and callback arguments.",
"  ///",
"  // All Backdraft functions that take a callback function as the last argument define those arguments as `(callback, context,",
"  // arg1, arg2, ...)`. For example, see bd.forEach. This function transforms the implied callback into a single function.",
"  //note",
"  // This function is mosly for internal use by Backdraft; it is exposed so that client programs can follow the same paradigm",
"  // if desired.",
"  if (args.length>offset+1) {",
"    return bd.hitch.apply(bd, bd.array(args, offset+2, [args[offset+1], args[offset]]));",
"  } else {",
"    return args[offset];",
"  }",
"};",
"",
"bd.mix= ",
"  function(",
"    dest,     ///(object) The object into which to mix src properties.",
"    src,      ///(object*) The object(s) from which to take properties to mix into dest.",
"    overwrite ///(not an object, optional, true) Overwrite dest properties iff truthy.",
"  ) {",
"    ///",
"    // Mix properties of src into dest. //If dest is falsy, then a new object is created to",
"    // hold the result. Multiple src objects may be provided in which case",
"    // properties are mixed from left to right. If the last argument is not an object, then it",
"    // is interpretted as a boolean that says whether or not to overwrite the properties in",
"    // dest (if true) or preserve the properties in dest (otherwise). In cases where multiple",
"    // source objects are provided and overwrite is missing or true, the right-most definition for",
"    // a particular property wins; conversely, when multiple source objects are provided and overwrite",
"    // is false, the left-most definition wins.",
"    //",
"    // Examples:",
"    //code",
"    // //missing first object",
"    // var x;",
"    // bd.mix(x, {a:1});       //=>{a:1}",
"    // bd.mix(0, {a: 1});      //=>{a: 1}",
"    // bd.mix(false, {a: 1});  //=>{a: 1}",
"    // ",
"    // //normal mixing",
"    // bd.mix({a: 1}, {b: 2});  //=>{a: 1, b: 2}",
"    // bd.mix({a: 1}, {a: 2});  //=>{a: 2}",
"    // ",
"    // //explicitly setting overwrite has the same effect as normal mixing",
"    // bd.mix({a: 1}, {a: 2}, true);  //=>{a: 2}",
"    // bd.mix({a: 1}, {a: 2}, 1);     //=>{a: 2}",
"    // ",
"    // //normal mixing multiple objects",
"    // bd.mix({a: 0}, {a: 1}, {a: 2});  //=>{a: 2}",
"    // bd.mix({x: 0}, {a: 1}, {a: 2});  //=>{x: 0, a: 2}",
"    // bd.mix({x: 0}, {y: 1}, {a: 2});  //=>{x: 0, y:1, a: 2}",
"    // ",
"    // //normal mixing multiple objects with overwrite explicitly false",
"    // bd.mix({a: 0}, {a: 1}, {a: 2}, false);  //=>{a: 0}",
"    // bd.mix({x: 0}, {a: 1}, {a: 2}, false);  //=>{x: 0, a: 1}",
"    // bd.mix({x: 0}, {y: 1}, {a: 2}, false);  //=>{x: 0, y:1, a: 2}",
"    var ",
"      args= arguments,",
"      length= arguments.length - 1,",
"      result= args[0] || {},",
"      //overwrite is declared in the signature for the documentation generator",
"      //since is may actually be an object to mix, DO NOT steop on it!",
"      overwrite_= (args[length] instanceof Object) ? true : args[length--],",
"      source, prop,",
"      i= 1;",
"    while (i<=length) {",
"      source= args[i++];",
"      for (prop in source) {",
"        if (overwrite_ || !(prop in result)) {",
"          result[prop] = source[prop];",
"        }",
"      }      ",
"    }",
"    return result;",
"  };",
"",
"bd.partial= ",
"  function(",
"    func, ///(function) Function to apply.",
"    vargs ///(variableArgs, optional) Zero or more arguments for application of function.",
"  ) {",
"    ///",
"    // Returns a function equivalent to `function() { func.apply(bd.global, bd.array(arguments, 0, vargs)); }`",
"    vargs= bd.array(arguments, 1);",
"    return function() { ",
"      return func.apply(bd.global, bd.array(arguments, 0, vargs));",
"    };",
"  };",
"",
"var delegateCtor= function() {};",
"bd.delegate=",
"  function(",
"    prototype, props",
"  ) {",
"    ///",
"    // Creates a new object with given prototype and properties.",
"    delegateCtor.prototype= prototype;",
"    var result= new delegateCtor();",
"    return props ? bd.mix(result, props) : result;",
"  };",
"",
"bd.extend= ",
"  function(",
"    ctor, ///(function) The constructor function whos prototype is to be modified.",
"    src   ///(object) The object(s) from which to take properties to mix into ctor.prototype.",
"  ) {",
"    ///",
"    // Mixes src objects into ctor.prototype with bd.mix.",
"    bd.mix.apply(bd, bd.array(arguments, 1, [ctor.prototype]));",
"  };",
"",
"bd.get=",
"  function(",
"    name,        ///(jsName) The property to resolve.",
"    context,     ///(falsy) Root object for name is given by dojo.global.",
"                 //(string) Root object for name is given by dojo.module(context).",
"                 //(otherwise) Root object for name.",
"    defaultValue ///(any, optional) Value to initialize the property iff it is currently undefined.",
"  ) {",
"    ///",
"    // Resolves a string into a nested property value.",
"    ///",
"    // Returns the property given by ```context``.``name```.  If the property is undefined",
"    // and `defaultValue!==undefined`, then calls `bd.set(name, context, defaultValue)`.",
"    bd.docGen(\"overload\", ",
"      function(",
"        name,      ///(bd.modulePropertyName) property to resolve",
"        defaultValue",
"      ) {",
"        /// ",
"        // Returns the property implied by name.  //If the property is undefined",
"        // and `defaultValue!==undefined`, then calls `bd.set(name, defaultValue)`.",
"      }",
"    );",
"    //argument juggling",
"    var parts= name.split(\":\");",
"    if (parts.length==2) {",
"      defaultValue= context;",
"      context= dojo.module(parts[0]);",
"      name= parts[1];",
"    } else if (bd.isString(context)) {",
"      context= dojo.module(context);",
"    } else {",
"      context= context || dojo.global;",
"    }",
"    if (!context) {",
"      return undefined;",
"    }",
"    var ",
"      p, ",
"      temp= context, ",
"      i= 0, ",
"      end= (parts= name.split(\".\")).length;",
"    while (i<end) {",
"      p= parts[i++];",
"      if (temp===undefined || !(p in temp)) {",
"        return defaultValue!==undefined ? bd.set(name, context, defaultValue) : undefined;",
"      }",
"      temp= temp[p];",
"    }",
"    return temp;",
"  };",
"",
"bd.exists= ",
"  function(",
"    name,   ///(jsName) The property to resolve.",
"    context ///(falsy) Root object for name is given by dojo.global.",
"            //(string) Root object for name is given by dojo.module(context).",
"            //(otherwise) Root object for name.",
"  ) {",
"    ///",
"    // Predicate: syntactic sugar for `bd.get(name, context)!==undefined`.",
"    bd.docGen(\"overload\", ",
"      function(",
"        name ///(bd.modulePropertyName) property to resolve",
"      ) {",
"        /// ",
"        // Predicate: syntactic sugar for `bd.get(name)==undefined`.",
"      }",
"    );",
"    return bd.get(name, context)!==undefined;",
"  };",
"",
"bd.set=",
"  function(",
"    name,    ///(jsName) The property to resolve.",
"    context, ///(falsy) Root object for name is given by dojo.global.",
"             //(string) Root object for name is given by dojo.module(context).",
"             //(otherwise) Root object for name.",
"    value    ///(any) Value to set.",
"  ) {",
"    ///",
"    // Sets to value of the property given by ```context``.``name``` to value.  //If the ",
"    // property is undefined, then create the implied chain of objects.",
"    //warn",
"    // If a module is implied by providing a string for context and that module does not exist,",
"    // then the function asserts failure and returns undefined (this function cannot create",
"    // a non-existing module).",
"    bd.docGen(\"overload\", ",
"      function(",
"        name, ///(bd.modulePropertyName) property to resolve",
"        value",
"      ) {",
"        /// ",
"        // Sets to value of the property implied by name to value.  //If the ",
"        // property is undefined, then create the implied chain of objects.",
"        //warn",
"        // If the implied module does not exist, then the function asserts ",
"        // failure and returns undefined (this function cannot create a non-existing module).",
"      }",
"    );",
"",
"    //argument juggling",
"    if (arguments.length==2) {",
"      //since name and value are required, context must be missing",
"      value= context;",
"      context= 0;",
"    }",
"    var parts= name.split(\":\");",
"    if (parts.length==2) {",
"      context= dojo.module(parts[0]);",
"      name= parts[1];",
"    } else if (bd.isString(context)) {",
"      context= dojo.module(context);",
"    } else {",
"      context= context || dojo.global;",
"    }",
"    if (!context) {",
"      bd.assert(context);",
"      return undefined;",
"    }",
"    for (var i= 0, end= (parts= name.split(\".\")).length-1; i<end;) {",
"      name= parts[i++];",
"      context= context[name]= context[name] || {};",
"    }",
"    return (context[parts[i]]= value);",
"  };",
"",
"bd.hijack=",
"  function(",
"    context,         ///(object) The object that contains the function to hijack.",
"    functionName,    ///(string) The name of the function to hijack.",
"    hijacker,        ///(function) The replacement function.",
"    hijackerContext, ///(object, optional, 0) The context in which to call hijacker; falsy implies bd.global",
"    chain            ///(boolean, optional, false) Call the original function automatically after the hijacker finishes.",
"  ) {",
"    ///",
"    // Replaces context[functionName] with highjacker. //If chain is true, then the context[functionName] is ",
"    // called with original arguments (if any) immediately after hijacker returns.",
"    ///",
"    // Returns a handle to restore context[functionName] to its original value with overloaded signature to bd.hijack.",
"    bd.docGen(\"overload\",",
"      function(",
"        handle ///(bd.hijack.handle) A result returned by bd.hijack when a hijack was installed.",
"      ) {",
"        ///",
"        // Restores a hijacked function to its prior state.",
"      }",
"    );",
"",
"    if (arguments.length>1) {",
"      //hijacking a function",
"      hijackerContext= hijackerContext || bd.global;",
"      var ",
"        originalFunction= context[functionName],",
"        handle= [context, functionName, originalFunction];",
"      if (chain) {",
"        context[functionName]= function() {",
"          var args= bd.array(arguments);",
"          hijacker.apply(hijackerContext, args);",
"          return originalFunction.apply(context, args);",
"        };",
"      } else {",
"        context[functionName]= bd.hitch(hijackerContext, hijacker);",
"      }",
"      context[functionName].original= originalFunction;",
"      return handle;",
"    } else {",
"      //context is actually a handle...",
"      context[0][context[1]]= context[2];",
"      return 0;      ",
"    }  ",
"  };",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.hitch":{
type:
Tfunction,
sdoc:
["Returns a function equivalent to `function() { func.apply(context, bd.array(arguments, 2)); }`. "],
ldoc:
["Returns a function equivalent to `function() { func.apply(context, bd.array(arguments, 2)); }`. If\ncontext is falsy, context is taken to imply bd.global. When there are no vargs,\nthe function returned is equivalent to `function() { func.call(context); }`.\n\nThe key purpose of this function is to generate functions that will operate equivalently irrespective\nof the calling context.",
[NOTE,"This function is an alias to dojo.hitch"],
[WARN,"Notice that bd.hitch, dojo.hitch, and dojo.connect order function, context, and vargs as (context, function, vargs)\nwhereas every other function that takes similar arguments (e.g., bd.forEach, bd.schedule, dojo.forEach, etc.)\norder the same arguments as (function, context, vargs)."]],
flags:
[Ffunction,Fnosource],
params:
[["context",[["object",
["Context in which to apply func."]]]],
["func",[["function",
["Function to apply."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of function."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Returns a function equivalent to `function() { context[functionName].apply(context, bd.array(arguments, 0, args)); }`.  "],
ldoc:
["Returns a function equivalent to `function() { context[functionName].apply(context, bd.array(arguments, 0, args)); }`.  If\ncontext is falsy, context is taken to imply bd.global. When args are missing,\nthe function returned is equivalent to `function() { context\\[functionName](); }`."],
params:
[["context",[]],
["functionName",[["string",
["The name of a function property in context."]]]],
["vargs",[]]],
loc: [35,8,44,9]}
],
src:
"bd/lang",
loc: [14,2,46,5],
module:"bd/lang"}
,"bd.Deferred":{
type:
Tfunction,
sdoc:
["Controls a chain of asynchronous execution."],
ldoc:
[[NOTE,"This function is an alias for dojo.Deferred."]],
flags:
[Ffunction],
params:
[["canceler",[["function",
["Function to call if the instance is canceled."]]]]],
src:
"bd/lang",
loc: [48,2,57,5],
module:"bd/lang"}
,"bd.isString":{
type:
Tfunction,
sdoc:
["Returns true iff test is a string literal or string object."],
ldoc:
[],
params:
[["test",[["any",
["Item to test."]]]]],
src:
"bd/lang",
loc: [60,0,67,3],
module:"bd/lang"}
,"bd.isArray":{
type:
Tfunction,
sdoc:
["Returns true iff test is an Array."],
ldoc:
[],
params:
[["test",[["any",
["Item to test."]]]]],
src:
"bd/lang",
loc: [69,0,76,3],
module:"bd/lang"}
,"bd.isFunction":{
type:
Tfunction,
sdoc:
["Returns true iff test is a Function."],
ldoc:
[],
params:
[["test",[["any",
["Item to test."]]]]],
src:
"bd/lang",
loc: [78,0,85,3],
module:"bd/lang"}
,"bd.isObject":{
type:
Tfunction,
sdoc:
["Returns true iff test has Object at the end of its prototype chain. "],
ldoc:
["Returns true iff test has Object at the end of its prototype chain. In particular, object literals, instances of Object,\ninstances of String, array literals, instances of Array, function literals, instances of Function, regex literals and\ninstances of RegExp, instances of Date,\nand all instances from user-defined constructor functions are considered objects by this function. Conversely, numbers\nliterals, boolean literals, string literals, null, and undefined are not considered objects by this function.",
[WARN,"null is not considered an object by this function which is different the JavaScript typeof operator."]],
params:
[["test",[["any",
["Item to test."]]]]],
src:
"bd/lang",
loc: [87,0,100,3],
module:"bd/lang"}
,"bd.array":{
type:
Tfunction,
sdoc:
["Concatenates src[start..src.length-1] to dest and returns result.  "],
ldoc:
["Concatenates src[start..src.length-1] to dest and returns result.  Typically, this function is used to convert array-like\nobjects--like the JavaScript arguments variable--to a proper array."],
params:
[["src",[["array-like object",
["Some aggregate object that presents a continuous, integer-indexed interface to its\n contents and a length property to say how many components it contains."]]]],
["start",[["integer, optional, 0",
["The first item in src to move to the result."]]]],
["dest",[["array, optional, []",
["The initial value of result before src is copied."]]]]],
src:
"bd/lang",
loc: [103,0,114,3],
module:"bd/lang"}
,"bd.hitchCallback":{
type:
Tfunction,
sdoc:
["Hitches callback, context, and callback arguments."],
ldoc:
["All Backdraft functions that take a callback function as the last argument define those arguments as `(callback, context,\narg1, arg2, ...)`. For example, see bd.forEach. This function transforms the implied callback into a single function.",
[NOTE,"This function is mosly for internal use by Backdraft; it is exposed so that client programs can follow the same paradigm\nif desired."]],
params:
[["args",[["arguments",
["The arguments object of a particular function application."]]]],
["offset",[["integer",
["The position in arguments that (callback, context, vargs) starts."]]]]],
src:
"bd/lang",
loc: [116,0,133,1],
module:"bd/lang"}
,"bd.mix":{
type:
Tfunction,
sdoc:
["Mix properties of src into dest. "],
ldoc:
["Mix properties of src into dest. If dest is falsy, then a new object is created to\nhold the result. Multiple src objects may be provided in which case\nproperties are mixed from left to right. If the last argument is not an object, then it\nis interpretted as a boolean that says whether or not to overwrite the properties in\ndest (if true) or preserve the properties in dest (otherwise). In cases where multiple\nsource objects are provided and overwrite is missing or true, the right-most definition for\na particular property wins; conversely, when multiple source objects are provided and overwrite\nis false, the left-most definition wins.\n\nExamples:",
[CODE,"//missing first object\nvar x;\nbd.mix(x, {a:1});       //=>{a:1}\nbd.mix(0, {a: 1});      //=>{a: 1}\nbd.mix(false, {a: 1});  //=>{a: 1}\n\n//normal mixing\nbd.mix({a: 1}, {b: 2});  //=>{a: 1, b: 2}\nbd.mix({a: 1}, {a: 2});  //=>{a: 2}\n\n//explicitly setting overwrite has the same effect as normal mixing\nbd.mix({a: 1}, {a: 2}, true);  //=>{a: 2}\nbd.mix({a: 1}, {a: 2}, 1);     //=>{a: 2}\n\n//normal mixing multiple objects\nbd.mix({a: 0}, {a: 1}, {a: 2});  //=>{a: 2}\nbd.mix({x: 0}, {a: 1}, {a: 2});  //=>{x: 0, a: 2}\nbd.mix({x: 0}, {y: 1}, {a: 2});  //=>{x: 0, y:1, a: 2}\n\n//normal mixing multiple objects with overwrite explicitly false\nbd.mix({a: 0}, {a: 1}, {a: 2}, false);  //=>{a: 0}\nbd.mix({x: 0}, {a: 1}, {a: 2}, false);  //=>{x: 0, a: 1}\nbd.mix({x: 0}, {y: 1}, {a: 2}, false);  //=>{x: 0, y:1, a: 2}"]],
params:
[["dest",[["object",
["The object into which to mix src properties."]]]],
["src",[["object*",
["The object(s) from which to take properties to mix into dest."]]]],
["overwrite",[["not an object, optional, true",
["Overwrite dest properties iff truthy."]]]]],
src:
"bd/lang",
loc: [135,0,194,3],
module:"bd/lang"}
,"bd.partial":{
type:
Tfunction,
sdoc:
["Returns a function equivalent to `function() { func.apply(bd.global, bd.array(arguments, 0, vargs)); }`"],
ldoc:
[],
params:
[["func",[["function",
["Function to apply."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of function."]]]]],
src:
"bd/lang",
loc: [196,0,207,3],
module:"bd/lang"}
,"bd.delegate":{
type:
Tfunction,
sdoc:
["Creates a new object with given prototype and properties."],
ldoc:
[],
params:
[["prototype",[]],
["props",[]]],
src:
"bd/lang",
loc: [210,0,219,3],
module:"bd/lang"}
,"bd.extend":{
type:
Tfunction,
sdoc:
["Mixes src objects into ctor.prototype with bd.mix."],
ldoc:
[],
params:
[["ctor",[["function",
["The constructor function whos prototype is to be modified."]]]],
["src",[["object",
["The object(s) from which to take properties to mix into ctor.prototype."]]]]],
src:
"bd/lang",
loc: [221,0,229,3],
module:"bd/lang"}
,"bd.get":{
type:
Tfunction,
sdoc:
["Resolves a string into a nested property value."],
ldoc:
["Returns the property given by ```context``.``name```.  If the property is undefined\nand `defaultValue!==undefined`, then calls `bd.set(name, context, defaultValue)`."],
params:
[["name",[["jsName",
["The property to resolve."]]]],
["context",[["falsy",
["Root object for name is given by dojo.global."]],
["string",
["Root object for name is given by dojo.module(context)."]],
["otherwise",
["Root object for name."]]]],
["defaultValue",[["any, optional",
["Value to initialize the property iff it is currently undefined."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Returns the property implied by name.  "],
ldoc:
["Returns the property implied by name.  If the property is undefined\nand `defaultValue!==undefined`, then calls `bd.set(name, defaultValue)`."],
params:
[["name",[["bd.modulePropertyName",
["property to resolve"]]]],
["defaultValue",[]]],
loc: [245,6,252,7]}
],
src:
"bd/lang",
loc: [231,0,281,3],
module:"bd/lang"}
,"bd.exists":{
type:
Tfunction,
sdoc:
["Predicate: syntactic sugar for `bd.get(name, context)!==undefined`."],
ldoc:
[],
params:
[["name",[["jsName",
["The property to resolve."]]]],
["context",[["falsy",
["Root object for name is given by dojo.global."]],
["string",
["Root object for name is given by dojo.module(context)."]],
["otherwise",
["Root object for name."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Predicate: syntactic sugar for `bd.get(name)==undefined`."],
ldoc:
[],
params:
[["name",[["bd.modulePropertyName",
["property to resolve"]]]]],
loc: [293,6,298,7]}
],
src:
"bd/lang",
loc: [283,0,301,3],
module:"bd/lang"}
,"bd.set":{
type:
Tfunction,
sdoc:
["Sets to value of the property given by ```context``.``name``` to value.  "],
ldoc:
["Sets to value of the property given by ```context``.``name``` to value.  If the\nproperty is undefined, then create the implied chain of objects.",
[WARN,"If a module is implied by providing a string for context and that module does not exist,\nthen the function asserts failure and returns undefined (this function cannot create\na non-existing module)."]],
params:
[["name",[["jsName",
["The property to resolve."]]]],
["context",[["falsy",
["Root object for name is given by dojo.global."]],
["string",
["Root object for name is given by dojo.module(context)."]],
["otherwise",
["Root object for name."]]]],
["value",[["any",
["Value to set."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Sets to value of the property implied by name to value.  "],
ldoc:
["Sets to value of the property implied by name to value.  If the\nproperty is undefined, then create the implied chain of objects.",
[WARN,"If the implied module does not exist, then the function asserts\nfailure and returns undefined (this function cannot create a non-existing module)."]],
params:
[["name",[["bd.modulePropertyName",
["property to resolve"]]]],
["value",[]]],
loc: [319,6,329,7]}
],
src:
"bd/lang",
loc: [303,0,356,3],
module:"bd/lang"}
,"bd.hijack":{
type:
Tfunction,
sdoc:
["Replaces context[functionName] with highjacker. "],
ldoc:
["Replaces context[functionName] with highjacker. If chain is true, then the context[functionName] is\ncalled with original arguments (if any) immediately after hijacker returns.",
"Returns a handle to restore context[functionName] to its original value with overloaded signature to bd.hijack."],
params:
[["context",[["object",
["The object that contains the function to hijack."]]]],
["functionName",[["string",
["The name of the function to hijack."]]]],
["hijacker",[["function",
["The replacement function."]]]],
["hijackerContext",[["object, optional, 0",
["The context in which to call hijacker; falsy implies bd.global"]]]],
["chain",[["boolean, optional, false",
["Call the original function automatically after the hijacker finishes."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Restores a hijacked function to its prior state."],
ldoc:
[],
params:
[["handle",[["bd.hijack.handle",
["A result returned by bd.hijack when a hijack was installed."]]]]],
loc: [372,6,377,7]}
],
src:
"bd/lang",
loc: [358,0,402,3],
module:"bd/lang"}
,"modules.bd/lang":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with several functions that provide basic JavaScript language features."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load the module bd. See module.bd."]],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/lang",
loc: [0,0,404,2]}
,"resources.bd/mouse":{
type:
Tresource,
sdoc:
["Defines the module bd/mouse"],
src:
"bd/mouse",
modules:
["bd/mouse"],
docLocs:
[[130,152]],
code:
["dojo.def(\"bd/mouse\", [",
"  \"dojo\", \"bd\",",
"  \"bd/collections\"",
"], function(dojo, bd) {",
"///",
"// Augments the bd namespace with mouse capture machinery.",
"",
"bd.mouse= ",
"  ///namespace ",
"  // Contains the mouse capture/release machinery.",
"  bd.mouse || {};",
"",
"var",
"  doc= document,",
"  events= {mousedown:0, mouseup:0, mousemove:0, mouseover:0, mouseout:0, click:0, dblclick:0, blur:0},",
"  registeredHandlers= null,",
"  onReleaseAdvise= 0,",
"  registerHandlers,",
"  removeHandlers;",
"",
"if (doc.addEventListener) {",
"  //normal case...",
"  registerHandlers= function(",
"    handlers,",
"    registeredHandlers",
"  ){",
"    var createHandler= function(handler, blur) {",
"      return function(e) {",
"        if (handler) {",
"          handler(e);",
"        }",
"        if (blur) {",
"          bd.mouse.release();",
"        } else {",
"          e.preventDefault();",
"        }",
"        e.stopPropagation();",
"      };",
"    };",
"    bd.forEachHash(dojo.mix({}, events, handlers), function(handler, event) {",
"      registeredHandlers[event]= createHandler(handler, event==\"blur\");",
"      doc.addEventListener(event, registeredHandlers[event], true);",
"    });",
"  };",
"",
"  removeHandlers= function(handlers){",
"    bd.forEachHash(handlers, function(handler, event) {",
"      doc.removeEventListener(event, handler, true);",
"    });",
"  };",
"} else if (doc.attachEvent) {",
"  //IE...",
"  registerHandlers= function(",
"    handlers,",
"    registeredHandlers",
"  ){",
"    var createHandler= function(handler, blur) {",
"      return function() {",
"        var e= dojo._event_listener._fixEvent(window.event);",
"        if (handler) {",
"          handler(e);",
"        }",
"        if (blur) {",
"          bd.mouse.release();",
"        } else {",
"          e.preventDefault();",
"        }",
"        e.stopPropagation();",
"      };",
"    };",
"",
"    var element= doc.body;",
"    element.setCapture();",
"    bd.forEachHash(dojo.mix({}, events, handlers), function(handler, event) {",
"      var registeredEvent= event==\"blur\" ? \"onlosecapture\" : \"on\" + event;",
"      registeredHandlers[registeredEvent]= createHandler(handler, event==\"blur\");",
"      element.attachEvent(registeredEvent, registeredHandlers[registeredEvent]);",
"    });",
"  };",
"",
"  removeHandlers= function(handlers){",
"    var element= doc.body;",
"    bd.forEachHash(handlers, function(handler, event) {",
"      element.detachEvent(event, handler);",
"    });",
"    element.releaseCapture();",
"  };",
"} else {",
"  //TODO: warning and/or exception",
"}",
"",
"bd.mouse.capture= function(",
"  by,            ///(any) The objet that captured the mouse.",
"  handlers,      ///(bd.mouse.handlerHash) The set of events and their handlers to capture.",
"  releaseAdvise  ///(function(), optional) The function to call when the capture is released.",
"){",
"  ///",
"  // Captures the mouse. //Upon return, all mouse events cause any associated handler in handlers to be executed. The event object",
"  // is automatically instructed to prevent default processing and stop propagation.",
"  //",
"  // At a minimum, the mousedown, mouseup, mousemove, mouseover, mouseout, click, dblclick, and blur events are captured; other",
"  // events may be captured if specified in handlers.",
"  // ",
"  // handlers need not be completely filled with all events mentioned above. For example, if the capture client",
"  // has no need to process the mouseover event, then that entry can be set to falsy or be left missing from the hash.",
"  // The capture machinery will still connect to this event, stop default processing, stop propagation, and then",
"  // simply return rather then calling a client-provided handler.",
"  //",
"  // Upon reception of a blur event or execution of bd.mouse.release, the capture is released and releaseAdvise (if any) is called.",
"  // Attempts to call bd.mouse.capture without a subsequent release are ignored.",
"  //",
"  //return",
"  //(true) The mouse was successfully captured.",
"  //(false) The mouse is already captured.",
"",
"  if (registeredHandlers) {",
"    //only one capture at a time...",
"    return false;",
"  }",
"",
"  //doc and onReleaseAdvise persist during the capture lifetime",
"  doc= document;",
"  onReleaseAdvise= releaseAdvise;",
"  registeredHandlers= {};",
"  registerHandlers(handlers, registeredHandlers);",
"  bd.mouse.capture.by= by;",
"  dojo.publish(\"bd/mouse/captured\", [by]);",
"  return true;",
"};",
"",
"bd.docGen(\"bd.mouse\", {",
"  handlerHash:",
"    ///type",
"    // A hash of event names to event handlers.  //For example,",
"    // in order to process each mousemove event, the following bd.mouse.handlerHash",
"    // could be provided:",
"    // ",
"    //code",
"    // {",
"    //   mousemove: function(e) {",
"    //     //do something interesting",
"    //   }",
"    // }",
"    ///",
"    // Note that e.preventDefault() and e.stopPropagation() are automatically called by",
"    // the capture machinery on each event (see bd.mouse.capture).",
"    // ",
"    // These events are triggered according to standard DOM semantics.",
"    // ",
"    // When called, any provided handler function will be passed an event object as normalized by dojo (i.e.,",
"    // it looks like a standards-based event object even if IE happens to be the browser).",
"    {}",
"});",
"",
"bd.mouse.release= function() {",
"  ///",
"  // Releases the current capture and restores execution of other mouse handlers. //See bd.mouse.capture",
"",
"  //guard against client recursion",
"  if (!registeredHandlers) {",
"    return;",
"  }",
"",
"  removeHandlers(registeredHandlers);",
"  registeredHandlers= null;",
"  bd.mouse.capture.by= null;",
"  dojo.publish(\"bd/mouse/released\");",
"",
"  if (onReleaseAdvise) {",
"    // just in case onReleaseAdvise throws...",
"    var temp= onReleaseAdvise;",
"    onReleaseAdvise= 0;",
"    temp();",
"  }",
"};",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.mouse":{
type:
Tnamespace,
sdoc:
["Contains the mouse capture/release machinery."],
ldoc:
[],
src:
"bd/mouse",
loc: [7,0,10,16],
module:"bd/mouse"}
,"bd.mouse.capture":{
type:
Tfunction,
sdoc:
["Captures the mouse. "],
ldoc:
["Captures the mouse. Upon return, all mouse events cause any associated handler in handlers to be executed. The event object\nis automatically instructed to prevent default processing and stop propagation.\n\nAt a minimum, the mousedown, mouseup, mousemove, mouseover, mouseout, click, dblclick, and blur events are captured; other\nevents may be captured if specified in handlers.\n\nhandlers need not be completely filled with all events mentioned above. For example, if the capture client\nhas no need to process the mouseover event, then that entry can be set to falsy or be left missing from the hash.\nThe capture machinery will still connect to this event, stop default processing, stop propagation, and then\nsimply return rather then calling a client-provided handler.\n\nUpon reception of a blur event or execution of bd.mouse.release, the capture is released and releaseAdvise (if any) is called.\nAttempts to call bd.mouse.capture without a subsequent release are ignored."],
params:
[["by",[["any",
["The objet that captured the mouse."]]]],
["handlers",[["bd.mouse.handlerHash",
["The set of events and their handlers to capture."]]]],
["releaseAdvise",[["function(), optional",
["The function to call when the capture is released."]]]]],
returns:
[["true",
["The mouse was successfully captured."]],
["false",
["The mouse is already captured."]]],
src:
"bd/mouse",
loc: [91,0,128,1],
module:"bd/mouse"}
,"bd.mouse.handlerHash":{
type:
Ttype,
sdoc:
["A hash of event names to event handlers.  "],
ldoc:
["A hash of event names to event handlers.  For example,\nin order to process each mousemove event, the following bd.mouse.handlerHash\ncould be provided:",
[CODE,"{\n  mousemove: function(e) {\n    //do something interesting\n  }\n}"],
"Note that e.preventDefault() and e.stopPropagation() are automatically called by\nthe capture machinery on each event (see bd.mouse.capture).\n\nThese events are triggered according to standard DOM semantics.\n\nWhen called, any provided handler function will be passed an event object as normalized by dojo (i.e.,\nit looks like a standards-based event object even if IE happens to be the browser)."],
src:
"bd/mouse",
loc: [131,2,151,6],
module:"bd/mouse"}
,"bd.mouse.release":{
type:
Tfunction,
sdoc:
["Releases the current capture and restores execution of other mouse handlers. "],
ldoc:
["Releases the current capture and restores execution of other mouse handlers. See bd.mouse.capture"],
src:
"bd/mouse",
loc: [154,0,174,1],
module:"bd/mouse"}
,"modules.bd/mouse":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with mouse capture machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/mouse",
loc: [0,0,176,2]}
,"resources.bd/mouseable":{
type:
Tresource,
sdoc:
["Defines the module bd/mouseable"],
src:
"bd/mouseable",
modules:
["bd/mouseable"],
code:
["dojo.def(\"bd/mouseable\", [",
"  \"bd\", ",
"  \"dojo\",",
"  \"bd/interactive\",",
"  \"bd/async\", ",
"  \"dojo/window\"",
"], function(bd, dojo) {",
"///",
"// Defines the bd.mouseable class.",
"",
"bd.declare(",
"  ///",
"  // Mixin class for objects that interact with the mouse. //Defines the attributes `hover`",
"  // `mouseDown`, and `active` as well as connection points for all DOM mouse events.",
"  //",
"  // The implementation watches the Backdraft global capture state as well",
"  // as the `disabled` attribute (if any), thereby preventing mouse feedback when another object has ",
"  // captured the mouse or when the instance is disabled. If the `disabled` attribute is toggled",
"  // true while the mouse is hovering, down, and/or active, then all of these states are unconditionally",
"  // and automatically set false upon detection.",
"  //",
"  //warn",
"  // This class assumes it will be mixed with bd.connectable for connection handle management.",
"",
"  //class name",
"  \"bd:mouseable\",",
"",
"  //superclasses",
"  [bd.interactive],",
"",
"  //members",
"  bd.makeDeferredConnects(",
"    ///",
"    // Declares connection points.",
"    //note",
"    // These will almost always be redefined in leaf classes.",
"    {",
"    onClick:[\"click\", \"domNode\"],",
"    onDblClick:[\"dblclick\", \"domNode\"],",
"    onMouseMove:[\"mousemove\", \"domNode\"],",
"    onMouseDown:[\"mousedown\", \"domNode\"],",
"    onMouseOut:[\"mouseout\", \"domNode\"],",
"    onMouseOver:[\"mouseover\", \"domNode\"],",
"    onMouseLeave:[\"mouseleave\", \"domNode\"],",
"    onMouseEnter:[\"mouseenter\", \"domNode\"],",
"    onMouseUp:[\"mouseup\", \"domNode\"]",
"  }),",
"",
"  bd.constAttr(",
"    ///",
"    //(boolean) true if the mouse is over this widget; false otherwise.",
"    ///",
"    // Returns true if the mouse is currently over the DOM subtree defined by this object. //By default, the subtree",
"    // is rooted at `this.domNode`; however, this can be controlled through the deferredConnects property.",
"",
"    \"hover\", false",
"  ),",
"",
"  bd.constAttr(",
"    ///",
"    //(boolean) true if a mouse button was pressed while over this widget; false otherwise.",
"    ///",
"    // Returns true if a mouse button is depressed with the mouse currently over the DOM subtree defined by this object. //By default, the subtree",
"    // is rooted at `this.domNode`; however, this can be controlled through the deferredConnects property.",
"",
"    \"mouseDown\", false",
"  ),",
"",
"  bd.constAttr(",
"    ///",
"    //(boolean) true if the mouse is over this widget and a mouse button is pressed; false otherwise.",
"    ///",
"    // Returns true if the mouse is currently over the DOM subtree defined by this object and a mouse button is depressed. //By default, the subtree",
"    // is rooted at `this.domNode`; however, this can be controlled through the deferredConnects property.",
"",
"    \"active\", false",
"  ),",
"",
"  {",
"    mouseableMouseupHandle: 0,",
"",
"    precreateDom: function() {",
"      ///",
"      // Initializes watchers for the Backdraft global capture state and this object\'s disabled attribute.",
"      this.inherited(arguments);",
"      bd.subscribe(\"bd/mouse/captured\", \"onMouseCapture\", this);",
"      this.watch(\"disabled\", function(value) {",
"        !value && this.resetMouseState();",
"      }, this);     ",
"    },",
"",
"    resetMouseState: function() {",
"      ///",
"      // Unconditionally sets the `hover`, `active`, and `mouseDown` attributes false.",
"      this.set(\"hover\", false);",
"      this.set(\"active\", false);",
"      this.set(\"mouseDown\", false);",
"      this.mouseableMouseupHandle && this.mouseableMouseupHandle.disconnect() && (this.mouseableMouseupHandle= 0);",
"    },",
"   ",
"    onMouseCapture: function(",
"      by ///(any) The object that captured th mouse",
"    ) {",
"      ///",
"      // Triggered when any object captures the mouse via the Backdraft capture machinery (see bd.mouse).",
"      // `connectionPoint",
"      by!==this && this.resetMouseState();",
"    },",
"",
"    onMouseDown: function(",
"      e ///(DOM event object) The event object associated with the mousedown DOM event.",
"    ) {",
"      ///",
"      // Triggered when mousedown event is detected on the DOM subtree controlled by this object. //Sets the `active`",
"      // and `mouseDown` attributes to true iff this object is not disabled.",
"      // `connectionPoint",
"      if (!this.get(\"disabled\")) {",
"        this.set(\"active\", true);",
"        this.set(\"mouseDown\", true);",
"        this.mouseableMouseupHandle= bd.connect(bd.body, \"onmouseup\", \"onMouseUp\", this);",
"      }",
"    },",
"",
"    onMouseUp: function(",
"      e ///(DOM event object) The event object associated with the mouseup DOM event.",
"    ) {",
"      ///",
"      // Triggered when mouseup event is detected on the DOM subtree controlled by this object. //Sets the `active`",
"      // and `mouseDown` attributes to false.",
"      // `connectionPoint",
"      if (!this.get(\"disabled\")) {",
"        this.set(\"active\", false);",
"        this.set(\"mouseDown\", false);",
"        this.mouseableMouseupHandle && this.mouseableMouseupHandle.disconnect() && (this.mouseableMouseupHandle= 0);",
"      }",
"    } ,",
"",
"    onMouseOver: function(",
"      e ///(DOM event object) The event object associated with the mouseover DOM event.",
"    ) {",
"      ///",
"      // Triggered when mouseover event is detected on the DOM subtree controlled by this object. //Sets the `hover`",
"      // attribute to true iff this object is not disabled.",
"      // `connectionPoint",
"      if (!this.get(\"disabled\")) {",
"        this.set(\"hover\", true);",
"      }",
"    },",
"",
"    onMouseOut: function(",
"      e ///(DOM event object) The event object associated with the mouseout DOM event.",
"    ) {",
"      ///",
"      // Triggered when mouseout event is detected on the DOM subtree controlled by this object. //Sets the `hover`",
"      // and `active` attributes to false.",
"      // `connectionPoint",
"      if (!this.get(\"disabled\")) {",
"        this.set(\"hover\", false);",
"        this.set(\"active\", false);",
"      }",
"    },",
"",
"    onMouseEnter: function(",
"      e ///(DOM event object) The event object associated with the mouseenter DOM event.",
"    ) {",
"      ///",
"      // Clients chould not connect to this event; connect to the onMouseOver event instead.",
"      // `connectionPoint",
"      // `private",
"      this.onMouseOver(e);",
"    },",
"",
"    onMouseLeave: function(",
"      e ///(DOM event object) The event object associated with the mouseleave DOM event.",
"    ) {",
"      ///",
"      // Clients chould not connect to this event; connect to the onMouseOut event instead.",
"      // `connectionPoint",
"      // `private",
"      this.onMouseOut(e);",
"    },",
"",
"    hoverSet: function(",
"      value",
"    ) {",
"      // private; not defined using bd.attr since this attribute is settable only via this class\'s internal machinery.",
"      var oldValue= this.value;",
"      value!=oldValue && (this.hover= value);",
"      return oldValue;",
"    },",
"",
"    mouseDownSet: function(",
"      value",
"    ) {",
"      // private; not defined using bd.attr since this attribute is settable only via this class\'s internal machinery.",
"      var oldValue= this.value;",
"      value!=oldValue && (this.mouseDown= value);",
"      return oldValue;",
"    },",
"",
"    activeSet: function(",
"      value",
"    ) {",
"      // private; not defined using bd.attr since this attribute is settable only via this class\'s internal machinery.",
"      var oldValue= this.value;",
"      value!=oldValue && (this.active= value);",
"      return oldValue;",
"    }",
"  }",
");",
"",
"});"]}
,"bd.mouseable":{
type:
Tclass,
sdoc:
["Mixin class for objects that interact with the mouse. "],
ldoc:
["Mixin class for objects that interact with the mouse. Defines the attributes `hover`\n`mouseDown`, and `active` as well as connection points for all DOM mouse events.\n\nThe implementation watches the Backdraft global capture state as well\nas the `disabled` attribute (if any), thereby preventing mouse feedback when another object has\ncaptured the mouse or when the instance is disabled. If the `disabled` attribute is toggled\ntrue while the mouse is hovering, down, and/or active, then all of these states are unconditionally\nand automatically set false upon detection.",
[WARN,"This class assumes it will be mixed with bd.connectable for connection handle management."]],
src:
"bd/mouseable",
loc: [10,0,209,1],
supers:
["bd.interactive"],
module:"bd/mouseable"}
,"bd.mouseable.active":{
type:
Tvariable,
sdoc:
["Returns true if the mouse is currently over the DOM subtree defined by this object and a mouse button is depressed. "],
imember:1,
ldoc:
["Returns true if the mouse is currently over the DOM subtree defined by this object and a mouse button is depressed. By default, the subtree\nis rooted at `this.domNode`; however, this can be controlled through the deferredConnects property."],
flags:
[Froattr],
loc: [68,2,76,3],
types:
[["boolean",
["true if the mouse is over this widget and a mouse button is pressed; false otherwise."]]]}
,"bd.mouseable.mouseDown":{
type:
Tvariable,
sdoc:
["Returns true if a mouse button is depressed with the mouse currently over the DOM subtree defined by this object. "],
imember:1,
ldoc:
["Returns true if a mouse button is depressed with the mouse currently over the DOM subtree defined by this object. By default, the subtree\nis rooted at `this.domNode`; however, this can be controlled through the deferredConnects property."],
flags:
[Froattr],
loc: [58,2,66,3],
types:
[["boolean",
["true if a mouse button was pressed while over this widget; false otherwise."]]]}
,"bd.mouseable.hover":{
type:
Tvariable,
sdoc:
["Returns true if the mouse is currently over the DOM subtree defined by this object. "],
imember:1,
ldoc:
["Returns true if the mouse is currently over the DOM subtree defined by this object. By default, the subtree\nis rooted at `this.domNode`; however, this can be controlled through the deferredConnects property."],
flags:
[Froattr],
loc: [48,2,56,3],
types:
[["boolean",
["true if the mouse is over this widget; false otherwise."]]]}
,"bd.mouseable.deferredConnects":{
type:
Tvariable,
sdoc:
["Declares connection points."],
imember:1,
ldoc:
[[NOTE,"These will almost always be redefined in leaf classes."]],
loc: [31,2,46,4]}
,"bd.mouseable.precreateDom":{
type:
Tfunction,
sdoc:
["Initializes watchers for the Backdraft global capture state and this object\'s disabled attribute."],
imember:1,
ldoc:
[],
loc: [81,4,89,5]}
,"bd.mouseable.resetMouseState":{
type:
Tfunction,
sdoc:
["Unconditionally sets the `hover`, `active`, and `mouseDown` attributes false."],
imember:1,
ldoc:
[],
loc: [91,4,98,5]}
,"bd.mouseable.onMouseCapture":{
type:
Tfunction,
sdoc:
["Triggered when any object captures the mouse via the Backdraft capture machinery (see bd.mouse).\n`connectionPoint"],
imember:1,
ldoc:
[],
params:
[["by",[["any",
["The object that captured th mouse"]]]]],
loc: [100,4,107,5]}
,"bd.mouseable.onMouseDown":{
type:
Tfunction,
sdoc:
["Triggered when mousedown event is detected on the DOM subtree controlled by this object. "],
imember:1,
ldoc:
["Triggered when mousedown event is detected on the DOM subtree controlled by this object. Sets the `active`\nand `mouseDown` attributes to true iff this object is not disabled.\n`connectionPoint"],
params:
[["e",[["DOM event object",
["The event object associated with the mousedown DOM event."]]]]],
loc: [109,4,121,5]}
,"bd.mouseable.onMouseUp":{
type:
Tfunction,
sdoc:
["Triggered when mouseup event is detected on the DOM subtree controlled by this object. "],
imember:1,
ldoc:
["Triggered when mouseup event is detected on the DOM subtree controlled by this object. Sets the `active`\nand `mouseDown` attributes to false.\n`connectionPoint"],
params:
[["e",[["DOM event object",
["The event object associated with the mouseup DOM event."]]]]],
loc: [123,4,135,5]}
,"bd.mouseable.onMouseOver":{
type:
Tfunction,
sdoc:
["Triggered when mouseover event is detected on the DOM subtree controlled by this object. "],
imember:1,
ldoc:
["Triggered when mouseover event is detected on the DOM subtree controlled by this object. Sets the `hover`\nattribute to true iff this object is not disabled.\n`connectionPoint"],
params:
[["e",[["DOM event object",
["The event object associated with the mouseover DOM event."]]]]],
loc: [137,4,147,5]}
,"bd.mouseable.onMouseOut":{
type:
Tfunction,
sdoc:
["Triggered when mouseout event is detected on the DOM subtree controlled by this object. "],
imember:1,
ldoc:
["Triggered when mouseout event is detected on the DOM subtree controlled by this object. Sets the `hover`\nand `active` attributes to false.\n`connectionPoint"],
params:
[["e",[["DOM event object",
["The event object associated with the mouseout DOM event."]]]]],
loc: [149,4,160,5]}
,"bd.mouseable.onMouseEnter":{
type:
Tfunction,
sdoc:
["Clients chould not connect to this event; connect to the onMouseOver event instead.\n`connectionPoint"],
imember:1,
ldoc:
[],
flags:
[Fprivate],
params:
[["e",[["DOM event object",
["The event object associated with the mouseenter DOM event."]]]]],
loc: [162,4,170,5]}
,"bd.mouseable.onMouseLeave":{
type:
Tfunction,
sdoc:
["Clients chould not connect to this event; connect to the onMouseOut event instead.\n`connectionPoint"],
imember:1,
ldoc:
[],
flags:
[Fprivate],
params:
[["e",[["DOM event object",
["The event object associated with the mouseleave DOM event."]]]]],
loc: [172,4,180,5]}
,"modules.bd/mouseable":{
type:
Tmodule,
sdoc:
["Defines the bd.mouseable class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/mouseable",
loc: [0,0,211,2]}
,"resources.bd/namespace":{
type:
Tresource,
sdoc:
["Defines the module bd/namespace"],
src:
"bd/namespace",
modules:
["bd/namespace"],
docLocs:
[[6,44]],
code:
["dojo.def(\"bd/namespace\", [",
"  \"dojo\", \"bd\"",
"], function(dojo, bd) {",
"///",
"// Augments the bd namespace with the bd.namespace class.",
"",
"bd.docGen(\"bd.namespace\", {",
"  creator: ",
"    function(",
"      name,  ///(string) The name of the object to add to the namespace.",
"      value  ///(any) The object to add to the namespace.",
"    ) {",
"      ///type",
"      // A function used by a namespace instance to add new objects to the namespace. // The",
"      // function should add a new object by executing the statement",
"      //",
"      //c this._hash[<name>]= <value>;",
"      ///",
"      // The function is passed arguments provided to namespace.add (and namespace.get iff autocreate is true).",
"      // name is guaranteed to be at arguments[0], but other arguments may exist as the caller provides",
"      // them according to the semantics of creator. The default implementation simply executes",
"      //",
"      //c this._hash[name]= arguments[1]\"",
"      ///",
"      // with arguments as given to add or get.",
"    },",
"  ",
"  proc:",
"    function(",
"      name, ///(string) The name associated with value.",
"      value ///(any) An object stored in the namespace at name.  ",
"    ) {",
"      ///type",
"      //sematics as required by client code",
"    },",
"",
"  predicate:",
"    function(",
"      name, ///(string) The name associated with value.",
"      value ///(any) An object stored in the namespace at name.  ",
"    ) {",
"      ///type",
"      //sematics return true if (name, value) satisfies the predicate as required by client code",
"    }",
"});",
"",
"bd.declare(",
"  ///",
"  // Implements a dynamic namespace that allows associating names with some value or reference.",
"  ///",
"  // The key differences between bd.namespace and a standard JavaScript object are as follows:",
"  // ",
"  //   * The ability to define a specialized function that adds names to the namespace and",
"  //     further guaranteeing that this function is executed to cause any name to be added.",
"  //   * The ability to connect to insert/delete/lookup events.",
"",
"  //class name",
"  \"bd:namespace\", ",
"",
"  //superclasses",
"  [], ",
"",
"  //members",
"  {",
"  constructor: function(",
"    creator,   ///(bd.namespace.creator, optional) called when a new object is added to the namespace.",
"    autocreate ///(bool, optional, false) if true, then automatically create an object if lookup fails using the creator function.",
"  ){",
"    ///",
"    // Create a new instance. //If creator is not found, then the following default is used:",
"    //code",
"    // function(name, value) {",
"    //   this._hash[name]= value;",
"    //   return value;",
"    // };",
"    this._hash={};",
"    this.creator= creator || function(name, value) {",
"      this._hash[name]= value;",
"      return value;",
"    };",
"    this.autocreate= !!autocreate;",
"  },",
"",
"  set: function(",
"    name, ///(string) The name to add to the namespace",
"    vargs   ///(any*) Arguments as required by the creator",
"  ) {",
"    ///",
"    // Add an object to the namespace.",
"    //return",
"    //(bd.namespace) The namespace object (this)",
"    this.creator.apply(this, arguments);",
"    return this;",
"  },",
"",
"  del: function(",
"    name ///(string) The name to delete from the namespace",
"  ){",
"    ///",
"    // Delete an object from the namespace.",
"    //return",
"    //(any) The object deleted from the namespace.",
"    var result= this._hash[name];",
"    delete this._hash[name];",
"    return result;",
"  },",
"",
"  get: function(",
"    name ///(string) The name to resolve",
"  ) {",
"    ///",
"    // Lookup and return a member of the namespace.",
"    //return",
"    //(any) The object associated with name.",
"    var result= this._hash[name];",
"    if (result===undefined && this.autocreate) {",
"      result= this._hash[name]= this.creator.apply(this, arguments);",
"    }",
"    return result;",
"  },",
"",
"  forEach: function(",
"    proc,   ///(bd.namespace.proc) Function to execute.",
"            //(string) Function to execute is given by context[function].",
"    context ///(object, optional, dojo.global) Context in which to execute function.",
"  ) {",
"    ///",
"    // Apply proc to each (name,  object) in the namespace.",
"    context= context || dojo.global;",
"    if (dojo.isString(proc)) {",
"      proc= context[proc];",
"    }",
"    var hash= this._hash;",
"    for (var name in hash) {",
"      proc.call(context, name, hash[name]);",
"    }",
"  },",
"",
"  filter: function(",
"    filter, ///(bd.namespace.predicate) Predicate function.",
"            //(string) Predicate function is given by context[function].",
"    context ///(object, optional, dojo.global) Context in which to execute function.",
"  ) {",
"    ///",
"    // Create a new namespace containing only the objects in the current namespace that satisfy the filter predicate.",
"    context= context || dojo.global;",
"    if (dojo.isString(filter)) {",
"      filter= context[filter];",
"    }",
"    var",
"      result= new bd.namespace(this.creator, this.autocreate),",
"      thisHash= this._hash,",
"      resultHash= result._hash;",
"    for (var name in thisHash) {",
"      if (filter.call(context, name, thisHash[name])) {",
"	      resultHash[name]= thisHash[name];",
"      }",
"    }",
"    return result;",
"  }",
"});",
"",
"//TODO change the signatures of forEach and filter to the standard Backdraft callback signatures",
"",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.namespace.creator":{
type:
Ttype,
sdoc:
["A function used by a namespace instance to add new objects to the namespace. "],
ldoc:
["A function used by a namespace instance to add new objects to the namespace.  The\nfunction should add a new object by executing the statement",
[CODE,"this._hash[<name>]= <value>;"],
"The function is passed arguments provided to namespace.add (and namespace.get iff autocreate is true).\nname is guaranteed to be at arguments[0], but other arguments may exist as the caller provides\nthem according to the semantics of creator. The default implementation simply executes",
[CODE,"this._hash[name]= arguments[1]\""],
"with arguments as given to add or get."],
flags:
[Ffunction],
params:
[["name",[["string",
["The name of the object to add to the namespace."]]]],
["value",[["any",
["The object to add to the namespace."]]]]],
src:
"bd/namespace",
loc: [7,2,25,5],
module:"bd/namespace"}
,"bd.namespace.proc":{
type:
Ttype,
sdoc:
["sematics as required by client code"],
ldoc:
[],
flags:
[Ffunction],
params:
[["name",[["string",
["The name associated with value."]]]],
["value",[["any",
["An object stored in the namespace at name."]]]]],
src:
"bd/namespace",
loc: [27,2,34,5],
module:"bd/namespace"}
,"bd.namespace.predicate":{
type:
Ttype,
sdoc:
["sematics return true if (name, value) satisfies the predicate as required by client code"],
ldoc:
[],
flags:
[Ffunction],
params:
[["name",[["string",
["The name associated with value."]]]],
["value",[["any",
["An object stored in the namespace at name."]]]]],
src:
"bd/namespace",
loc: [36,2,43,5],
module:"bd/namespace"}
,"bd.namespace":{
type:
Tclass,
sdoc:
["Implements a dynamic namespace that allows associating names with some value or reference."],
ldoc:
["The key differences between bd.namespace and a standard JavaScript object are as follows:\n\n  * The ability to define a specialized function that adds names to the namespace and\n    further guaranteeing that this function is executed to cause any name to be added.\n  * The ability to connect to insert/delete/lookup events."],
src:
"bd/namespace",
loc: [46,0,160,2],
module:"bd/namespace"}
,"bd.namespace.constructor":{
type:
Tfunction,
sdoc:
["Create a new instance. "],
imember:1,
ldoc:
["Create a new instance. If creator is not found, then the following default is used:",
[CODE,"function(name, value) {\n  this._hash[name]= value;\n  return value;\n};"]],
params:
[["creator",[["bd.namespace.creator, optional",
["called when a new object is added to the namespace."]]]],
["autocreate",[["bool, optional, false",
["if true, then automatically create an object if lookup fails using the creator function."]]]]],
loc: [64,2,81,3]}
,"bd.namespace.set":{
type:
Tfunction,
sdoc:
["Add an object to the namespace."],
imember:1,
ldoc:
[],
params:
[["name",[["string",
["The name to add to the namespace"]]]],
["vargs",[["any*",
["Arguments as required by the creator"]]]]],
returns:
[["bd.namespace",
["The namespace object (this)"]]],
loc: [83,2,93,3]}
,"bd.namespace.del":{
type:
Tfunction,
sdoc:
["Delete an object from the namespace."],
imember:1,
ldoc:
[],
params:
[["name",[["string",
["The name to delete from the namespace"]]]]],
returns:
[["any",
["The object deleted from the namespace."]]],
loc: [95,2,105,3]}
,"bd.namespace.get":{
type:
Tfunction,
sdoc:
["Lookup and return a member of the namespace."],
imember:1,
ldoc:
[],
params:
[["name",[["string",
["The name to resolve"]]]]],
returns:
[["any",
["The object associated with name."]]],
loc: [107,2,119,3]}
,"bd.namespace.forEach":{
type:
Tfunction,
sdoc:
["Apply proc to each (name,  object) in the namespace."],
imember:1,
ldoc:
[],
params:
[["proc",[["bd.namespace.proc",
["Function to execute."]],
["string",
["Function to execute is given by context[function]."]]]],
["context",[["object, optional, dojo.global",
["Context in which to execute function."]]]]],
loc: [121,2,136,3]}
,"bd.namespace.filter":{
type:
Tfunction,
sdoc:
["Create a new namespace containing only the objects in the current namespace that satisfy the filter predicate."],
imember:1,
ldoc:
[],
params:
[["filter",[["bd.namespace.predicate",
["Predicate function."]],
["string",
["Predicate function is given by context[function]."]]]],
["context",[["object, optional, dojo.global",
["Context in which to execute function."]]]]],
loc: [138,2,159,3]}
,"modules.bd/namespace":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with the bd.namespace class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/namespace",
loc: [0,0,165,2]}
,"resources.bd/navigator":{
type:
Tresource,
sdoc:
["Defines the module bd/navigator"],
src:
"bd/navigator",
modules:
["bd/navigator"],
docLocs:
[[355,391]],
code:
["dojo.def(\"bd/navigator\", [",
"  \"bd\", ",
"  \"dijit\",",
"  \"bd/stateful\"",
"], function(bd, dijit) {",
"///",
"// Defines the class bd.navigator and associated machinery.",
"",
"bd.declare(",
"  ///",
"  // Mixin class that defines machinery for sequencing focus within a tree of container widgets.",
"  ///",
"  // This class allows sophisticated control over the movement of the focus upon reception of a navigate",
"  // command--usually consequent to pressing the tab key or other accelerators or toolbar/menu items.",
"  //",
"  // This class is intended to be mixed into classes that contain multiple children and controls the movement of the focus",
"  // between the children and the parent. The children may themselves be containers with several navigable children, just as the",
"  // parent may contain multiple containers with navigable children that are siblings of an instance of this class.",
"  //",
"  // The default algorithm as provided in bd.navigator.navigate attempts to find a child to which to pass the focus given a navigation command and",
"  // the current state. If such a child is found, and that child is also a bd.navigator, then further processing is delegated to that",
"  // child object; otherwise, focus is simple set to the child. If no such child is found, then processing is delegated to the parent (if any). If no",
"  // parent is found, then the trigger event may be ignored, thereby allowing the browser to navigate out of the document via default processing.",
"  // Notice in particular that this machinery allows applications to \"trap\" the focus inside the document for tab key navigation.",
"  //",
"  // Finally, the default algorithm includes several hooks where state-dependent navigation decisions can be made. For example, a common user-interface",
"  // paradigm includes a \"yes/no\" radio button followed by an \"if yes, comment\" field. The container of the radio button and comment field can choose",
"  // or skip the comment field depending on the value of the radio button.",
"  //",
"  // This class requires much of the interface defined by bd.focusable, and typically it will be mixed into classes that also mix bd.focusable. However",
"  // the design does *not* derive from bd.focusable to allow greater flexibility to class designers.",
"",
"  // class name",
"  \"bd:navigator\",",
"",
"  // superclasses",
"  [bd.focusable],",
"",
"  //members",
"  bd.constAttr(",
"    ///",
"    //(boolean) true is a child contolled by this object can recieve the focus; false otherwise.",
"    ///",
"    // Returns true if this object can receive the focus; false otherwise. //The ",
"    // calculation requires the object must be visible, not disabled, and ",
"    // have at least one child that is focusable.",
"",
"    \"focusable\", ",
"",
"    bd.noValue, // The value is always calculated, never stored.",
"",
"    function() { //getter",
"      return this.get(\"visible\") && !this.get(\"disabled\") && bd.some(this.getChildren(), function(child) { return child.get(\"focusable\"); });",
"    }",
"  ),",
"",
"//TODO: make sure the dijit widgets all include the getter focusable",
"",
"  bd.attr(",
"    ///",
"    //(bool) true if navigation should cycle within the children controlled by this navigator; false otherwise.",
"    ///",
"    // Causes the following calculations in bd.navigator.navigate:",
"    // ",
"    // * If truthy and a \"previous\" navigate command is given, cycle to the last child if currently on the first child.",
"    // * If truthy and any other navigate command is given, cycle to the first child is currently on the last child.",
"    // * Otherwise, delegate to the parent upon navigating beyond the first or last children.",
"    //",
"    // See bd.navigator.navigate.",
"    ",
"    \"cycleNavigation\", false",
"  ),",
"",
"  {",
"  lastFocused: ",
"    ///",
"    // (object) Holds the child that last had the focus (if any).",
"    null,",
"",
"  onFocus: function() {",
"    ///",
"    // Connection point for receiving the focus. //Nontrivial handler hooks up machinery to remember that last child",
"    // that had the focus and select a when the container gets the focus.",
"    if (this.focusableGet()) {",
"      //if getting the focus by clicking on the container but not the contained widget, then delegate to the contained widget...",
"      this.focusWatcher= bd.subscribe(\"widgetFocus\", function(widget) {",
"        // records this.lastFocused as widget iff widget is a child of this container.",
"        for (var children= this.getChildren(), i= children.length; i--;) {",
"          if (widget===children[i]) {",
"            this.lastFocused= widget;",
"            return;",
"          }",
"        }",
"      }, this);",
"      bd.back(dijit._activeStack)===this.id && this.navigate(bd.command.createEvent({id:\"lastFocused\"}));",
"    } else {",
"      //should never get here; ping the parent in hopes that it will take our focus away",
"      this.parent.focus();",
"    }",
"",
"",
"  },",
"",
"  onBlur: function() {",
"    // Connection for called when this DOM subtree loses the focus as triggered by the dijit focus manager.",
"    // `connectionPoint",
"    this.focusWatcher && this.focusWatcher.disconnect();",
"    this.inherited(arguments);",
"  },",
"",
"  onNavigateBefore: function(",
"    navState //(bd.navigator.eventObject) The object consequent to this navigation.",
"  ) {",
"    // Connection point to advise that a navigation move has been calculated. //`navState` may be modified",
"    // to affect the navigation; see bd.navigator.navigate.",
"  },",
"",
"  onNavigateAfter: function(",
"    navState //(bd.navigator.eventObject) The object consequent to this navigation.",
"  ) {",
"    // Connection point to advise that a navigation move has occured. //`navState` should not be modified",
"    // and will not affect the navigation; see bd.navigator.navigate.",
"  },",
"",
"  navigate: function(",
"    commandEventObject, ///(bd.command.eventObject) The command that is demanding the navigation.",
"    next                ///(object, optional, undefined) The next object to get the focus.",
"  ) {",
"    ///",
"    // Computes and executes the navigation command implied by commandEventObject, next,  and the current state of the application. //The default",
"    // algorithm is as follows:",
"    // ",
"    // 1. Initialize a bd.navigator.eventObject for use in the remaining steps.",
"    // 2. If next was not hard-set, select next via `this.selectNextActive`.",
"    // 3. If next is still undefined and cycle is true, then define next as the appropriate endpoint (see bd.navigator.cycle).",
"    // 4. If next is still undefined and an ancestor exists that is a navigator, delegate to that parent.",
"    // 5. If next is still undefined, return false to indicate the command was not handled.",
"    // 6. Otherwise, trigger the onNavigatorBeforeMove event; this event may change or cancel the navigation.",
"    // 7. Unless cancled, execute the navigation by moving the focus and trigger the onNavigatorAfterMove.",
"    //",
"",
"    // find the current child",
"    for (var p= null, lastChild= null, activeStack= dijit._activeStack, i= activeStack.length; i-- && p!==this;) {",
"      lastChild= p;",
"      p= bd.object.get(activeStack[i]);",
"    }",
"",
"    var navState= {",
"      currentChild: lastChild,",
"      currentFocusNode: dijit._curFocus,",
"      next: next,",
"      nextFocusNode: null,",
"      commandEventObject: commandEventObject,",
"      cancel: false",
"    };",
"    ",
"    if (!navState.next) {",
"      this.selectNextActive(navState);",
"    }",
"",
"    if (!navState.next &&  this.cycleNavigation) {",
"      var navCommand= commandEventObject.id;",
"      commandEventObject.id= (navCommand===\"previous\" ? \"end\" : \"home\");",
"      this.selectNextActive(navState);",
"      commandEventObject.id= navCommand;",
"    }",
"",
"    if (!navState.next) {",
"      return this.delegateNavigate(commandEventObject);",
"    }",
"",
"    this.onNavigateBefore(navState);",
"    if (navState.cancel || (navState.next===navState.currentChild && navState.nextFocusNode===navState.currentFocusNode)) {",
"      return true;",
"    }",
"",
"    navState.next.focus();",
"",
"    navState= {",
"      previous: navState.currentChild,",
"      previousFocusNode: this.currentFocusNode,",
"      current: navState.next,",
"      currentFocusNode: dijit._curFocus,",
"      commandEventObject: commandEventObject",
"    };",
"    this.onNavigateAfter(navState);",
"",
"    return true;",
"  },",
"",
"  delegateNavigate: function(",
"    commandEventObject ///(bd.command.eventObject) The command that is demanding the navigation.",
"  ) {",
"    ///",
"    // Finds an ancester that contains a `navigate` method and, if found, applies that (ancestor, method) to commandEventObject.",
"    var parent= this.parent;",
"    while (parent && !parent.navigate) {",
"      parent= parent.parent;",
"    }",
"    if (parent && parent.navigate) {",
"      return parent.navigate(commandEventObject, this);",
"    } else {",
"      return false;",
"    }",
"  },",
"",
"  selectNextActive: function(",
"    navState",
"  ) {",
"    ///",
"    // Selects the next child to get the focus given the navigate command. //The algorithm is given as follows:",
"    //",
"    // If a child controlled by the navigator currently has the focus, then,",
"    // ",
"    // 1. When the command===\"next\", select the next child according to tabIndex.",
"    // 2. When the command===\"previous\", select the previous child according to the tabIndex.",
"    // ",
"    // Otherwise,",
"    // ",
"    // 1. When the command is \"next\" or \"home\", select the child with the least tabIndex.",
"    // 2. When the command is \"previous\" or \"last\", select the child with the highest tabIndex.",
"    // ",
"    var movementCommand= navState.commandEventObject.id;",
"    if (!navState.currentChild) {",
"      //next/prev selects home/end of children when not already on a child",
"      movementCommand= movementCommand===\"next\" ? \"home\" : (movementCommand===\"previous\" ? \"end\" : movementCommand);",
"    }",
"    var f= this.selectors[movementCommand];",
"    f && f.call(this, navState);",
"  },",
"",
"  find: function(",
"    currentTabIndex,",
"    condition",
"  ) {",
"    // helper that applies condition to all children; bd.navigator.selectors.",
"    var",
"      candidateWidget= null,",
"      candidateTabIndex= null;",
"    bd.forEach(this.children, function(child) {",
"      if (child.get && child.get(\"focusable\")) {",
"        var tabIndex= child.get && child.get(\"tabIndex\");",
"        if (tabIndex && condition(currentTabIndex, candidateTabIndex, tabIndex)) {",
"          candidateTabIndex= tabIndex;",
"          candidateWidget= child;",
"        }",
"      }",
"    });",
"    return candidateWidget;",
"  },",
"",
"  selectors: {",
"    // helpers for bd.navigator.selectNextActive",
"    next: function(",
"      navState",
"    ) {",
"      if (navState.currentChild && navState.currentChild.get) {",
"	      var tabIndex= navState.currentChild.get(\"tabIndex\");",
"	      if (tabIndex) {",
"	        navState.next= this.find(tabIndex, function(currentTabIndex, candidateTabIndex, tabIndex) {",
"            return tabIndex>currentTabIndex && (!candidateTabIndex || tabIndex<candidateTabIndex);",
"          });",
"	      }",
"      }",
"      if (!navState.next && this.cycleNavigation) {",
"        this.selectors.home.call(this, navState);",
"      }",
"    },",
"",
"    previous: function(",
"      navState",
"    ) {",
"      if (navState.currentChild && navState.currentChild.get) {",
"	      var tabIndex= navState.currentChild.get(\"tabIndex\");",
"	      if (tabIndex) {",
"	        navState.next= this.find(tabIndex, function(currentTabIndex, candidateTabIndex, tabIndex) {",
"            return tabIndex<currentTabIndex && (!candidateTabIndex || tabIndex>candidateTabIndex);",
"          });",
"	      }",
"      }",
"      if (!navState.next && this.cycleNavigation) {",
"        this.selectors.end.call(this, navState);",
"      }",
"    },",
"",
"    home: function(",
"      navState",
"    ) {",
"      navState.next= this.find(Infinity, function(currentTabIndex, candidateTabIndex, tabIndex) {",
"        return tabIndex<currentTabIndex && (!candidateTabIndex || tabIndex<candidateTabIndex);",
"      });",
"    },",
"",
"    end: function(",
"      navState",
"    ) {",
"      navState.next= this.find(-1, function(currentTabIndex, candidateTabIndex, tabIndex) {",
"        return tabIndex>currentTabIndex && (!candidateTabIndex || tabIndex>candidateTabIndex);",
"      });",
"    },",
"",
"    lastFocused: function(",
"      navState",
"    ) {",
"      if (this.lastFocused) {",
"        navState.next= this.lastFocused;",
"      } else {",
"        this.selectors.home.call(this, navState);",
"      }",
"    }",
"  },",
"",
"  focus: function() {",
"    ///",
"    // Sets the focus to a child of this object iff `this.get(\"focusable\")` returns true.",
"    //warn",
"    // Focus is set asynchronously. This ensures focus will be set correctly under all circumstances",
"    // (e.g., from a blur event handler); however, the focus will not have moved before this",
"    // function returns.",
"    var candidate= this.find(Infinity, function(currentTabIndex, candidateTabIndex, tabIndex) {",
"      return tabIndex<currentTabIndex && (!candidateTabIndex || tabIndex<candidateTabIndex);",
"    });",
"    if (candidate) {",
"      candidate.focus();",
"    } else {",
"      bd.async.setFocus(this.domNode);",
"    }",
"  }",
"});",
"",
"bd.navigator.commandHandler= function(",
"  commandEventObject",
") {",
"  ///",
"  // Dispatches a navigate command to the current active object that contains the navigate method.",
"",
"  for (var currentWidget= null, activeStack= dijit._activeStack, i= activeStack.length; i--;) {",
"    currentWidget= dijit.byId(activeStack[i]);",
"    if (currentWidget.navigate) {",
"      if (currentWidget.navigate(commandEventObject)) {",
"	      commandEventObject.stopEvent= true;",
"      }",
"      return;",
"    }",
"  }",
"  if (bd.navigator.commandHandler.unconditionallyStopEvent) {",
"    commandEventObject.stopEvent= true;",
"  }",
"};",
"bd.navigator.commandHandler.unconditionallyStopEvent= ",
"  ///",
"  // Causes bd.navigator.commandHandler to unconditionally stop any navigate command. //This can be used to",
"  // prevent the focus from shifting out of the document during tab navigation.",
"  false;",
"",
"bd.docGen(\"bd.navigator\", {",
"  eventObject: {",
"    ///type",
"    // (hash) Describes the current navigation being executed.",
"    ///",
"    // This object is passed among the various functions the calculate and execute a navigation via bd.navigator.navigate.",
"    currentChild: ",
"      ///",
"      // The child the currently owns the focus.",
"      bd.nodoc,",
"",
"    currentFocusNode: ",
"      ///",
"      // The DOM node that currently owns the focus.",
"      dijit._curFocus,",
"",
"    next: ",
"      ///",
"      // The object that is calculated to get the focus next.",
"      bd.nodoc,",
"",
"    nextFocusNode:",
"      ///",
"      // The DOM node that is calculated to get the focus next.",
"      bd.nodoc,",
"",
"    commandEventObject:",
"      ///",
"      // The bd.command.eventObject that caused the navigation.",
"      bd.noDoc,",
"",
"    cancel: ",
"      ///",
"      // Indicates the navigation should be canceled and the focus remain unchanged.",
"      bd.noDoc",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.navigator":{
type:
Tclass,
sdoc:
["Mixin class that defines machinery for sequencing focus within a tree of container widgets."],
ldoc:
["This class allows sophisticated control over the movement of the focus upon reception of a navigate\ncommand--usually consequent to pressing the tab key or other accelerators or toolbar/menu items.\n\nThis class is intended to be mixed into classes that contain multiple children and controls the movement of the focus\nbetween the children and the parent. The children may themselves be containers with several navigable children, just as the\nparent may contain multiple containers with navigable children that are siblings of an instance of this class.\n\nThe default algorithm as provided in bd.navigator.navigate attempts to find a child to which to pass the focus given a navigation command and\nthe current state. If such a child is found, and that child is also a bd.navigator, then further processing is delegated to that\nchild object; otherwise, focus is simple set to the child. If no such child is found, then processing is delegated to the parent (if any). If no\nparent is found, then the trigger event may be ignored, thereby allowing the browser to navigate out of the document via default processing.\nNotice in particular that this machinery allows applications to \"trap\" the focus inside the document for tab key navigation.\n\nFinally, the default algorithm includes several hooks where state-dependent navigation decisions can be made. For example, a common user-interface\nparadigm includes a \"yes/no\" radio button followed by an \"if yes, comment\" field. The container of the radio button and comment field can choose\nor skip the comment field depending on the value of the radio button.\n\nThis class requires much of the interface defined by bd.focusable, and typically it will be mixed into classes that also mix bd.focusable. However\nthe design does *not* derive from bd.focusable to allow greater flexibility to class designers."],
src:
"bd/navigator",
loc: [8,0,328,2],
supers:
["bd.focusable"],
module:"bd/navigator"}
,"bd.navigator.cycleNavigation":{
type:
Tvariable,
sdoc:
["Causes the following calculations in bd.navigator.navigate:\n\n* If truthy and a \"previous\" navigate command is given, cycle to the last child if currently on the first child.\n* If truthy and any other navigate command is given, cycle to the first child is currently on the last child.\n* Otherwise, delegate to the parent upon navigating beyond the first or last children.\n\nSee bd.navigator.navigate."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [58,2,71,3],
types:
[["bool",
["true if navigation should cycle within the children controlled by this navigator; false otherwise."]]]}
,"bd.navigator.focusable":{
type:
Tvariable,
sdoc:
["Returns true if this object can receive the focus; false otherwise. "],
imember:1,
ldoc:
["Returns true if this object can receive the focus; false otherwise. The\ncalculation requires the object must be visible, not disabled, and\nhave at least one child that is focusable."],
flags:
[Froattr],
loc: [39,2,54,3],
types:
[["boolean",
["true is a child contolled by this object can recieve the focus; false otherwise."]]]}
,"bd.navigator.lastFocused":{
type:
Tvariable,
sdoc:
["(object) Holds the child that last had the focus (if any)."],
imember:1,
ldoc:
[],
loc: [74,2,77,8]}
,"bd.navigator.onFocus":{
type:
Tfunction,
sdoc:
["Connection point for receiving the focus. "],
imember:1,
ldoc:
["Connection point for receiving the focus. Nontrivial handler hooks up machinery to remember that last child\nthat had the focus and select a when the container gets the focus."],
loc: [79,2,101,3]}
,"bd.navigator.navigate":{
type:
Tfunction,
sdoc:
["Computes and executes the navigation command implied by commandEventObject, next,  and the current state of the application. "],
imember:1,
ldoc:
["Computes and executes the navigation command implied by commandEventObject, next,  and the current state of the application. The default\nalgorithm is as follows:\n\n1. Initialize a bd.navigator.eventObject for use in the remaining steps.\n2. If next was not hard-set, select next via `this.selectNextActive`.\n3. If next is still undefined and cycle is true, then define next as the appropriate endpoint (see bd.navigator.cycle).\n4. If next is still undefined and an ancestor exists that is a navigator, delegate to that parent.\n5. If next is still undefined, return false to indicate the command was not handled.\n6. Otherwise, trigger the onNavigatorBeforeMove event; this event may change or cancel the navigation.\n7. Unless cancled, execute the navigation by moving the focus and trigger the onNavigatorAfterMove."],
params:
[["commandEventObject",[["bd.command.eventObject",
["The command that is demanding the navigation."]]]],
["next",[["object, optional, undefined",
["The next object to get the focus."]]]]],
loc: [124,2,188,3]}
,"bd.navigator.delegateNavigate":{
type:
Tfunction,
sdoc:
["Finds an ancester that contains a `navigate` method and, if found, applies that (ancestor, method) to commandEventObject."],
imember:1,
ldoc:
[],
params:
[["commandEventObject",[["bd.command.eventObject",
["The command that is demanding the navigation."]]]]],
loc: [190,2,204,3]}
,"bd.navigator.selectNextActive":{
type:
Tfunction,
sdoc:
["Selects the next child to get the focus given the navigate command. "],
imember:1,
ldoc:
["Selects the next child to get the focus given the navigate command. The algorithm is given as follows:\n\nIf a child controlled by the navigator currently has the focus, then,\n\n1. When the command===\"next\", select the next child according to tabIndex.\n2. When the command===\"previous\", select the previous child according to the tabIndex.\n\nOtherwise,\n\n1. When the command is \"next\" or \"home\", select the child with the least tabIndex.\n2. When the command is \"previous\" or \"last\", select the child with the highest tabIndex."],
params:
[["navState",[]]],
loc: [206,2,229,3]}
,"bd.navigator.focus":{
type:
Tfunction,
sdoc:
["Sets the focus to a child of this object iff `this.get(\"focusable\")` returns true."],
imember:1,
ldoc:
[[WARN,"Focus is set asynchronously. This ensures focus will be set correctly under all circumstances\n(e.g., from a blur event handler); however, the focus will not have moved before this\nfunction returns."]],
loc: [312,2,327,3]}
,"bd.navigator.commandHandler":{
type:
Tfunction,
sdoc:
["Dispatches a navigate command to the current active object that contains the navigate method."],
ldoc:
[],
params:
[["commandEventObject",[]]],
src:
"bd/navigator",
loc: [330,0,348,1],
module:"bd/navigator"}
,"bd.navigator.commandHandler.unconditionallyStopEvent":{
type:
Tvariable,
sdoc:
["Causes bd.navigator.commandHandler to unconditionally stop any navigate command. "],
ldoc:
["Causes bd.navigator.commandHandler to unconditionally stop any navigate command. This can be used to\nprevent the focus from shifting out of the document during tab navigation."],
src:
"bd/navigator",
loc: [349,0,353,7],
module:"bd/navigator"}
,"bd.navigator.eventObject":{
type:
Ttype,
sdoc:
["(hash) Describes the current navigation being executed."],
ldoc:
["This object is passed among the various functions the calculate and execute a navigation via bd.navigator.navigate."],
props:
["currentChild",{
type:
Tvariable,
sdoc:
["The child the currently owns the focus."],
ldoc:
[],
loc: [364,6,364,14]}
,
"currentFocusNode",{
type:
Tvariable,
sdoc:
["The DOM node that currently owns the focus."],
ldoc:
[],
loc: [369,6,369,21]}
,
"next",{
type:
Tvariable,
sdoc:
["The object that is calculated to get the focus next."],
ldoc:
[],
loc: [374,6,374,14]}
,
"nextFocusNode",{
type:
Tvariable,
sdoc:
["The DOM node that is calculated to get the focus next."],
ldoc:
[],
loc: [379,6,379,14]}
,
"commandEventObject",{
type:
Tvariable,
sdoc:
["The bd.command.eventObject that caused the navigation."],
ldoc:
[],
loc: [384,6,384,14]}
,
"cancel",{
type:
Tvariable,
sdoc:
["Indicates the navigation should be canceled and the focus remain unchanged."],
ldoc:
[],
loc: [389,6,389,14]}
],
src:
"bd/navigator",
loc: [356,2,390,3],
module:"bd/navigator"}
,"modules.bd/navigator":{
type:
Tmodule,
sdoc:
["Defines the class bd.navigator and associated machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/navigator",
loc: [0,0,393,2]}
,"resources.bd/start":{
type:
Tresource,
sdoc:
["Defines the module bd/start"],
src:
"bd/start",
modules:
["bd/start"],
code:
["dojo.def(\"bd/start\", [",
"  \"dojo\", \"dijit\", \"bd/kernel\",",
"  \"bd/collections\"",
"], function(dojo, dijit, bd) {",
"///",
"// Augments the bd namespace with startup machinery.",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load the module bd. See module.bd.",
"",
"bd.queryArgs= ",
"  ///const",
"  // Parse the URL query argument and return it as a hash. //",
"  //",
"  // For example, ",
"  //code",
"  // http://somehost.com/main.htm?run=someApp.test.tests.run001&someParam=someValue",
"  ///",
"  // would return",
"  //code",
"  // {",
"  //   run: \"someApp.test.tests.run001\",",
"  //   someParam: \"someValue\"",
"  // }",
"  //",
"  (function() {",
"		var",
"      args= {},",
"      decode= decodeURIComponent;",
"    dojo.forEach(location.search.slice(1).split(\"&\"), function(item) {",
"      var result= item.match(/(\\w+)=(.+)/);",
"      if (result) {",
"        var",
"          prop= decode(result[1]),",
"          value= decode(result[2]);",
"        if (args[prop]===undefined) {",
"          args[prop]= value;",
"        } else {",
"          dojo.isArray(args[prop]) ? args[prop].push(value) : (args[prop]= [args[prop], value]);",
"        }",
"      }",
"    });",
"    return args;",
"  })();",
"",
"",
"bd.parameterArgs=",
"  ///const",
"  // Parse the URL parameters argument and return it as a hash. //",
"  //",
"  // For example, ",
"  //code",
"  // TODO",
"  ///",
"  // would return",
"  //code",
"  // {",
"  //   TODO",
"  // }",
"  ///",
"  // `warn NOT IMPLEMENTED",
"  {};",
"",
"bd.start= function(",
"  args,    ///(bd.start.kwargs, optional) Controls application startup and operation.",
"  callback ///(function(), optional) Function to apply after everything has been created.",
") {",
"  ///",
"  // Starts the application. //",
"  // ",
"  // 1. Trys to create the root widget (bd.root) if it\'s not already created as given by args.rootCreateArgs or ",
"  //    bd.config.rootCreateArgs (if either); if created, stores the result in bd.root.",
"  // ",
"  // 2. Trys to create the top widget as given by args.topCreateArgs or bd.config.topCreateArgs (if any); if created",
"  //    stores the result in bd.top.",
"  // ",
"  // 3. Publishes a function to dojo.addOnLoad that accomplishes the following:",
"  //",
"  //      1. Removes any loading message via bd.root.destroyLoadingMessage.",
"  //      2. Removes any CSS zIndex on the bd.top widget (if any) to ensure this widget is on top. This",
"  //         allows the widget to be created behind a \"curtain\" that\'s removed by the previous step if desired.",
"  //      3. Sets up machinery to manage the focus as focus shifts into and out of the program.",
"  //      4. Loads the module given by args.run (if any).",
"  //      5. Calls callback (if any).",
"  //",
"",
"  args= args || {};",
"  var",
"    root= bd.root || dijit.byId(\"root\"),",
"    rootCreateArgs= args.rootCreateArgs || bd.config.rootCreateArgs,",
"    topCreateArgs= args.topCreateArgs || bd.config.topCreateArgs,",
"    createTop= function(root) {",
"      bd.root= root;",
"      if (topCreateArgs && !bd.top) {",
"        bd.createWidget(topCreateArgs, finish);",
"      } else {",
"        finish(bd.top);",
"      }",
"    },",
"    finish= function(top) {",
"      bd.top= top;",
"      dojo.addOnLoad(function() {",
"        // remove and destroy the loading messaging; show the top window",
"        bd.root.destroyLoadingMessage && bd.root.destroyLoadingMessage();",
"        bd.top && dojo.style(bd.top.domNode, {zIndex:\"\"});",
"    ",
"        // bd programs tend to handle all tab navigation. Here we hook up to the",
"        // document blur/focus events to remember/set the focus to the proper element",
"        // when focus shifts from/to our application",
"        //",
"        // Note: this code depends on our modifications to dijit/_base/focus.js",
"        var lastFocused= null;",
"        dojo.subscribe(\"focusDocument\", function() {",
"          if (lastFocused) {",
"            lastFocused.focus();",
"          } else {",
"            bd.top.focus();",
"          }",
"        });",
"        dojo.subscribe(\"blurDocument\", function() {",
"          lastFocused= dijit._prevFocus;",
"        });",
"    ",
"        args.run && dojo.req(args.run);",
"        setTimeout(function() {callback && dojo.addOnLoad(callback);}, 0);",
"      });",
"    };",
"  if (!root && rootCreateArgs) {",
"    bd.createWidget(rootCreateArgs, createTop);",
"  } else {",
"    createTop(root);",
"  }",
"};",
"",
"bd.start.kwargs= {",
"  ///",
"  // Controls how bd.start starts the application.",
"  rootCreateArgs:",
"    ///",
"    // Create the root widget.",
"    // ",
"    //(falsy) Use bd.config.rootCreateArgs.",
"    //(bd.createWidget.kwargs) Describes how to create the root widget.",
"    undefined,",
"",
"  topCreateArgs:",
"    ///",
"    // Create a top widget.",
"    // ",
"    //(falsy) Do not attempt to create a top widget.",
"    //(bd.createWidget.kwargs) Create a widget via bd.createWidget; reference the result in bd.top.",
"    undefined",
"};",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.queryArgs":{
type:
Tconst,
sdoc:
["Parse the URL query argument and return it as a hash. "],
ldoc:
["Parse the URL query argument and return it as a hash. \n\nFor example,",
[CODE,"http://somehost.com/main.htm?run=someApp.test.tests.run001&someParam=someValue"],
"would return",
[CODE,"{\n  run: \"someApp.test.tests.run001\",\n  someParam: \"someValue\"\n}"]],
src:
"bd/start",
loc: [10,0,43,6],
module:"bd/start"}
,"bd.parameterArgs":{
type:
Tconst,
sdoc:
["Parse the URL parameters argument and return it as a hash. "],
ldoc:
["Parse the URL parameters argument and return it as a hash. \n\nFor example,",
[CODE,"TODO"],
"would return",
[CODE,"{\n  TODO\n}"],
[WARN,"NOT IMPLEMENTED"]],
src:
"bd/start",
loc: [46,0,61,4],
module:"bd/start"}
,"bd.start":{
type:
Tfunction,
sdoc:
["Starts the application. "],
ldoc:
["Starts the application. \n\n1. Trys to create the root widget (bd.root) if it\'s not already created as given by args.rootCreateArgs or\n   bd.config.rootCreateArgs (if either); if created, stores the result in bd.root.\n\n2. Trys to create the top widget as given by args.topCreateArgs or bd.config.topCreateArgs (if any); if created\n   stores the result in bd.top.\n\n3. Publishes a function to dojo.addOnLoad that accomplishes the following:\n\n     1. Removes any loading message via bd.root.destroyLoadingMessage.\n     2. Removes any CSS zIndex on the bd.top widget (if any) to ensure this widget is on top. This\n        allows the widget to be created behind a \"curtain\" that\'s removed by the previous step if desired.\n     3. Sets up machinery to manage the focus as focus shifts into and out of the program.\n     4. Loads the module given by args.run (if any).\n     5. Calls callback (if any)."],
params:
[["args",[["bd.start.kwargs, optional",
["Controls application startup and operation."]]]],
["callback",[["function(), optional",
["Function to apply after everything has been created."]]]]],
src:
"bd/start",
loc: [63,0,132,1],
module:"bd/start"}
,"bd.start.kwargs":{
type:
Ttype,
sdoc:
["Controls how bd.start starts the application."],
ldoc:
[],
props:
["rootCreateArgs",{
type:
Tvariable,
sdoc:
["Create the root widget."],
ldoc:
[],
loc: [143,4,143,13],
types:
[["falsy",
["Use bd.config.rootCreateArgs."]],
["bd.createWidget.kwargs",
["Describes how to create the root widget."]]]}
,
"topCreateArgs",{
type:
Tvariable,
sdoc:
["Create a top widget."],
ldoc:
[],
loc: [151,4,151,13],
types:
[["falsy",
["Do not attempt to create a top widget."]],
["bd.createWidget.kwargs",
["Create a widget via bd.createWidget; reference the result in bd.top."]]]}
],
src:
"bd/start",
loc: [134,0,152,1],
module:"bd/start"}
,"modules.bd/start":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with startup machinery."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load the module bd. See module.bd."]],
flags:
[Fmodule],
params:
[["dojo",[]],
["dijit",[]],
["bd",[]]],
src:
"bd/start",
loc: [0,0,154,2]}
,"resources.bd/stateful":{
type:
Tresource,
sdoc:
["Defines the module bd/stateful"],
src:
"bd/stateful",
modules:
["bd/stateful"],
docLocs:
[[78,86]],
code:
["dojo.def(\"bd/stateful\", [",
"  \"bd\", ",
"  \"bd/lang\", ",
"  \"bd/collections\", ",
"  \"bd/connect\"",
"], function(bd) {",
"///",
"// Defines the class bd.stateful and associated machinery.",
"",
"bd.declare(",
"  ///",
"  // Mixin class that provides getters and watchable setters.",
"  ///",
"  // The method bd.stateful.watch allows clients to register a callback that is applied when any or a particular",
"  // attribute value is modified. In order for this machinery to work, clients must use the bd.stateful.get",
"  // and bd.stateful.set methods instead of calling getter/setter methods directly.",
"  //note",
"  // We use the term \"attribute\" to denote some quality or aspect representable by a value defined by a class instance.",
"  // A particular attribute may be only readable, only writable (highly unusual), or both. Although an attribute is almost",
"  // always implemented as a per-instance property value, this need not be the case. For example, interactive Backdraft",
"  // widgets define the attribute \"focusable\" that indicates whether or not a particular widget instance is capable",
"  // of accepting the keyboard focus. For Backdraft widgets, focusable is a read-only property that is calculated based",
"  // on the values of other properties (e.g., visible, disabled, etc.) and there is no JavaScript property \"focusable\"",
"  // that is explicitly defined and maintained within Backdraft widget instances.",
"  //warn",
"  // Clients of a particular class inteface must access attributes through the `get` and `set` methods to make the",
"  // design work. In particular, clients should use ```some-instance``.set(``some-attribute``, ``some-new-value``)`",
"  // since calling the setter directly (e.g., ```some-instance``.``some-attribute``Set(``some-new-value``)`)",
"  // *will not* cause the watcher callbacks to be applied.",
"  /// ",
"  // For class implementators, a getter is defined by a method named ```name``Get` that returns the",
"  // current value of the attribute ```name```. Typically, the attibute is a property of the same",
"  // name, but this is not required.",
"  // ",
"  // Similarly, a setter is defined by a method named ```name``Set` that accepts a single argument, ```value```. The",
"  // methods sets the value of the attribute ```name``` as given by the argument and returns the previous ",
"  // value. Typically, operator= is used to set the new value, but this is not required and there is no ",
"  // restriction on additional semantics defined by any particular setter.",
"  // ",
"  // The helper function bd.attr and bd.constAttr are available to help define getters and",
"  // setters in bd.declare\'d classes.",
"  // ",
"  // The getter/setter methods are designed to be protected methods for use by class implementors, although",
"  // the notion of a \"protected\" method is not defined in JavaScript.",
"  ///",
"  //note",
"  // This code inspired by and derived from dojo.Stateful.",
"  //warn",
"  // The signature of the watcher callback function is different than the dojo version. Dojo passes `(name,",
"  // oldValue, newValue)` whereas Backdraft passes `(newValue, oldValue)` for named setter watchers and `(name,",
"  // newValue, oldValue)` for wildcard setter watchers.",
"",
"  //class name",
"  \"bd:stateful\",",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  {",
"  ",
"  get: function(",
"    name ///(string) The attribute name.",
"  ) {",
"    ///",
"    // Get the value of the attribute identified by name.",
"    name+= \"Get\";",
"    return this[name] && this[name]();",
"  },",
"",
"  set: function(",
"    name, ///(string) The attribute name.",
"    value ///(any) The value to set name.",
"  ) {",
"    ///",
"    // Set the value of the attribute identified by name with value and return the old value.",
"    ////",
"    // If the oldValue!==value, then all watchers watching the named attribute are applied.",
"    bd.docGen(\"overload\",",
"      function(",
"        changeSet ///(hash name --> value(any)) A set of (name, value) pairs to set.",
"      ) {",
"        ///",
"        // Syntactic sugar for `bd.forEachHash(changeSet, function(value, name) { ``instance``.set(name, value); }`.",
"        // Returns this.",
"      }",
"    );",
"    if (bd.isObject(name)) {",
"      forEachHash(name, function(value, name) { this.set(name, value); }, this);",
"      return this;",
"    } else {",
"      var oldValue= this[name + \"Set\"](value);",
"      oldValue!==bd.failed && oldValue!==value && this.adviseWatchers(name, oldValue, value);",
"      return oldValue;",
"    }",
"  },",
"",
"  has: function(",
"    name ///(string) The attribute name.",
"  ) {",
"    ///",
"    // Predicate that says if the instance has a particular property.",
"    //return",
"    //(2) The instance has a setter(which canonically implies it has a getter)",
"    //(1) The instance has a getter but no setter",
"    //(0) The instance has neither a getter nor a setter.",
"    return (this[name+\"Set\"] ? 2 : (this[name+\"Get\"] ? 1 : 0));",
"  },",
"",
"  adviseWatchers: function(",
"    name,     ///(string) Name of the attibute that changed via `set`.",
"    oldValue, ///(any) The value of the attribute before the change.",
"    newValue  ///(any) The value of the attribute after the change.",
"  ) {",
"    ///",
"    // Advises all watchers of the attribute ```name``` that it\'s value changed.",
"    var watchers= this.watchers;",
"    if (watchers) {",
"      if (watchers[name]) {",
"        bd.forEachHash(watchers[name], function(callback) {",
"          try {",
"            callback(newValue, oldValue);",
"          } catch(e) {",
"            console.error(e);",
"          }",
"        });",
"      }",
"      if (watchers[\"*\"]) {",
"        bd.forEachHash(watchers[\"*\"], function(callback) {",
"          try {",
"            callback(name, newValue, oldValue);",
"          } catch(e) {",
"            console.error(e);",
"          }",
"        });",
"      }",
"    }",
"  },",
"",
"  watch: function(",
"    name,       ///(string) The attribute name to watch; \"*\" indicates all names.",
"    callback,   ///(function) Function to apply upon change of name.",
"    context,    ///(object, optional) Context in which to apply callback.",
"    vargs       ///(variableArgs, optional) Zero or more arguments for application of callback.",
"  ) {",
"    ///",
"    // Causes callback to be applied if one (`name` is a attribute name) or all properties (`name` is \"*\") change value via",
"    // `set`.",
"    ///",
"    // As with all Backdraft functions that take a callback-like function argument, `(callback, context, vargs)`",
"    // is transformed to `bd.hitch(context, callback, arg1, arg2, ...)`.",
"    ///",
"    // Returns a bd.connect.handle that may be used to disconnect the watch. context.adviseEventWatcher is called iff it",
"    // exists. See bd.connect and bd.connect.handle for details.",
"    //",
"    //warn",
"    // watch will *not* notify any changes that are not applied via the `set` method.",
"    var ",
"      transformedCallback= bd.hitchCallback(arguments, 1),",
"      watchers= this.watchers || (this.watchers= {}),",
"      watchList= watchers[name] || (watchers[name]= {}),",
"      watchId= bd.uid();",
"    watchList[watchId]= transformedCallback;",
"    return new bd.connect.handle(this, \"watch\", context, callback, [this, name, watchId], bd.disconnectWatch);",
"  }",
"});",
"",
"bd.disconnectWatch=",
"  function(",
"    handle //([source-object, attribute-name, watch-id]) Handle returned by bd.stateful.watch.",
"  ) {",
"    // Disconnect the watch previously connected by bd.stateful.watch.",
"    var watchers= handle[0].watchers[handle[1]];",
"    delete watchers[handle[2]];",
"  };",
"",
"bd.noValue=",
"  ///const",
"  // Unique object recognized by bd.attr and bd.constAttr to say that no explicit property is defined for a particular attribute. //This implies",
"  // the attribute value will always be calculated rather then read from a property.",
"  {};",
"",
"bd.attr= function(",
"  name,         ///(string) The property name.",
"  defaultValue, ///(any) The initial value for the property.",
"  setter,       ///(function(value), optional, see description) Function that sets the property to `value` and returns the previous value.",
"  getter        ///(function(), optional, see description) Function that returns the current value of the property.",
") {",
"  ///",
"  // Creates an object that may be used with bd.declare to cause an attribute with the name `name` and associated",
"  // getter/setter functions to be defined in the prototype. //For example,",
"  //code",
"  // bd.declare(",
"  //   [],",
"  //   attr(\"x\", 0),",
"  //   attr(\"y\", 0),",
"  // );",
"  ///",
"  // Is equivalent to ",
"  //code",
"  // bd.declare(",
"  //   [],",
"  //   {",
"  //     x: 0,",
"  //     xGet: function() { return this.x; },",
"  //     xSet: function(value) { var oldValue= this.x; this.x= value; return oldValue; }",
"  //   },",
"  //   {",
"  //     y: 0,",
"  //     yGet: function() { return this.y; },",
"  //     ySet: function(value) { var oldValue= this.y; this.y= value; return oldValue; }",
"  //   }",
"  // );",
"  ///",
"  // The implementation of the setter and/or getter functions can be specified by providing setter and/or getter function",
"  // arguments. If you desire to provide a custom getter while using the default setter, provide falsy for the setter ",
"  // arguments.",
"",
"  var result= {};",
"  defaultValue!==bd.noValue && (result[name]= defaultValue);",
"  result[name + \"Get\"]= getter || function() {",
"    return this[name];",
"  };",
"  result[name + \"Set\"]= setter || function(value) {",
"    var oldValue= this[name];",
"    this[name]= value;",
"    return oldValue;",
"  };",
"  return result;",
"};",
"",
"bd.constAttr= function(",
"  name,         ///(string) The property name.",
"  defaultValue, ///(any) The initial value for the property.",
"  getter        ///(function(), optional, see description) Function that returns the current value of property.",
") {",
"  ///",
"  // Similar to bd.attr except that no setter is defined.",
"  var result= {};",
"  defaultValue!==bd.noValue && (result[name]= defaultValue);",
"  result[name + \"Get\"]= getter || function() {",
"    return this[name];",
"  };",
"  return result;",
"};",
"  ",
"});"]}
,"bd.stateful":{
type:
Tclass,
sdoc:
["Mixin class that provides getters and watchable setters."],
ldoc:
["The method bd.stateful.watch allows clients to register a callback that is applied when any or a particular\nattribute value is modified. In order for this machinery to work, clients must use the bd.stateful.get\nand bd.stateful.set methods instead of calling getter/setter methods directly.",
[NOTE,"We use the term \"attribute\" to denote some quality or aspect representable by a value defined by a class instance.\nA particular attribute may be only readable, only writable (highly unusual), or both. Although an attribute is almost\nalways implemented as a per-instance property value, this need not be the case. For example, interactive Backdraft\nwidgets define the attribute \"focusable\" that indicates whether or not a particular widget instance is capable\nof accepting the keyboard focus. For Backdraft widgets, focusable is a read-only property that is calculated based\non the values of other properties (e.g., visible, disabled, etc.) and there is no JavaScript property \"focusable\"\nthat is explicitly defined and maintained within Backdraft widget instances."],
[WARN,"Clients of a particular class inteface must access attributes through the `get` and `set` methods to make the\ndesign work. In particular, clients should use ```some-instance``.set(``some-attribute``, ``some-new-value``)`\nsince calling the setter directly (e.g., ```some-instance``.``some-attribute``Set(``some-new-value``)`)\n*will not* cause the watcher callbacks to be applied."],
"For class implementators, a getter is defined by a method named ```name``Get` that returns the\ncurrent value of the attribute ```name```. Typically, the attibute is a property of the same\nname, but this is not required.\n\nSimilarly, a setter is defined by a method named ```name``Set` that accepts a single argument, ```value```. The\nmethods sets the value of the attribute ```name``` as given by the argument and returns the previous\nvalue. Typically, operator= is used to set the new value, but this is not required and there is no\nrestriction on additional semantics defined by any particular setter.\n\nThe helper function bd.attr and bd.constAttr are available to help define getters and\nsetters in bd.declare\'d classes.\n\nThe getter/setter methods are designed to be protected methods for use by class implementors, although\nthe notion of a \"protected\" method is not defined in JavaScript.",
[NOTE,"This code inspired by and derived from dojo.Stateful."],
[WARN,"The signature of the watcher callback function is different than the dojo version. Dojo passes `(name,\noldValue, newValue)` whereas Backdraft passes `(newValue, oldValue)` for named setter watchers and `(name,\nnewValue, oldValue)` for wildcard setter watchers."]],
src:
"bd/stateful",
loc: [9,0,165,2],
module:"bd/stateful"}
,"bd.stateful.get":{
type:
Tfunction,
sdoc:
["Get the value of the attribute identified by name."],
imember:1,
ldoc:
[],
params:
[["name",[["string",
["The attribute name."]]]]],
loc: [61,2,68,3]}
,"bd.stateful.set":{
type:
Tfunction,
sdoc:
[" Set the value of the attribute identified by name with value and return the old value.\n"],
imember:1,
ldoc:
[" Set the value of the attribute identified by name with value and return the old value.\n\n If the oldValue!==value, then all watchers watching the named attribute are applied."],
params:
[["name",[["string",
["The attribute name."]]]],
["value",[["any",
["The value to set name."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Syntactic sugar for `bd.forEachHash(changeSet, function(value, name) { ``instance``.set(name, value); }`.\nReturns this."],
ldoc:
[],
params:
[["changeSet",[["hash name --> value(any)",
["A set of (name, value) pairs to set."]]]]],
loc: [79,6,85,7]}
],
loc: [70,2,95,3]}
,"bd.stateful.has":{
type:
Tfunction,
sdoc:
["Predicate that says if the instance has a particular property."],
imember:1,
ldoc:
[],
params:
[["name",[["string",
["The attribute name."]]]]],
returns:
[["2",
["The instance has a setter(which canonically implies it has a getter)"]],
["1",
["The instance has a getter but no setter"]],
["0",
["The instance has neither a getter nor a setter."]]],
loc: [97,2,107,3]}
,"bd.stateful.adviseWatchers":{
type:
Tfunction,
sdoc:
["Advises all watchers of the attribute ```name``` that it\'s value changed."],
imember:1,
ldoc:
[],
params:
[["name",[["string",
["Name of the attibute that changed via `set`."]]]],
["oldValue",[["any",
["The value of the attribute before the change."]]]],
["newValue",[["any",
["The value of the attribute after the change."]]]]],
loc: [109,2,137,3]}
,"bd.stateful.watch":{
type:
Tfunction,
sdoc:
["Causes callback to be applied if one (`name` is a attribute name) or all properties (`name` is \"*\") change value via\n`set`."],
imember:1,
ldoc:
["As with all Backdraft functions that take a callback-like function argument, `(callback, context, vargs)`\nis transformed to `bd.hitch(context, callback, arg1, arg2, ...)`.",
"Returns a bd.connect.handle that may be used to disconnect the watch. context.adviseEventWatcher is called iff it\nexists. See bd.connect and bd.connect.handle for details.",
[WARN,"watch will *not* notify any changes that are not applied via the `set` method."]],
params:
[["name",[["string",
["The attribute name to watch; \"*\" indicates all names."]]]],
["callback",[["function",
["Function to apply upon change of name."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
loc: [139,2,164,3]}
,"bd.noValue":{
type:
Tconst,
sdoc:
["Unique object recognized by bd.attr and bd.constAttr to say that no explicit property is defined for a particular attribute. "],
ldoc:
["Unique object recognized by bd.attr and bd.constAttr to say that no explicit property is defined for a particular attribute. This implies\nthe attribute value will always be calculated rather then read from a property."],
src:
"bd/stateful",
loc: [176,0,180,4],
module:"bd/stateful"}
,"bd.attr":{
type:
Tfunction,
sdoc:
["Creates an object that may be used with bd.declare to cause an attribute with the name `name` and associated\ngetter/setter functions to be defined in the prototype. "],
ldoc:
["Creates an object that may be used with bd.declare to cause an attribute with the name `name` and associated\ngetter/setter functions to be defined in the prototype. For example,",
[CODE,"bd.declare(\n  [],\n  attr(\"x\", 0),\n  attr(\"y\", 0),\n);"],
"Is equivalent to",
[CODE,"bd.declare(\n  [],\n  {\n    x: 0,\n    xGet: function() { return this.x; },\n    xSet: function(value) { var oldValue= this.x; this.x= value; return oldValue; }\n  },\n  {\n    y: 0,\n    yGet: function() { return this.y; },\n    ySet: function(value) { var oldValue= this.y; this.y= value; return oldValue; }\n  }\n);"],
"The implementation of the setter and/or getter functions can be specified by providing setter and/or getter function\narguments. If you desire to provide a custom getter while using the default setter, provide falsy for the setter\narguments."],
params:
[["name",[["string",
["The property name."]]]],
["defaultValue",[["any",
["The initial value for the property."]]]],
["setter",[["function(value), optional, see description",
["Function that sets the property to `value` and returns the previous value."]]]],
["getter",[["function(), optional, see description",
["Function that returns the current value of the property."]]]]],
src:
"bd/stateful",
loc: [182,0,229,1],
module:"bd/stateful"}
,"bd.constAttr":{
type:
Tfunction,
sdoc:
["Similar to bd.attr except that no setter is defined."],
ldoc:
[],
params:
[["name",[["string",
["The property name."]]]],
["defaultValue",[["any",
["The initial value for the property."]]]],
["getter",[["function(), optional, see description",
["Function that returns the current value of property."]]]]],
src:
"bd/stateful",
loc: [231,0,244,1],
module:"bd/stateful"}
,"modules.bd/stateful":{
type:
Tmodule,
sdoc:
["Defines the class bd.stateful and associated machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/stateful",
loc: [0,0,246,2]}
,"resources.bd/string":{
type:
Tresource,
sdoc:
["Defines the module bd/string"],
src:
"bd/string",
modules:
["bd/string"],
code:
["dojo.def(\"bd/string\", [\"bd/kernel\", \"dojo\"], function(bd, dojo) {",
"///",
"// Augments the bd namespace with several functions that operate on strings.",
"// ",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load the module bd. See module.bd.",
"",
"",
"// bd references some of dojo base so that the code isn\'t so tightly coupled to dojo--",
"// theoretically, the following could be changed to reference another library with",
"// identical semantics and everything would still work.",
"bd.replace= ",
"  ///",
"  // Alias for dojo.replace.",
"  dojo.replace;",
"",
"bd.trim= ",
"  ///",
"  // Alias for dojo.trim.",
"  dojo.trim;",
"",
"bd.toJson= ",
"  ///",
"  // Alias for dojo.toJson.",
"  dojo.toJson;",
"",
"bd.toJsonIndentStr=",
"  ///",
"  // Alias for dojo.toJsonIndentStr.",
"  dojo.toJsonIndentStr;",
"",
"});",
""]}
,"bd.replace":{
type:
Tvariable,
sdoc:
["Alias for dojo.replace."],
ldoc:
[],
src:
"bd/string",
loc: [12,0,15,14],
module:"bd/string"}
,"bd.trim":{
type:
Tvariable,
sdoc:
["Alias for dojo.trim."],
ldoc:
[],
src:
"bd/string",
loc: [17,0,20,11],
module:"bd/string"}
,"bd.toJson":{
type:
Tvariable,
sdoc:
["Alias for dojo.toJson."],
ldoc:
[],
src:
"bd/string",
loc: [22,0,25,13],
module:"bd/string"}
,"bd.toJsonIndentStr":{
type:
Tvariable,
sdoc:
["Alias for dojo.toJsonIndentStr."],
ldoc:
[],
src:
"bd/string",
loc: [27,0,30,22],
module:"bd/string"}
,"modules.bd/string":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with several functions that operate on strings."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load the module bd. See module.bd."]],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/string",
loc: [0,0,32,2]}
,"resources.bd/symbols":{
type:
Tresource,
sdoc:
["Defines the module bd/symbols"],
src:
"bd/symbols",
modules:
["bd/symbols"],
code:
["dojo.def(\"bd/symbols\", [",
"  \"dojo\", \"bd\",",
"  \"bd/collections\"",
"], function(dojo, bd) {",
"///",
"// Augments the bd namespace with the Backdraft symbol machinery.",
"",
"bd.symbols= ",
"  ///",
"  // Holds the backdraft symbol table.",
"  ///",
"  // The backdraft symbol table provides a mapping from any string (the",
"  // symbol name) to an object that is guaranteed to have",
"  // the property name that holds a string with the symbol name. Symbols are",
"  // added with the function bd.symbol. For example:",
"  //code",
"  // var s= bd.symbol(\"mySymbol\"); //creates the symbol, iff required",
"  // s.name==\"mySymbol\";           //true",
"  // s===bd.symbol(\"mySymbol\");    //true, bd.symbol simply returns an existing symbol",
"  ///",
"  // Symbols can be used for many different purposes. For example, a symbol can be",
"  // used to generate a type field without having to rely on a string:",
"  //code",
"  // var ",
"  //   o1= {",
"  //     type: bd.symbol(\"type1\")",
"  //   },",
"  //   o2= {",
"  //     type: bd.symbol(\"type1\")",
"  //   },",
"  //   o3= {",
"  //     type: bd.symbol(\"type2\")",
"  //   };",
"  // ",
"  // o1.type===o2.type; //true; note identity operator, no string comparison required!",
"  // o1.type===o3.type; //false",
"  // ",
"  // o1.type===bd.symbol(\"type1\");  //true; note identity operator, but we used a string; we can do better...",
"  // var type1= bd.symbol(\"type1\"); //probably keep type1 around for reuse",
"  // o1.type===type1;               //true, fast, no string comparison",
"  // //or...",
"  // o1.type1===bd.symbol.type1;    //true, fast, no string comparison",
"  // ",
"  ///",
"  // Of course the logic above could be spread widely within a large program and the",
"  // symbol properties are guaranteed.",
"  // ",
"  // There are many other interesting ways to use symbols. ",
"  // ",
"  //warn",
"  // Do not add properties to bd.symbols directly; use bd.symbol.",
"  //note",
"  // It is OK to access bd.symbol directly (e.g. bd.symbol.coolOp) so long",
"  // as program logic can guarantee that the symbol has already been created.",
"  {};",
"",
"bd.symbol= function(",
"  name ///(string) The target name.",
") {",
"  ///",
"  // Returns the symbol object given by name. //The symbol is automatically",
"  // created if it does not already exist.",
"  return bd.symbols[name] || (bd.symbols[name]= {name:name});///(object) bd.symbols[name]",
"};",
"",
"bd.createSymbols= function(",
"  symbols ///(array of string) The set of names to ensure exist as symbols.",
") {",
"  ///",
"  // Ensures that each name given in symbols has generated a symbol in bd.symbols.",
"  bd.forEach(symbols, function(symbol){ bd.symbol(symbol); });",
"};",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.symbols":{
type:
Tvariable,
sdoc:
["Holds the backdraft symbol table."],
ldoc:
["The backdraft symbol table provides a mapping from any string (the\nsymbol name) to an object that is guaranteed to have\nthe property name that holds a string with the symbol name. Symbols are\nadded with the function bd.symbol. For example:",
[CODE,"var s= bd.symbol(\"mySymbol\"); //creates the symbol, iff required\ns.name==\"mySymbol\";           //true\ns===bd.symbol(\"mySymbol\");    //true, bd.symbol simply returns an existing symbol"],
"Symbols can be used for many different purposes. For example, a symbol can be\nused to generate a type field without having to rely on a string:",
[CODE,"var\n  o1= {\n    type: bd.symbol(\"type1\")\n  },\n  o2= {\n    type: bd.symbol(\"type1\")\n  },\n  o3= {\n    type: bd.symbol(\"type2\")\n  };\n\no1.type===o2.type; //true; note identity operator, no string comparison required!\no1.type===o3.type; //false\n\no1.type===bd.symbol(\"type1\");  //true; note identity operator, but we used a string; we can do better...\nvar type1= bd.symbol(\"type1\"); //probably keep type1 around for reuse\no1.type===type1;               //true, fast, no string comparison\n//or...\no1.type1===bd.symbol.type1;    //true, fast, no string comparison"],
"Of course the logic above could be spread widely within a large program and the\nsymbol properties are guaranteed.\n\nThere are many other interesting ways to use symbols.",
[WARN,"Do not add properties to bd.symbols directly; use bd.symbol."],
[NOTE,"It is OK to access bd.symbol directly (e.g. bd.symbol.coolOp) so long\nas program logic can guarantee that the symbol has already been created."]],
src:
"bd/symbols",
loc: [7,0,54,4],
module:"bd/symbols"}
,"bd.symbol":{
type:
Tfunction,
sdoc:
["Returns the symbol object given by name. "],
ldoc:
["Returns the symbol object given by name. The symbol is automatically\ncreated if it does not already exist."],
params:
[["name",[["string",
["The target name."]]]]],
returns:
[["object",
["bd.symbols[name]"]]],
src:
"bd/symbols",
loc: [56,0,63,1],
module:"bd/symbols"}
,"bd.createSymbols":{
type:
Tfunction,
sdoc:
["Ensures that each name given in symbols has generated a symbol in bd.symbols."],
ldoc:
[],
params:
[["symbols",[["array of string",
["The set of names to ensure exist as symbols."]]]]],
src:
"bd/symbols",
loc: [65,0,71,1],
module:"bd/symbols"}
,"modules.bd/symbols":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with the Backdraft symbol machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/symbols",
loc: [0,0,73,2]}
,"resources.bd/test":{
type:
Tresource,
sdoc:
["Defines the module bd/test"],
src:
"bd/test",
modules:
["bd/test"],
code:
["dojo.def(\"bd/test\", [",
"  \"dojo\", \"bd\",",
"  \"bd/test/namespace\",",
"  \"bd/collections\",",
"  \"bd/test/proc\",",
"  \"bd/test/publisher\",",
"  \"bd/test/space\",",
"  \"bd/test/result\",",
"  \"bd/test/matchers\",",
"  \"bd/test/loader\"",
"], function(dojo, bd) {",
"///",
"// Augments the bd namespace with the entire backdraft test framework.",
"",
"if (bd.config.test.makeBdGlobal) {",
"  bd.global.bd= bd;",
"  bd.global.byName= bd.object.byName;",
"  bd.global.dijit= dojo.module(\"dijit\");",
"}",
"",
"var",
"  bumpToDoCount= function(",
"    space //(bd.test.space) The space upon which to bump the to do count.",
"  ) {",
"    ///",
"    // Increments the toDoCount counter in space.",
"    space.toDoCount++;",
"  },",
"  logVariable= function() {",
"    return \"[\" + this.name + \"]Variable \" + this.name;",
"  },",
"  logConst= function() {",
"    return \"[\" + this.name + \"]Constant \" + this.name;",
"  },",
"  logEnum= function() {",
"    return \"[\" + this.name + \"]Enumeration \" + this.name;",
"  },",
"  logFunction= function() {",
"    return \"[\" + this.name + \"]Function \" + this.name;",
"  },",
"  logArgument= function() {",
"    return \"[\" + this.name + \"]Argument \" + this.name;",
"  },",
"  logClass= function() {",
"    return \"[\" + this.name + \"]Class \" + this.name;",
"  },",
"  logMember= function() {",
"    return \"[\" + this.name + \"]Member \" + this.name;",
"  },",
"  logNote= function() {",
"    return (this.name ? \"[\" + this.name + \"]\" : \"\") + \"Note: \" + this.doc;",
"  },",
"  logRef= function() {",
"    return (this.name ? \"[\" + this.name + \"]\" : \"\") + \"Reference: \" + this.doc;",
"  },",
"  logToDo= function() {",
"    return \"[\" + this.name + \"]TODO: \" + this.doc;",
"  };",
"",
"bd.mix(bd.test, {",
"  describe: function(",
"    args,     ///(*bd.test.proc.description.constructor.args)",
"    scaffold, ///(*bd.test.proc.description.constructor.scaffold)",
"    children  ///(*bd.test.proc.description.constructor.children)",
"  ){",
"    ///",
"    // Creates and returns a bd.test.proc.description object. //Syntactic",
"    // sugar (see source below).",
"    return bd.test.proc.description.create.apply(null, arguments);",
"  },",
"",
"  describeVariable: function(",
"    args,     ///(*bd.test.proc.description.constructor.args)",
"    scaffold, ///(*bd.test.proc.description.constructor.scaffold)",
"    children  ///(*bd.test.proc.description.constructor.children)",
"  ){",
"    ///",
"    // Creates and returns a bd.test.proc.description that contains a member trait. //Syntactic",
"    // sugar (see source below).",
"    var result= bd.test.proc.description.create.apply(null, arguments);",
"    result.log= logVariable;",
"    return result;",
"  },",
"",
"  describeFunction: function(",
"    args,     ///(*bd.test.proc.description.constructor.args)",
"    scaffold, ///(*bd.test.proc.description.constructor.scaffold)",
"    children  ///(*bd.test.proc.description.constructor.children)",
"  ){",
"    ///",
"    // Creates and returns a bd.test.proc.description that contains a member trait. //Syntactic",
"    // sugar (see source below).",
"    var result= bd.test.proc.description.create.apply(null, arguments);",
"    result.log= logFunction;",
"    return result;",
"  },",
"",
"  describeClass: function(",
"    args,     ///(*bd.test.proc.description.constructor.args)",
"    scaffold, ///(*bd.test.proc.description.constructor.scaffold)",
"    children  ///(*bd.test.proc.description.constructor.children)",
"  ){",
"    ///",
"    // Creates and returns a bd.test.proc.description that contains a member trait. //Syntactic",
"    // sugar (see source below).",
"    var result= bd.test.proc.description.create.apply(null, arguments);",
"    result.log= logClass;",
"    return result;",
"  },",
"",
"  describeMember: function(",
"    args,     ///(*bd.test.proc.description.constructor.args)",
"    scaffold, ///(*bd.test.proc.description.constructor.scaffold)",
"    children  ///(*bd.test.proc.description.constructor.children)",
"  ){",
"    ///",
"    // Creates and returns a bd.test.proc.description that contains a member trait. //Syntactic",
"    // sugar (see source below).",
"    var result= bd.test.proc.description.create.apply(null, arguments);",
"    result.log= logMember;",
"    return result;",
"  },",
"",
"  describeArgument: function(",
"    args,     ///(*bd.test.proc.description.constructor.args)",
"    scaffold, ///(*bd.test.proc.description.constructor.scaffold)",
"    children  ///(*bd.test.proc.description.constructor.children)",
"  ){",
"    ///",
"    // Creates and returns a bd.test.proc.description that contains an argument trait. //Syntactic",
"    // sugar (see source below).",
"    var result= bd.test.proc.description.create.apply(null, arguments);",
"    result.log= logArgument;",
"    return result;",
"  },",
"",
"  scaffold: function(",
"    execType, ///(*bd.test.proc.scaffold.constructor.execType)",
"    before,   ///(*bd.test.proc.scaffold.before.execType)",
"    after     ///(*bd.test.proc.scaffold.after.execType)",
"  ) {",
"    ///",
"    // Creates and returns a bd.test.proc.scaffold object. //Syntactic",
"    // sugar (see source below).",
"    return new bd.test.proc.scaffold(execType, before, after);",
"  },",
"",
"  demo: function(",
"    args,   ///(*bd.test.proc.demo.constructor.args) ",
"    program ///(*bd.test.proc.demo.constructor.program) ",
"  ) {",
"    ///",
"    // Creates and returns a bd.test.proc.demo object. //Syntactic",
"    // sugar (see source below).",
"    return new bd.test.proc.demo(args, program);",
"  },",
"",
"  userDemo: function(",
"    args,   ///(*bd.test.proc.demo.constructor.args) ",
"    program ///(*bd.test.proc.demo.constructor.program) ",
"  ){",
"    ///",
"    // Creates and returns a bd.test.proc.demo object with the automatic addition of the userDemo trait. //Syntactic",
"    // sugar (see source below).",
"    var result= new bd.test.proc.demo(args, program);",
"    result.userDemo= true;",
"    return result;",
"  },",
"",
"  todo: function(",
"    args ///(string) The to do message.",
"  ) {",
"    ///",
"    // Creates and returns a bd.test.proc.demo object that increments the space toDoCount and contains a todo trait. //Syntactic",
"    // sugar (see source below).",
"    var result= new bd.test.proc.demo(args, bumpToDoCount);",
"    result.log= logToDo;",
"    return result;",
"  },",
"",
"  note: function(",
"    args ///(string) The note message.",
"  ) {",
"    ///",
"    // Creates and returns a bd.test.proc.demo object that executes a no-op and contains a note trait. //Syntactic",
"    // sugar (see source below).",
"    var result= new bd.test.proc.demo(args, bd.noop);",
"    result.log= logNote;",
"    return result;",
"  },",
"",
"  see: function(",
"    args ///(name) The reference message.",
"  ) {",
"    ///",
"    // Creates and returns a bd.test.proc.demo object that executes a no-op and contains a reference trait. //Syntactic",
"    // sugar (see source below).",
"    var result= new bd.test.proc.demo(args, bd.noop);",
"    result.log= logRef;",
"    return result;",
"  },",
"",
"  the: function (",
"    arg ///(any) Arguments to mixin to the new object.",
"  ){",
"    ///",
"    // Creates and returns a new object delegated to bd.test.theBase that contains any passed arguments.//",
"    // If a single argument is passed then it is referenced at property arg; if multiple arguments are ",
"    // passed then the arguments object is referenced at property args.",
"    return dojo.delegate(bd.test.theBase, arguments.length==1 ? {arg:arg} : {args:arguments});",
"  },",
"",
"  pass: function() {",
"    ///",
"    // Advise the active space of a pass result.",
"    bd.test.activeSpace.adviseResult(bd.test.result.pass());",
"  },",
"",
"  fail: function() {",
"    ///",
"    // Advise the active space of a fail result.",
"    bd.test.activeSpace.adviseResult(bd.test.result.fail());",
"  },",
"",
"  run: function(",
"    name,     ///(string) The name of the test to run.",
"    publisher ///(bd.test.publisher, optional, 0) The publisher to use for the test results.",
"  ) {",
"    ///",
"    // Runs the test given by name.",
"    var ",
"      test= this.proc.module.find(name),",
"      space= new bd.test.space({publisher:publisher||0});",
"    space.execute(test);",
"  }",
"});",
"",
"bd.test.theBase=",
"  ///",
"  // The prototype for objects created with bd.test.the.",
"  //",
"  // This object is initialized to contain functions named after the functions contained in bd.test.matchers.",
"  // These functions call the same-named bd.test.matchers function and then advise the result to the current active test space.",
"  (function() {",
"     var result= {};",
"     bd.forEachHash(bd.test.matchers, function(item, name) {",
"       result[name]= function() {",
"         bd.test.activeSpace.adviseResult(item.apply(this, arguments));",
"       };",
"     });",
"     return result;",
"   })();",
"",
"",
"bd.test.wait= function(",
"  time ///(positive integer) Number of milliseconds to wait.",
") {",
"  ///",
"  // Wait for a number of milliseconds. //This function is useful for simulating synchronous processes.",
"  //",
"  //Note",
"  // This is not like a real sleep function that will yeild to other threads. bd.wait",
"  // literally spins in a tight loop and will not return or allow any other processing until the time has expired.",
"",
"  var start= bd.getTime();",
"  while (bd.getTime()-start<time) {}",
"};",
"",
"bd.test.sampleValues= ",
"  ///",
"  // sample values that are convenient to have around for testing",
"  [",
"    undefined,",
"    null,",
"    false,",
"    true,",
"    0,",
"    1,",
"    22/7,",
"    new Number(\"123\"),",
"    \"\",",
"    \"a non-empty string\",",
"    new String(\"another non-empty string\"),",
"    [],",
"    [1, 2, 3],",
"    {},",
"    {someProperty:\"someValue\"},",
"    {someProperty:\"someValue\", nest1:{someProperty:\"someValue\"}},",
"    {someProperty:\"someValue\", nest1:{someProperty:\"someValue\", nest2:{somePropety:\"someValue\"}}},",
"    new Date(),",
"    /test/,",
"    new Error(\"some error message\"),",
"    new bd.test.proc.scaffold(\"once\", function(){}, function(){}) // a bd.declare\'d class",
"  ];",
"",
"//TODO is this REALLY used?",
"bd.test.runSampleValues= function(",
"  proc",
"){",
"  dojo.forEach(bd.test.sampleValues, proc);",
"};",
"",
"",
"bd.test.makeConsolePublisher= function() {",
"  ///",
"  // Creates a new bd.test.publisher that publishes to the debug console.",
"  //return",
"  //(bd.test.publisher) A publisher that publishes to the debug console.",
"  var buffer= \"\";",
"  return new bd.test.publisher({",
"    write: function(text) {",
"      var lines= text.split(\"\\n\");",
"      if (lines.length>1) {",
"        console.log(buffer+lines[0]);",
"        for (var i= 1; i<lines.length-1; i++) {",
"          console.log(lines[i]);",
"        } ",
"        buffer= lines[lines.length-1];",
"      } else if (lines.length==1) {",
"        buffer+= text;",
"      }",
"    }",
"  });",
"};",
"",
"bd.test.exec= function(",
"  testName,  ///(string) The full name of the test to execute.",
"  publisher, ///(bd.test.publisher) The destination of results.",
"             //(falsy) Use a publisher given by bd.test.makeConsolePublisher.",
"  spaceArgs  ///(hash) Arguments to use when creating the space.",
") {",
"  ///",
"  // Execute a single test. //This is useful for executing a quick test from the console.",
"  var test= bd.test.proc.find(testName);",
"  if (test) {",
"    publisher= publisher || bd.test.makeConsolePublisher();",
"    var space= new bd.test.space(dojo.mix({publisher:publisher, abortOnFail:false}, spaceArgs||{}));",
"    space.execute(test, function() {",
"      space.publisher.write(\"\\nPassed: \" + space.passCount + \"\\nFailed: \" + space.failCount + \"\\nTo Do:: \" + space.toDoCount + \"\\n\");",
"    });",
"  } else {",
"    console.error(\"In bd.test.exec, \" + testName + \" is not a valid test name.\");",
"  }",
"};",
"",
"return bd.test;",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.test.theBase":{
type:
Tvariable,
sdoc:
["The prototype for objects created with bd.test.the.\n\nThis object is initialized to contain functions named after the functions contained in bd.test.matchers.\nThese functions call the same-named bd.test.matchers function and then advise the result to the current active test space."],
ldoc:
[],
src:
"bd/test",
loc: [237,0,251,7],
module:"bd/test"}
,"bd.test.wait":{
type:
Tfunction,
sdoc:
[" Wait for a number of milliseconds. "],
ldoc:
[" Wait for a number of milliseconds. This function is useful for simulating synchronous processes.\n\nNote\n This is not like a real sleep function that will yeild to other threads. bd.wait\n literally spins in a tight loop and will not return or allow any other processing until the time has expired."],
params:
[["time",[["positive integer",
["Number of milliseconds to wait."]]]]],
src:
"bd/test",
loc: [254,0,266,1],
module:"bd/test"}
,"bd.test.sampleValues":{
type:
Tvariable,
sdoc:
["sample values that are convenient to have around for testing"],
ldoc:
[],
src:
"bd/test",
loc: [268,0,293,3],
module:"bd/test"}
,"bd.test.makeConsolePublisher":{
type:
Tfunction,
sdoc:
["Creates a new bd.test.publisher that publishes to the debug console."],
ldoc:
[],
returns:
[["bd.test.publisher",
["A publisher that publishes to the debug console."]]],
src:
"bd/test",
loc: [303,0,323,1],
module:"bd/test"}
,"bd.test.exec":{
type:
Tfunction,
sdoc:
["Execute a single test. "],
ldoc:
["Execute a single test. This is useful for executing a quick test from the console."],
params:
[["testName",[["string",
["The full name of the test to execute."]]]],
["publisher",[["bd.test.publisher",
["The destination of results."]],
["falsy",
["Use a publisher given by bd.test.makeConsolePublisher."]]]],
["spaceArgs",[["hash",
["Arguments to use when creating the space."]]]]],
src:
"bd/test",
loc: [325,0,343,1],
module:"bd/test"}
,"modules.bd/test":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with the entire backdraft test framework."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/test",
loc: [0,0,347,2]}
,"resources.bd/test/loader":{
type:
Tresource,
sdoc:
["Defines the module bd/test/loader"],
src:
"bd/test/loader",
modules:
["bd/test/loader"],
code:
["dojo.def(\"bd/test/loader\", [",
"  \"dojo\", \"bd\", \"bd/test/namespace\"",
"], function(dojo, bd) {",
"///",
"// Defines the Backdraft test framework loader.",
"",
"bd.test.loader=",
"  ///namespace",
"  // Contains the Backdraft test framework loader machinery.",
"  bd.test.loader || {};",
"",
"//local lexical variable...",
"var theLoader= bd.test.loader;",
"",
"bd.mix(bd.test.loader, {",
"  version: ",
"    ///",
"    // The current version of the cache. See bd.test.loader.text and bd.test.loader.flushCache.",
"    1,",
"",
"  asynchLoad: function(",
"    moduleNameOrNames ///(string | array of string) Module name(s) to load.",
"  ) {",
"    ///",
"    // Asynchronously downloads and loads one or many test modules.",
"    if (!dojo.isArray(moduleNameOrNames)) {",
"      moduleNameOrNames= [moduleNameOrNames];",
"    }",
"",
"    var currentVersion= theLoader.version;",
"    dojo.forEach(moduleNameOrNames, function(moduleName) {",
"      dojo.xhrGet({",
"        url:dojo.url(moduleName),",
"        load:function(text) {",
"          var module= bd.test.proc.get(moduleName);",
"          if (currentVersion<theLoader.version) {",
"            //the cache was flushed since the preload request; therefore, ignore this resource and get it again...",
"            theLoader.asynchLoad(moduleName);",
"          } else if (currentVersion>module.loadedVersion) {",
"            //the module either hasn\'t ever been loaded or the load is based on an older resource than we now have; therefore...",
"            theLoader.text[dojo.url(moduleName)]= text;",
"            theLoader.load(module);",
"          }",
"        }",
"      });",
"    });",
"  },",
"",
"  text:",
"    ///",
"    // A cache of raw test modules.",
"    ///",
"    //(map:url(string) --> text(string)) The raw text retrieved from url.",
"    {},",
"",
"  getText: function(",
"    url ///(URL) The address from which to download the text.",
"  ) {",
"    ///",
"    // Downloads the text from url and stores it in the cache at bd.test.loader.text.",
"    if (!theLoader.text[url]) {",
"      dojo.xhrGet({",
"        url:url,",
"        sync:true,",
"        load:function(text) {",
"          theLoader.text[url]= text;",
"        }",
"      });",
"    }",
"    return theLoader.text[url];",
"  },",
"",
"  flushCache: function() {",
"    ///",
"    // Clears the bd.test.loader.cache and bumps the cache version.",
"    theLoader.version++;",
"    theLoader.text= {};",
"  },",
"",
"  preprocess: function(",
"    text,",
"    moduleName",
"  ) {",
"    ///",
"    // Preprocesses text.",
"    var ",
"      metaCommandRegEx= /^(\\/\\/\\#)(\\w+)(.*)$/gm,   // \"//#<meta-command><args>\"",
"      result;",
"    while ((result= metaCommandRegEx.exec(text)) != null) {",
"      text= theLoader.preprocessors[result[2]](text, result, metaCommandRegEx, moduleName);",
"    }",
"    return theLoader.preprocessors.firebugId(text, 0, 0, moduleName);",
"  },",
"",
"  load: function(",
"    moduleOrModuleName, ///(bd.test.proc.module | string) the module or moduleName to load",
"    onLoad, ///(function, optional) function to execute upon completion of loading module",
"    onError ///(function, optional) function to execute if module fails to load",
"  ) {",
"    ///",
"    // Retrieves and preprocesses the resource associated moduleName iff the load version of that module is less than bd.test.loader.version.",
"",
"    var moduleName, module;",
"    if (dojo.isString(moduleOrModuleName)) {",
"      moduleName= moduleOrModuleName;",
"      module= bd.test.proc.get(moduleName);",
"    } else {",
"      module= moduleOrModuleName;",
"      moduleName= module.getFullName();",
"    }",
"    if (module.loadedVersion>=theLoader.version) {",
"      return;",
"    }",
"    try {",
"      dojo.eval(theLoader.preprocess(theLoader.getText(module.getUrl()), moduleName));",
"      module.loadedVersion= theLoader.version;",
"      onLoad && onLoad(module);",
"    } catch (e) {",
"      dojo.onError(\"failed-to-load-test-module\", [e]);",
"      onError && onError();",
"    }",
"  }",
"});",
"",
"",
"bd.test.loader.preprocessors=",
"  ///namespace",
"  // Contains functions that process raw test modules.",
"  bd.test.loader.preprocessors || {};",
"",
"bd.mix(bd.test.loader.preprocessors, {",
"  commentToString: function(",
"    text,          ///(string) The raw text to transform.",
"    reResult,      ///(regex result) The result of executing the regular expression that found this processor (`//#commentToString`); see bd.loader.preprocess.",
"    metaCommandRe,",
"    moduleName",
"  ) {",
"    ///",
"    // Scans source for a multi-line \"//\" comment sequence preceeded by a keyword; when found, changes the comment sequence to a string. //For example...",
"    //code",
"    // describe(//This is a long comment",
"    //          //here is more",
"    //          //etc.",
"    //   demo(...)",
"    // )",
"    ///",
"    // is transfored into",
"    //code",
"    // describe(\"This is a long comment\\nhere is more\\etc.\", demo(...))",
"    ///",
"    // Notice the comma was inserted. If the next token after the comment sequence is \")\", then the comma is not inserted.",
"    //",
"    // If each line is preceeded by some white space, then the number of spaces found on the line",
"    // with the least about of prefix white space are deleted from every line.",
"    //",
"    // For example...",
"    //code",
"    //   // This is a comment",
"    //   // some more",
"    //   //    this is indented",
"    //   // that\'s all",
"    ///",
"    // is transformed into",
"    //code",
"    // \"This is a comment\\nsome more\\n  this is indented\\nthat\'sall\"",
"    var",
"      result= [],",
"      regex= /^(\\s*)(describe|member|argument|demo|todo|note|see)\\(\\/\\/(\\s*)(.*)/,",
"      commentRegEx= /^\\s*\\/\\/(\\s*)(.*)/,",
"      nextTokenIsClosingParen= /^\\s*\\)/,",
"      head= text.substring(0, reResult.index);",
"    text= text.substring(metaCommandRe.lastIndex).split(\"\\n\");",
"    for (var i= 0, end= text.length; i<end; i++) {",
"      var match= regex.exec(text[i]);",
"      if (match) {",
"        var",
"          j, jEnd, minLeadingWS,",
"          start= match[1] + match[2] + \"(\",",
"          // s is a vector of pairs of (leading white-space, content)",
"          s= [[match[3], match[4]]];",
"        i++;",
"        while (i<end) {",
"          match= commentRegEx.exec(text[i]);",
"          if (match) {",
"            s.push([match[1], match[2]]);",
"            i++;",
"          } else {",
"            break;",
"          }",
"        }",
"        //remove any empty lines from the front of the vector",
"        while (s.length && !s[0][1]) {",
"          s.shift();",
"        }",
"        //remove any empty lines from the end of the vector",
"        j= s.length - 1;",
"        while (s.length && !s[j--][1]) {",
"          s.pop();",
"        }",
"        //find the minimum number of leading spaces all lines contain",
"        minLeadingWS= s[0][0].length;",
"        for (j= 1, jEnd= s.length; j<jEnd; j++) {",
"          minLeadingWS= Math.min(minLeadingWS, s[j][0].length);",
"        }",
"        //if all lines contain at least some leading white space, trim it and calculate the new content",
"        if (minLeadingWS) {",
"          for (j= 0, jEnd= s.length; j<jEnd; j++) {",
"            s[j]= s[j][0].substring(minLeadingWS) + s[j][1];",
"          }",
"        } else {",
"          for (j= 0, jEnd= s.length; j<jEnd; j++) {",
"            s[j]= s[j][0] + s[j][1];",
"          }",
"        }",
"        s= s.join(\"\\n\");",
"        if (nextTokenIsClosingParen.test(text[i])) {",
"          result.push(start + dojo._escapeString(s));",
"        } else {",
"          result.push(start + dojo._escapeString(s) + \",\");",
"        }",
"        i--;",
"      } else {",
"        result.push(text[i]);",
"      }",
"    }",
"    metaCommandRe.lastIndex= head.length;",
"    return head + \"\\n\" + result.join(\"\\n\");",
"  },",
"",
"  firebugId:function(",
"    text,",
"    notUsed1,",
"    notUsed2,",
"    moduleName",
"  ) {",
"    ///",
"    // Appends the string required for Firebug to debug eval\'d text.",
"    ///",
"    // The name is given as <module name>.<bd.test.loader.version at the time the module was loaded.",
"    // This allows modules to be reloaded without restarted the application.",
"",
"    return text + \"\\n//@ sourceURL=\" + moduleName + \".\" + theLoader.version;",
"  },",
"",
"  include: function(",
"    text,",
"    reResult,",
"    metaCommandRe,",
"    moduleName",
"  ) {",
"    ///",
"    // Includes a resouse inside another resource.",
"    var",
"      includeText= theLoader.getText(dojo.url(dojo.trim(reResult[3]), false)),",
"      temp= text.substring(0, reResult.index) + includeText + \"var moduleName= \\\"\" + moduleName + \"\\\";\",",
"      lastIndex= metaCommandRe.lastIndex;",
"    metaCommandRe.lastIndex= temp.length;",
"    return temp + text.substring(lastIndex);",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.test.loader":{
type:
Tnamespace,
sdoc:
["Contains the Backdraft test framework loader machinery."],
ldoc:
[],
src:
"bd/test/loader",
loc: [6,0,9,22],
module:"bd/test/loader"}
,"bd.test.loader.version":{
type:
Tvariable,
sdoc:
["The current version of the cache. See bd.test.loader.text and bd.test.loader.flushCache."],
ldoc:
[],
src:
"bd/test/loader",
loc: [15,2,18,5],
module:"bd/test/loader"}
,"bd.test.loader.asynchLoad":{
type:
Tfunction,
sdoc:
["Asynchronously downloads and loads one or many test modules."],
ldoc:
[],
params:
[["moduleNameOrNames",[["string | array of string",
["Module name(s) to load."]]]]],
src:
"bd/test/loader",
loc: [20,2,46,3],
module:"bd/test/loader"}
,"bd.test.loader.text":{
type:
Tvariable,
sdoc:
["A cache of raw test modules."],
ldoc:
[],
src:
"bd/test/loader",
loc: [48,2,53,6],
types:
[["map:url(string) --> text(string)",
["The raw text retrieved from url."]]],
module:"bd/test/loader"}
,"bd.test.loader.getText":{
type:
Tfunction,
sdoc:
["Downloads the text from url and stores it in the cache at bd.test.loader.text."],
ldoc:
[],
params:
[["url",[["URL",
["The address from which to download the text."]]]]],
src:
"bd/test/loader",
loc: [55,2,70,3],
module:"bd/test/loader"}
,"bd.test.loader.flushCache":{
type:
Tfunction,
sdoc:
["Clears the bd.test.loader.cache and bumps the cache version."],
ldoc:
[],
src:
"bd/test/loader",
loc: [72,2,77,3],
module:"bd/test/loader"}
,"bd.test.loader.preprocess":{
type:
Tfunction,
sdoc:
["Preprocesses text."],
ldoc:
[],
params:
[["text",[]],
["moduleName",[]]],
src:
"bd/test/loader",
loc: [79,2,92,3],
module:"bd/test/loader"}
,"bd.test.loader.load":{
type:
Tfunction,
sdoc:
["Retrieves and preprocesses the resource associated moduleName iff the load version of that module is less than bd.test.loader.version."],
ldoc:
[],
params:
[["moduleOrModuleName",[["bd.test.proc.module | string",
["the module or moduleName to load"]]]],
["onLoad",[["function, optional",
["function to execute upon completion of loading module"]]]],
["onError",[["function, optional",
["function to execute if module fails to load"]]]]],
src:
"bd/test/loader",
loc: [94,2,121,3],
module:"bd/test/loader"}
,"bd.test.loader.preprocessors":{
type:
Tnamespace,
sdoc:
["Contains functions that process raw test modules."],
ldoc:
[],
src:
"bd/test/loader",
loc: [125,0,128,36],
module:"bd/test/loader"}
,"bd.test.loader.preprocessors.commentToString":{
type:
Tfunction,
sdoc:
["Scans source for a multi-line \""],
ldoc:
["Scans source for a multi-line \"\" comment sequence preceeded by a keyword; when found, changes the comment sequence to a string. //For example...",
[CODE,"describe(//This is a long comment\n         //here is more\n         //etc.\n  demo(...)\n)"],
"is transfored into",
[CODE,"describe(\"This is a long comment\\nhere is more\\etc.\", demo(...))"],
"Notice the comma was inserted. If the next token after the comment sequence is \")\", then the comma is not inserted.\n\nIf each line is preceeded by some white space, then the number of spaces found on the line\nwith the least about of prefix white space are deleted from every line.\n\nFor example...",
[CODE,"// This is a comment\n// some more\n//    this is indented\n// that\'s all"],
"is transformed into",
[CODE,"\"This is a comment\\nsome more\\n  this is indented\\nthat\'sall\""]],
params:
[["text",[["string",
["The raw text to transform."]]]],
["reResult",[["regex result",
["The result of executing the regular expression that found this processor (`//#commentToString`); see bd.loader.preprocess."]]]],
["metaCommandRe",[]],
["moduleName",[]]],
src:
"bd/test/loader",
loc: [131,2,227,3],
module:"bd/test/loader"}
,"bd.test.loader.preprocessors.firebugId":{
type:
Tfunction,
sdoc:
["Appends the string required for Firebug to debug eval\'d text."],
ldoc:
["The name is given as <module name>.<bd.test.loader.version at the time the module was loaded.\nThis allows modules to be reloaded without restarted the application."],
params:
[["text",[]],
["notUsed1",[]],
["notUsed2",[]],
["moduleName",[]]],
src:
"bd/test/loader",
loc: [229,2,242,3],
module:"bd/test/loader"}
,"bd.test.loader.preprocessors.include":{
type:
Tfunction,
sdoc:
["Includes a resouse inside another resource."],
ldoc:
[],
params:
[["text",[]],
["reResult",[]],
["metaCommandRe",[]],
["moduleName",[]]],
src:
"bd/test/loader",
loc: [244,2,258,3],
module:"bd/test/loader"}
,"modules.bd/test/loader":{
type:
Tmodule,
sdoc:
["Defines the Backdraft test framework loader."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/test/loader",
loc: [0,0,261,2]}
,"resources.bd/test/matchers":{
type:
Tresource,
sdoc:
["Defines the module bd/test/matchers"],
src:
"bd/test/matchers",
modules:
["bd/test/matchers"],
code:
["dojo.def(\"bd/test/matchers\", [",
"  \"dojo\", \"bd\", \"bd/test/namespace\",",
"  \"bd/lang\"",
"], function(dojo, bd) {",
"///",
"// Defines the Backdraft test framework matcher functions.",
"",
"bd.test.matchers= ",
"  ///namespace",
"  // Contains a set of matcher functions.",
"  bd.test.matchers || {};",
"",
"var aDojoDeclaredObject= new (bd.declare(null, {}))();",
"",
"dojo.mix(bd.test.matchers, {",
"  is: function(",
"    expected ///(any) The expected object.",
"  ){",
"    ///",
"    // Tests that this.arg === expected.",
"    return((this.arg===expected ? bd.test.result.pass : bd.test.result.fail)(this.arg, expected));",
"  },",
"",
"  isNot: function(",
"    expected ///(any) The expected object.",
"  ){",
"    ///",
"    // Tests that this.arg !== expected.",
"    return((this.arg!==expected ? bd.test.result.pass : bd.test.result.fail)(this.arg, expected));",
"  },",
"",
"  hasValue: function(",
"    expected ///(any) The expected object.",
"  ){",
"    ///",
"    // Tests that this.arg is equal to expected by value.",
"    return((bd.equal(this.arg, expected) ? bd.test.result.pass : bd.test.result.fail)(this.arg, expected));",
"  },",
"",
"  hasDiffValue: function(",
"    expected ///(any) The expected object.",
"  ){",
"    ///",
"    // Tests that this.arg is not equal to expected by value.",
"    return((!bd.equal(this.arg, expected) ? bd.test.result.pass : bd.test.result.fail)(this.arg, expected));",
"  },",
"",
"  isDojoDeclared: function() {",
"    ///",
"    // Tests that this.arg is an object created by a constructor generated by dojo.declare.",
"    return (this.arg.getInherited===aDojoDeclaredObject.getInherited ?  bd.test.result.pass : bd.test.result.fail)(this.arg);",
"  },",
"",
"  //TODO: these need to be rewritten to say, e.g., the(x).isa(String) or the(x).nota(String)",
"",
"  isString: function() {",
"    ///",
"    // Tests that this.arg is a string.",
"    return((dojo.isString(this.arg) ?  bd.test.result.pass : bd.test.result.fail)(this.arg));",
"  },",
"",
"  isNotString: function() {",
"    ///",
"    // Tests that this.arg is not a string.",
"    return((!dojo.isString(this.arg) ?  bd.test.result.pass : bd.test.result.fail)(this.arg));",
"  },",
"",
"  isArray: function() {",
"    ///",
"    // Tests that this.arg is a array.",
"    return((dojo.isArray(this.arg) ?  bd.test.result.pass : bd.test.result.fail)(this.arg));",
"  },",
"",
"  isNotArray: function() {",
"    ///",
"    // Tests that this.arg is not an array.",
"    return((!dojo.isArray(this.arg) ?  bd.test.result.pass : bd.test.result.fail)(this.arg));",
"  },",
"",
"  isFunction: function() {",
"    ///",
"    // Tests that this.arg is a function.",
"    return((dojo.isFunction(this.arg) ?  bd.test.result.pass : bd.test.result.fail)(this.arg));",
"  },",
"",
"  isNotFunction: function() {",
"    ///",
"    // Tests that this.arg is not a function.",
"    return((!dojo.isFunction(this.arg) ?  bd.test.result.pass : bd.test.result.fail)(this.arg));",
"  },",
"",
"  prototypeIs: function(",
"    expected ///(object) The expected prototype.",
"  ){",
"    ///",
"    // Tests that the prototype of this.arg === expected.",
"    // `warn guaranteed to work iff browser supports __proto__ property",
"    // `warn changing the prototype of a constructor after that constructor has created objects will cause this test to return false fails",
"    // `warn this matcher won\'t work with objects created with delegation",
"    if (this.arg.__proto__) {",
"      return((this.arg.__proto__===(expected) ? bd.test.result.pass : bd.test.result.fail)(this.arg, expected));",
"    } else {",
"      //see warning above...",
"      return((this.arg.constructor.prototype===(expected) ? bd.test.result.pass : bd.test.result.fail)(this.arg, expected));",
"    }",
"  },",
"",
"  prototypeIsNot: function(",
"    expected ///(name or object) The expected prototype.",
"  ){",
"    ///",
"    // Tests that the prototype of this.arg !== expected.",
"    var result= bd.test.matchers.prototypeIs.call(this, expected);",
"    result.pass= !result.pass;",
"    return result;",
"  },",
"",
"  isInstanceOf: function(",
"    expected ///(object) The expected constructor function.",
"  ) {",
"    ///",
"    // Tests that this.arg is an instance of expected.",
"    return((this.arg instanceof expected ? bd.test.result.pass : bd.test.result.fail)(this.arg, expected));",
"  },",
"",
"  isNotInstanceOf: function(",
"    expected ///(name or object) The expected prototype.",
"  ){",
"    ///",
"    // Tests that this.arg is not an instance of expected.",
"    var result= bd.test.matchers.isInstanceOf.call(this, expected);",
"    result.pass= !result.pass;",
"    return result;",
"  },",
"",
"  hasProperties: function(",
"    expected ///(array of string or object) The expected properties",
"  ){",
"    ///",
"    // Tests that this.arg contains at least properties given/contained by expected; properties may be anywhere in the prototype chain.",
"    if (dojo.isArray(expected)) {",
"      for (var i= 0, end= expected.length; i<end; i++) {",
"        if (!(expected[i] in this.arg)) {",
"          return(bd.test.result.fail(this.arg, expected));",
"          //return;",
"        }",
"      }",
"      return(bd.test.result.pass(this.arg, expected));",
"    } else {",
"      for (var p in expected) {",
"        if (!(p in this.arg)) {",
"          return(bd.test.result.fail(this.arg, expected));",
"          //return;",
"        }",
"      }",
"      return(bd.test.result.pass(this.arg, expected));",
"    }",
"  },",
"",
"  doesNotHaveProperties: function(",
"    expected ///(name or object) The expected prototype.",
"  ){",
"    ///",
"    // Tests that this.arg does not contain the properties given/contained by expected; properties may be anywhere in the prototype chain.",
"    var result= bd.test.matchers.hasProperties.call(this, expected);",
"    result.pass= !result.pass;",
"    return result;",
"  },",
"",
"  hasOwnProperties: function(",
"    expected ///(array of string or object) The expected properties.",
"  ){",
"    ///",
"    // Tests that this.arg contains at least its own properties given/contained by expected.",
"    if (dojo.isArray(expected)) {",
"      for (var i= 0, end= expected.length; i<end; i++) {",
"        if (!this.arg.hasOwnProperty(expected[i])) {",
"          return(bd.test.result.fail(this.arg, expected));",
"          //return;",
"        }",
"      }",
"    } else {",
"      for (p in expected) {",
"        if (!this.arg.hasOwnProperty(p)){",
"          return(bd.test.result.fail(this.arg, expected));",
"          //return;",
"        }",
"      }",
"    }",
"    return(bd.test.result.pass(this.arg, expected));",
"  },",
"",
"  doesNotHaveOwnProperties: function(",
"    expected ///(name or object) The expected prototype.",
"  ){",
"    ///",
"    // Tests that this.arg does not contain at least its own properties given/contained by expected.",
"    var result= bd.test.matchers.hasOwnProperties.call(this, expected);",
"    result.pass= !result.pass;",
"    return result;",
"  },",
"",
"  hasPropertiesExact: function(",
"    expected ///(array of string or object) The expected properties.",
"  ){",
"    ///",
"    // Tests that this.arg contains exactly properties given/contained by expected; properties may be anywhere in the prototype chain.",
"    if (dojo.isArray(expected)) {",
"      for (var i= 0, end= expected.length; i<end; i++) {",
"        if (!(expected[i] in this.arg)) {",
"          return(bd.test.result.fail(this.arg, expected));",
"          //return;",
"        }",
"      }",
"      var count= 0;",
"      for (var p in this.arg) {",
"        count++;",
"      }",
"      return((expected.length===count ? bd.test.result.pass : bd.test.result.fail)(this.arg, expected));",
"    } else {",
"      for (var p in this.arg) {",
"        if (!(p in expected)) {",
"          return(bd.test.result.fail(this.arg, expected));",
"          //return;",
"        }",
"      }",
"      for (p in expected) {",
"        if (!(p in this.arg)) {",
"          return(bd.test.result.fail(this.arg, expected));",
"          //return;",
"        }",
"      }",
"      return(bd.test.result.pass(this.arg, expected));",
"    }",
"  },",
"",
"  doesNotHaveExactProperties: function(",
"    expected ///(name or object) The expected prototype.",
"  ){",
"    ///",
"    // Tests that this.arg does not contain exactly properties given/contained by expected; properties may be anywhere in the prototype chain.",
"    var result= bd.test.matchers.hasPropertiesExact.call(this, expected);",
"    result.pass= !result.pass;",
"    return result;",
"  },",
"",
"  hasOwnPropertiesExact: function(",
"    expected ///(array of string or object) The expected properties.",
"  ){",
"    ///",
"    // Tests that this.arg contains exactly its own properties given/contained by expected.",
"    if (dojo.isArray(expected)) {",
"      for (var i= 0, end= expected.length; i<end; i++) {",
"        if (!this.arg.hasOwnProperty(expected[i])) {",
"          return(bd.test.result.fail(this.arg, expected));",
"          //return;",
"        }",
"      }",
"      var count= 0;",
"      for (var p in this.arg) {",
"        if (this.arg.hasOwnProperty(p)) {",
"          count++;",
"        }",
"      }",
"      return((expected.length===count ? bd.test.result.pass : bd.test.result.fail)(this.arg, expected));",
"    } else {",
"      for (var p in this.arg) {",
"        if (this.arg.hasOwnProperty(p)){",
"          if (!(p in expected)) {",
"            return(bd.test.result.fail(this.arg, expected));",
"            //return;",
"          }",
"        }",
"      }",
"      for (p in expected) {",
"        if (!this.arg.hasOwnProperty(p)) {",
"          return(bd.test.result.fail(this.arg, expected));",
"          //return;",
"        }",
"      }",
"      return(bd.test.result.pass(this.arg, expected));",
"    }",
"  },",
"",
"  doesNotHaveOwnExactProperties: function(",
"    expected ///(name or object) The expected prototype.",
"  ){",
"    ///",
"    // Tests that this.arg does not contain exactly its own properties given/contained by expected.",
"    var result= bd.test.matchers.hasOwnPropertiesExact.call(this, expected);",
"    result.pass= !result.pass;",
"    return result;",
"  },",
"",
"  contains: function(",
"    expected ///(regex or string) The expected string.",
"  ) {",
"    ///",
"    // Tests that this.arg contains expected.",
"    if (expected instanceof RegExp) {",
"      return((!!expected.exec(this.arg.toString()) ? bd.test.result.pass : bd.test.result.fail)(this.arg, expected));",
"    } else {",
"      return((this.arg.toString().indexOf(expected)>-1 ? bd.test.result.pass : bd.test.result.fail)(this.arg, expected));",
"    }",
"  },",
"",
"  doesNotContain: function(",
"    expected ///(name or object) The expected prototype.",
"  ){",
"    ///",
"    // Tests that this.arg does not contain expected.",
"    var result= bd.test.matchers.contains.call(this, expected);",
"    result.pass= !result.pass;",
"    return result;",
"  },",
"",
"  isEmpty: function(",
"  ) {",
"    ///",
"    // Tests that this.arg is either an empty array ([]) or an empty object ({}).",
"",
"    if (dojo.isArray(this.arg)) {",
"      return this.arg.length ? bd.test.result.fail(this.arg) : bd.test.result.pass(this.arg);",
"    }",
"    for (var p in this.arg) {",
"      if (this.arg.hasOwnProperty(p)) {",
"        return(bd.test.result.fail(this.arg));",
"      }",
"    }",
"    return(bd.test.result.pass(this.arg));",
"  },",
"",
"  isNotEmpty: function(",
"  ){",
"    ///",
"    // Tests that this.arg is neither an empty array ([]) or an empty object ({}).",
"    var result= bd.test.matchers.isEmpty.call(this);",
"    result.pass= !result.pass;",
"    return result;",
"  },",
"",
"  inClosedInterval: function(",
"    min, ///(number) The left endpoint.",
"    max ///(number) The right endpoint.",
"  ) {",
"    ///",
"    // Tests that min <= this.arg <= max.",
"    return((min<=this.arg && this.arg<=max ? bd.test.result.pass : bd.test.result.fail)(this.arg, min, max));",
"  },",
"",
"  notInClosedInterval: function(",
"    expected ///(name or object) The expected prototype.",
"  ){",
"    ///",
"    // Tests that min > this.arg < max.",
"    var result= bd.test.matchers.inClosedInterval.call(this, expected);",
"    result.pass= !result.pass;",
"    return result;",
"  },",
"",
"  inLeftOpenInterval: function(",
"    min, ///(number) The left endpoint.",
"    max ///(number) The right endpoint.",
"  ) {",
"    ///",
"    // Tests that min < this.arg <= max.",
"    return((min<this.arg && this.arg<=max ? bd.test.result.pass : bd.test.result.fail)(this.arg, min, max));",
"  },",
"",
"  notInLeftOpenInterval: function(",
"    expected ///(name or object) The expected prototype.",
"  ){",
"    ///",
"    // Tests that min >= this.arg > max.",
"    var result= bd.test.matchers.inLeftOpenInterval.call(this, expected);",
"    result.pass= !result.pass;",
"    return result;",
"  },",
"",
"  inRightOpenInterval: function(",
"    min, ///(number) The left endpoint.",
"    max ///(number) The right endpoint.",
"  ) {",
"    ///",
"    // Tests that min <= this.arg < max.",
"    return((min<=this.arg && this.arg<max ? bd.test.result.pass : bd.test.result.fail)(this.arg, min, max));",
"  },",
"",
"  notInRightOpenInterval: function(",
"    expected ///(name or object) The expected prototype.",
"  ){",
"    ///",
"    // Tests that min > this.arg >= max.",
"    var result= bd.test.matchers.inRightOpenInterval.call(this, expected);",
"    result.pass= !result.pass;",
"    return result;",
"  },",
"",
"  inOpenInterval: function(",
"    min, ///(number) The left endpoint.",
"    max ///(number) The right endpoint.",
"  ) {",
"    ///",
"    // Tests that min < this.arg < max.",
"    return((min<this.arg && this.arg<max ? bd.test.result.pass : bd.test.result.fail)(this.arg, min, max));",
"  },",
"",
"  notInOpenInterval: function(",
"    expected ///(name or object) The expected prototype.",
"  ){",
"    ///",
"    // Tests that min >= this.arg >= max.",
"    var result= bd.test.matchers.inOpenInterval.call(this, expected);",
"    result.pass= !result.pass;",
"    return result;",
"  },",
"",
"  raises: function(",
"    expected",
"  ) {",
"    ///",
"    // Tests that expected() throws the exception expected.",
"    try {",
"      this.arg();",
"      return(bd.test.result.fail());",
"    } catch(e) {",
"      if (expected) {",
"        return((bd.equal(e, expected) ? bd.test.result.pass : bd.test.result.fail)(this.arg, e, expected));",
"      } else {",
"        return bd.test.result.pass(this.arg, e);",
"      }",
"    }",
"  }",
"});",
"",
"dojo.mix(bd.test.matchers, {",
"  inRange: ",
"    ///",
"    //synonym for bd.test.matchers.inClosedInterval.",
"    bd.test.matchers.inClosedInterval,",
"",
"  inLeftOpen: ",
"    ///",
"    //synonym for bd.test.matchers.inLeftOpenInterval.",
"    bd.test.matchers.inLeftOpenInterval,",
"",
"  inRightOpen: ",
"    ///",
"    //synonym for bd.test.matchers.inRightOpenInterval.",
"    bd.test.matchers.inRightOpenInterval,",
"",
"  inOpen: ",
"    ///",
"    //synonym for bd.test.matchers.inOpenInterval.",
"    bd.test.matchers.inOpenInterval",
"",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.test.matchers":{
type:
Tnamespace,
sdoc:
["Contains a set of matcher functions."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [7,0,10,24],
module:"bd/test/matchers"}
,"bd.test.matchers.is":{
type:
Tfunction,
sdoc:
["Tests that this.arg === expected."],
ldoc:
[],
params:
[["expected",[["any",
["The expected object."]]]]],
src:
"bd/test/matchers",
loc: [15,2,21,3],
module:"bd/test/matchers"}
,"bd.test.matchers.isNot":{
type:
Tfunction,
sdoc:
["Tests that this.arg !== expected."],
ldoc:
[],
params:
[["expected",[["any",
["The expected object."]]]]],
src:
"bd/test/matchers",
loc: [23,2,29,3],
module:"bd/test/matchers"}
,"bd.test.matchers.hasValue":{
type:
Tfunction,
sdoc:
["Tests that this.arg is equal to expected by value."],
ldoc:
[],
params:
[["expected",[["any",
["The expected object."]]]]],
src:
"bd/test/matchers",
loc: [31,2,37,3],
module:"bd/test/matchers"}
,"bd.test.matchers.hasDiffValue":{
type:
Tfunction,
sdoc:
["Tests that this.arg is not equal to expected by value."],
ldoc:
[],
params:
[["expected",[["any",
["The expected object."]]]]],
src:
"bd/test/matchers",
loc: [39,2,45,3],
module:"bd/test/matchers"}
,"bd.test.matchers.isDojoDeclared":{
type:
Tfunction,
sdoc:
["Tests that this.arg is an object created by a constructor generated by dojo.declare."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [47,2,51,3],
module:"bd/test/matchers"}
,"bd.test.matchers.isString":{
type:
Tfunction,
sdoc:
["Tests that this.arg is a string."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [55,2,59,3],
module:"bd/test/matchers"}
,"bd.test.matchers.isNotString":{
type:
Tfunction,
sdoc:
["Tests that this.arg is not a string."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [61,2,65,3],
module:"bd/test/matchers"}
,"bd.test.matchers.isArray":{
type:
Tfunction,
sdoc:
["Tests that this.arg is a array."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [67,2,71,3],
module:"bd/test/matchers"}
,"bd.test.matchers.isNotArray":{
type:
Tfunction,
sdoc:
["Tests that this.arg is not an array."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [73,2,77,3],
module:"bd/test/matchers"}
,"bd.test.matchers.isFunction":{
type:
Tfunction,
sdoc:
["Tests that this.arg is a function."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [79,2,83,3],
module:"bd/test/matchers"}
,"bd.test.matchers.isNotFunction":{
type:
Tfunction,
sdoc:
["Tests that this.arg is not a function."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [85,2,89,3],
module:"bd/test/matchers"}
,"bd.test.matchers.prototypeIs":{
type:
Tfunction,
sdoc:
["Tests that the prototype of this.arg === expected."],
ldoc:
[[WARN,"guaranteed to work iff browser supports __proto__ property"],
[WARN,"changing the prototype of a constructor after that constructor has created objects will cause this test to return false fails"],
[WARN,"this matcher won\'t work with objects created with delegation"]],
params:
[["expected",[["object",
["The expected prototype."]]]]],
src:
"bd/test/matchers",
loc: [91,2,105,3],
module:"bd/test/matchers"}
,"bd.test.matchers.prototypeIsNot":{
type:
Tfunction,
sdoc:
["Tests that the prototype of this.arg !== expected."],
ldoc:
[],
params:
[["expected",[["name or object",
["The expected prototype."]]]]],
src:
"bd/test/matchers",
loc: [107,2,115,3],
module:"bd/test/matchers"}
,"bd.test.matchers.isInstanceOf":{
type:
Tfunction,
sdoc:
["Tests that this.arg is an instance of expected."],
ldoc:
[],
params:
[["expected",[["object",
["The expected constructor function."]]]]],
src:
"bd/test/matchers",
loc: [117,2,123,3],
module:"bd/test/matchers"}
,"bd.test.matchers.isNotInstanceOf":{
type:
Tfunction,
sdoc:
["Tests that this.arg is not an instance of expected."],
ldoc:
[],
params:
[["expected",[["name or object",
["The expected prototype."]]]]],
src:
"bd/test/matchers",
loc: [125,2,133,3],
module:"bd/test/matchers"}
,"bd.test.matchers.hasProperties":{
type:
Tfunction,
sdoc:
["Tests that this.arg contains at least properties given/contained by expected; properties may be anywhere in the prototype chain."],
ldoc:
[],
params:
[["expected",[["array of string or object",
["The expected properties"]]]]],
src:
"bd/test/matchers",
loc: [135,2,157,3],
module:"bd/test/matchers"}
,"bd.test.matchers.doesNotHaveProperties":{
type:
Tfunction,
sdoc:
["Tests that this.arg does not contain the properties given/contained by expected; properties may be anywhere in the prototype chain."],
ldoc:
[],
params:
[["expected",[["name or object",
["The expected prototype."]]]]],
src:
"bd/test/matchers",
loc: [159,2,167,3],
module:"bd/test/matchers"}
,"bd.test.matchers.hasOwnProperties":{
type:
Tfunction,
sdoc:
["Tests that this.arg contains at least its own properties given/contained by expected."],
ldoc:
[],
params:
[["expected",[["array of string or object",
["The expected properties."]]]]],
src:
"bd/test/matchers",
loc: [169,2,190,3],
module:"bd/test/matchers"}
,"bd.test.matchers.doesNotHaveOwnProperties":{
type:
Tfunction,
sdoc:
["Tests that this.arg does not contain at least its own properties given/contained by expected."],
ldoc:
[],
params:
[["expected",[["name or object",
["The expected prototype."]]]]],
src:
"bd/test/matchers",
loc: [192,2,200,3],
module:"bd/test/matchers"}
,"bd.test.matchers.hasPropertiesExact":{
type:
Tfunction,
sdoc:
["Tests that this.arg contains exactly properties given/contained by expected; properties may be anywhere in the prototype chain."],
ldoc:
[],
params:
[["expected",[["array of string or object",
["The expected properties."]]]]],
src:
"bd/test/matchers",
loc: [202,2,234,3],
module:"bd/test/matchers"}
,"bd.test.matchers.doesNotHaveExactProperties":{
type:
Tfunction,
sdoc:
["Tests that this.arg does not contain exactly properties given/contained by expected; properties may be anywhere in the prototype chain."],
ldoc:
[],
params:
[["expected",[["name or object",
["The expected prototype."]]]]],
src:
"bd/test/matchers",
loc: [236,2,244,3],
module:"bd/test/matchers"}
,"bd.test.matchers.hasOwnPropertiesExact":{
type:
Tfunction,
sdoc:
["Tests that this.arg contains exactly its own properties given/contained by expected."],
ldoc:
[],
params:
[["expected",[["array of string or object",
["The expected properties."]]]]],
src:
"bd/test/matchers",
loc: [246,2,282,3],
module:"bd/test/matchers"}
,"bd.test.matchers.doesNotHaveOwnExactProperties":{
type:
Tfunction,
sdoc:
["Tests that this.arg does not contain exactly its own properties given/contained by expected."],
ldoc:
[],
params:
[["expected",[["name or object",
["The expected prototype."]]]]],
src:
"bd/test/matchers",
loc: [284,2,292,3],
module:"bd/test/matchers"}
,"bd.test.matchers.contains":{
type:
Tfunction,
sdoc:
["Tests that this.arg contains expected."],
ldoc:
[],
params:
[["expected",[["regex or string",
["The expected string."]]]]],
src:
"bd/test/matchers",
loc: [294,2,304,3],
module:"bd/test/matchers"}
,"bd.test.matchers.doesNotContain":{
type:
Tfunction,
sdoc:
["Tests that this.arg does not contain expected."],
ldoc:
[],
params:
[["expected",[["name or object",
["The expected prototype."]]]]],
src:
"bd/test/matchers",
loc: [306,2,314,3],
module:"bd/test/matchers"}
,"bd.test.matchers.isEmpty":{
type:
Tfunction,
sdoc:
["Tests that this.arg is either an empty array ([]) or an empty object ({})."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [316,2,330,3],
module:"bd/test/matchers"}
,"bd.test.matchers.isNotEmpty":{
type:
Tfunction,
sdoc:
["Tests that this.arg is neither an empty array ([]) or an empty object ({})."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [332,2,339,3],
module:"bd/test/matchers"}
,"bd.test.matchers.inClosedInterval":{
type:
Tfunction,
sdoc:
["Tests that min <= this.arg <= max."],
ldoc:
[],
params:
[["min",[["number",
["The left endpoint."]]]],
["max",[["number",
["The right endpoint."]]]]],
src:
"bd/test/matchers",
loc: [341,2,348,3],
module:"bd/test/matchers"}
,"bd.test.matchers.notInClosedInterval":{
type:
Tfunction,
sdoc:
["Tests that min > this.arg < max."],
ldoc:
[],
params:
[["expected",[["name or object",
["The expected prototype."]]]]],
src:
"bd/test/matchers",
loc: [350,2,358,3],
module:"bd/test/matchers"}
,"bd.test.matchers.inLeftOpenInterval":{
type:
Tfunction,
sdoc:
["Tests that min < this.arg <= max."],
ldoc:
[],
params:
[["min",[["number",
["The left endpoint."]]]],
["max",[["number",
["The right endpoint."]]]]],
src:
"bd/test/matchers",
loc: [360,2,367,3],
module:"bd/test/matchers"}
,"bd.test.matchers.notInLeftOpenInterval":{
type:
Tfunction,
sdoc:
["Tests that min >= this.arg > max."],
ldoc:
[],
params:
[["expected",[["name or object",
["The expected prototype."]]]]],
src:
"bd/test/matchers",
loc: [369,2,377,3],
module:"bd/test/matchers"}
,"bd.test.matchers.inRightOpenInterval":{
type:
Tfunction,
sdoc:
["Tests that min <= this.arg < max."],
ldoc:
[],
params:
[["min",[["number",
["The left endpoint."]]]],
["max",[["number",
["The right endpoint."]]]]],
src:
"bd/test/matchers",
loc: [379,2,386,3],
module:"bd/test/matchers"}
,"bd.test.matchers.notInRightOpenInterval":{
type:
Tfunction,
sdoc:
["Tests that min > this.arg >= max."],
ldoc:
[],
params:
[["expected",[["name or object",
["The expected prototype."]]]]],
src:
"bd/test/matchers",
loc: [388,2,396,3],
module:"bd/test/matchers"}
,"bd.test.matchers.inOpenInterval":{
type:
Tfunction,
sdoc:
["Tests that min < this.arg < max."],
ldoc:
[],
params:
[["min",[["number",
["The left endpoint."]]]],
["max",[["number",
["The right endpoint."]]]]],
src:
"bd/test/matchers",
loc: [398,2,405,3],
module:"bd/test/matchers"}
,"bd.test.matchers.notInOpenInterval":{
type:
Tfunction,
sdoc:
["Tests that min >= this.arg >= max."],
ldoc:
[],
params:
[["expected",[["name or object",
["The expected prototype."]]]]],
src:
"bd/test/matchers",
loc: [407,2,415,3],
module:"bd/test/matchers"}
,"bd.test.matchers.raises":{
type:
Tfunction,
sdoc:
["Tests that expected() throws the exception expected."],
ldoc:
[],
params:
[["expected",[]]],
src:
"bd/test/matchers",
loc: [417,2,432,3],
module:"bd/test/matchers"}
,"bd.test.matchers.inRange":{
type:
Tvariable,
sdoc:
["synonym for bd.test.matchers.inClosedInterval."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [436,2,439,37],
module:"bd/test/matchers"}
,"bd.test.matchers.inLeftOpen":{
type:
Tvariable,
sdoc:
["synonym for bd.test.matchers.inLeftOpenInterval."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [441,2,444,39],
module:"bd/test/matchers"}
,"bd.test.matchers.inRightOpen":{
type:
Tvariable,
sdoc:
["synonym for bd.test.matchers.inRightOpenInterval."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [446,2,449,40],
module:"bd/test/matchers"}
,"bd.test.matchers.inOpen":{
type:
Tvariable,
sdoc:
["synonym for bd.test.matchers.inOpenInterval."],
ldoc:
[],
src:
"bd/test/matchers",
loc: [451,2,454,35],
module:"bd/test/matchers"}
,"modules.bd/test/matchers":{
type:
Tmodule,
sdoc:
["Defines the Backdraft test framework matcher functions."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/test/matchers",
loc: [0,0,458,2]}
,"resources.bd/test/mockFrenzyServer":{
type:
Tresource,
sdoc:
["Defines the module bd/test/mockFrenzyServer"],
src:
"bd/test/mockFrenzyServer",
modules:
["bd/test/mockFrenzyServer"],
code:
["dojo.def(\"bd/test/mockFrenzyServer\", [",
"  \"dojo\", \"bd\", \"bd/test/namespace\"",
"], function(dojo, bd) {",
"///",
"// Defines the class bd.test.mockFrenzyServer",
"",
"bd.declare(",
"  ///",
"  // Simulates a frenzy server. //The constructor accepts a hash of functions that are used to simulate the",
"  // server-side procedures. The method bd.test.mockFrenzyServer` decodes a frenzy request message, calls all procedures",
"  // contained in the message that have also been defined in the instance (during construction, derivation, or otherwise), packages",
"  // the results and returns the frenzy response message.",
"",
"  //class name",
"  \"bd:test.mockFrenzyServer\", ",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  {",
"  constructor: function(",
"    args ///(hash) A set of objects (usually server-side function simulators) to mix into this instance.",
"  ){",
"    ///",
"    // Mixes args into the new instance.",
"    dojo.mix(this, args);",
"  },",
"",
"  postScript: function(",
"    result ///The result created while servicing a frenzy message.",
"  ) {",
"    ///",
"    // The sole purpose of this function is to provide an place to hook an override function to manipulate results",
"    // after all simulated procedures have been run but before the frenzy response message is returned.",
"  },",
"",
"  dispatchRequest: function(",
"    message ///(frenzy request message) with the properties {responseText, responseXML, status, headers, method, url, user, password, content}",
"  ) {",
"    ///",
"    // Decodes the message, runs the simulator functions, packages and returns a response message.",
"    var",
"      request= dojo.fromJson(message.query),",
"      serviceInfo= request.serviceInfo,",
"      result= {",
"        serviceInfo: serviceInfo,",
"        results: []",
"      };",
"",
"    result.serviceInfo.timeServiceRx= bd.getTime();",
"",
"    dojo.forEach(request.calls, function(call) {",
"      var",
"        proc= this[call.procName],",
"        thisResult= {",
"          callId: call.callId,",
"          result: (proc ? proc.call(this, call.args, call.callId, serviceInfo) : 0)",
"        };",
"      result.results.push(thisResult);",
"    }, this);",
"",
"    this.postScript(result);",
"",
"    result.serviceInfo.timeServiceTx= bd.getTime();",
"",
"    return {",
"      status: 200,",
"      responseText: dojo.toJson(result),",
"      responseXML: \"\"",
"    };",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.test.mockFrenzyServer":{
type:
Tclass,
sdoc:
["Simulates a frenzy server. "],
ldoc:
["Simulates a frenzy server. The constructor accepts a hash of functions that are used to simulate the\nserver-side procedures. The method bd.test.mockFrenzyServer` decodes a frenzy request message, calls all procedures\ncontained in the message that have also been defined in the instance (during construction, derivation, or otherwise), packages\nthe results and returns the frenzy response message."],
src:
"bd/test/mockFrenzyServer",
loc: [6,0,72,2],
module:"bd/test/mockFrenzyServer"}
,"bd.test.mockFrenzyServer.constructor":{
type:
Tfunction,
sdoc:
["Mixes args into the new instance."],
imember:1,
ldoc:
[],
params:
[["args",[["hash",
["A set of objects (usually server-side function simulators) to mix into this instance."]]]]],
loc: [21,2,27,3]}
,"bd.test.mockFrenzyServer.postScript":{
type:
Tfunction,
sdoc:
["The sole purpose of this function is to provide an place to hook an override function to manipulate results\nafter all simulated procedures have been run but before the frenzy response message is returned."],
imember:1,
ldoc:
[],
params:
[["result",[["",
["The result created while servicing a frenzy message."]]]]],
loc: [29,2,35,3]}
,"bd.test.mockFrenzyServer.dispatchRequest":{
type:
Tfunction,
sdoc:
["Decodes the message, runs the simulator functions, packages and returns a response message."],
imember:1,
ldoc:
[],
params:
[["message",[["frenzy request message",
["with the properties {responseText, responseXML, status, headers, method, url, user, password, content}"]]]]],
loc: [37,2,71,3]}
,"modules.bd/test/mockFrenzyServer":{
type:
Tmodule,
sdoc:
["Defines the class bd.test.mockFrenzyServer"],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/test/mockFrenzyServer",
loc: [0,0,74,2]}
,"resources.bd/test/mockXhr":{
type:
Tresource,
sdoc:
["Defines the module bd/test/mockXhr"],
src:
"bd/test/mockXhr",
modules:
["bd/test/mockXhr"],
code:
["dojo.def(",
"  \"bd/test/mockXhr\", [",
"  \"dojo\", \"bd\", \"bd/test/namespace\"",
"], function(dojo, bd) {",
"///",
"// Defines the class bd.test.mockXhr.",
"",
"bd.declare(",
"  ///",
"  // Simulates an XMLHttpRequest object.",
"",
"  \"bd:test.mockXhr\", ",
"",
"  [],",
" ",
"  {",
"  delay:",
"    ///",
"    // (integer) The delay in milliseconds before the response is available; used to simulate network IO.",
"    20,",
"",
"  readyState:",
"    ///",
"    // (0 | 1 | 2 | 3 | 4) As per standard XMLHttpRequest semantics.",
"    0,",
"",
"  responseText:",
"    ///",
"    // (string) As per standard XMLHttpRequest semantics.",
"    \"\",",
"",
"  responseXML:",
"    ///",
"    // (?) As per standard XMLHttpRequest semantics.",
"    \"\",",
"",
"  status:",
"    ///",
"    // (integer) As per standard XMLHttpRequest semantics.",
"    0,",
"",
"  headers:",
"    ///",
"    // (hash)[{}] As per standard XMLHttpRequest semantics.",
"    {},",
"",
"  method:",
"    ///",
"    // (\"GET\" | \"POST\") As set by bd.test.mockXhr.open.",
"    undefined,",
"",
"  url:",
"    ///",
"    // (string) As set by bd.test.mockXhr.open.",
"    \"\",",
"",
"  asynchronous:",
"    ///",
"    // (bool) As set by bd.test.mockXhr.open.",
"    true,",
"",
"  user:",
"    ///",
"    // (string) As set by bd.test.mockXhr.open.",
"    \"\",",
"",
"  password:",
"    ///",
"    // (string) As set by bd.test.mockXhr.open.",
"    \"\",",
"",
"  aborted:",
"    ///",
"    // (boolean) True if bd.test.mockXhr.abort has been called; false otherwise.",
"    // `private",
"    false,",
"",
"  service:",
"    ///",
"    // (bd.test.mockXhr.service) Function that sets the response given the method, headers, URL, etc; initialized in constructor.",
"    // `private",
"    null,",
"",
"  response:",
"    ///",
"    // (hash) The reponse returned by service; should include the properties responseText, responseXML, status.",
"    // `private",
"    null,",
"",
"  constructor: function(",
"    service ///(bd.test.mockXhr.service) Function that returns the response given the method, headers, URL, etc.",
"  ) {",
"    ///",
"    // Create a new instance that answers requests by calling service.",
"    this.service= service;",
"  },",
"",
"  open: function(",
"    method,       ///(\"POST\" | \"GET\") The HTTP method to use.",
"    url,          ///(string) The URL to which to send the request.",
"    asynchronous, ///(boolean)[true] Perform the operation asynchronously (or not)",
"    user,         ///(string)[\"\"] User name to use for authentication.",
"    password      ///(string)[\"\"] Password to use for authentication.",
"  ) {",
"    ///",
"    // As per standard XMLHttpRequest semantics.",
"    if (this.readyState!=0) {",
"      throw Error(\"XHR already opened\");",
"    }",
"    this.method= method;",
"    this.url= url;",
"    this.asynchronous= !!asynchronous;",
"    this.user= user;",
"    this.password= password;",
"    this.signalReadyState(1);",
"  },",
"",
"  setRequestHeader: function(",
"    key,  ///(string) The name of the header key to set.",
"    value ///(string) The value for the header key.",
"  ) {",
"    ///",
"    // As per standard XMLHttpRequest semantics.",
"    this.headers[key]= value;",
"  },",
"",
"  send: function(",
"    query ///(string, optional \"\") The body of a POST, if any.",
"  ) {",
"    ///",
"    // As per standard XMLHttpRequest semantics.",
"    this.query= query || \"\";",
"    this.signalReadyState(2);",
"    this.aborted= false;",
"    this.response= this.service(this);",
"    this.signalReadyState(3);",
"    if (this.asynchronous) {",
"      setTimeout(dojo.hitch(this, \"setResponse\"), this.response.delay || this.delay);",
"    } else {",
"      bd.test.wait(this.response.delay || this.delay);",
"      this.setResponse();",
"    }",
"  },",
"",
"  abort: function() {",
"    ///",
"    // As per standard XMLHttpRequest semantics.",
"    this.aborted= true;",
"  },",
"",
"  setResponse: function() {",
"    // set the response and advance readState to 4.",
"    if (!this.aborted) {",
"      this.status= this.response.status;",
"      this.responseText= this.response.responseText;",
"      this.responseXML= this.response.responseXML;",
"      this.signalReadyState(4);",
"    }",
"  },",
"",
"  signalReadyState: function(",
"    state //(integer) new readyState value",
"  ) {",
"    // called upon a change to readyState; fire onreadstateChange, if any.",
"    this.readyState= state;",
"    if (this.onreadystatechange) {",
"      this.onreadystatechange();",
"    }",
"  }",
"});",
"",
"var",
"  dojoXhrObj= null, // The original value at dojo.getXhr.",
"  mocks= null;      // An array of {filter, service} pairs that says which XHR calls to mock.",
"",
"dojo.mix(bd.test.mockXhr, {",
"  install: function(",
"    filter, ///(bd.test.mockXhr.filter) Predicate that says if a request should return a bd.test.mockXhr based on associated service.",
"    service ///(bd.test.mockXhr.service) When filter returns true, use this service to create a mock XHR object.",
"  ) {",
"    ///",
"    // Advise the bd.test.mockXhr machinery that a particular class of XHR requests (as given by filter) should be mocked (as given by service).",
"    //",
"    // Replaces dojo.getXhr with a function that returns mock XHR objects (for requests that match a filter) or the standard XHR object",
"    // as provided by dojo (if no filter match is found).",
"    //",
"    // If several filters are installed that return true for a particulare request, then the most recently inserted filter",
"    // is selected. This allows client code to insert generalized filters first and then \"override\" subsets caught by the generalized",
"    // filter with a more-specific filter.",
"",
"    if (!dojoXhrObj) {",
"      mocks= mocks || [];",
"      dojoXhrObj= dojo.getXhr;",
"      //TODO: dojo v2.0, remove dojo._xhrObj",
"      dojo.getXhr= dojo._xhrObj= function(args) {",
"        var result= null;",
"        if (mocks && args) {",
"          dojo.some(mocks, function(item) {",
"            return item.filter(args) && (result= new bd.test.mockXhr(item.service));",
"          });",
"        };",
"        return result || dojoXhrObj.apply(dojo, arguments);",
"      };",
"    }",
"",
"    mocks.unshift({filter: filter, service:service});",
"  },",
"",
"  remove: function(",
"    filter ///(bd.test.mockXhr.filter) A filter previously installed with bd.test.mockXhr.install.",
"  ) {",
"    ///",
"    // Removes a (filter, service) pair previously installed by bd.test.mock.Xhr.install.",
"    if (mocks) {",
"      dojo.some(mocks, function(item, i) {",
"        if (item.filter===filter) {",
"          mocks.splice(i, 1);",
"          return true;",
"        } else {",
"          return false;",
"        }",
"      });",
"    }",
"  },",
"",
"  filter: function(",
"    args /// The \"args\" argument given to dojo.xhr*",
"  ){",
"    ///type",
"    // Predicate returns true if the filter matches; false otherwise.",
"  },",
"",
"  service: function(",
"    mockXhr ///(bd.test.mockXhr) The instance of bd.test.mockXhr to which to response.",
"  ) {",
"    ///type",
"    // Returns a hash that contains the properties status, responseText, and responseXML filled with values",
"    // to simulate a server\'s response.",
"    //",
"    // The hash can also include the value delay to set an explicit delay time, overriding the property bd.test.mockXhr.delay.",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.test.mockXhr":{
type:
Tclass,
sdoc:
["Simulates an XMLHttpRequest object."],
ldoc:
[],
src:
"bd/test/mockXhr",
loc: [7,0,169,2],
module:"bd/test/mockXhr"}
,"bd.test.mockXhr.delay":{
type:
Tvariable,
sdoc:
["(integer) The delay in milliseconds before the response is available; used to simulate network IO."],
imember:1,
ldoc:
[],
loc: [16,2,19,6]}
,"bd.test.mockXhr.readyState":{
type:
Tvariable,
sdoc:
["(0 | 1 | 2 | 3 | 4) As per standard XMLHttpRequest semantics."],
imember:1,
ldoc:
[],
loc: [21,2,24,5]}
,"bd.test.mockXhr.responseText":{
type:
Tvariable,
sdoc:
["(string) As per standard XMLHttpRequest semantics."],
imember:1,
ldoc:
[],
loc: [26,2,29,6]}
,"bd.test.mockXhr.responseXML":{
type:
Tvariable,
sdoc:
["(?) As per standard XMLHttpRequest semantics."],
imember:1,
ldoc:
[],
loc: [31,2,34,6]}
,"bd.test.mockXhr.status":{
type:
Tvariable,
sdoc:
["(integer) As per standard XMLHttpRequest semantics."],
imember:1,
ldoc:
[],
loc: [36,2,39,5]}
,"bd.test.mockXhr.headers":{
type:
Tvariable,
sdoc:
["(hash)[{}] As per standard XMLHttpRequest semantics."],
imember:1,
ldoc:
[],
loc: [41,2,44,6]}
,"bd.test.mockXhr.method":{
type:
Tvariable,
sdoc:
["(\"GET\" | \"POST\") As set by bd.test.mockXhr.open."],
imember:1,
ldoc:
[],
loc: [46,2,49,13]}
,"bd.test.mockXhr.url":{
type:
Tvariable,
sdoc:
["(string) As set by bd.test.mockXhr.open."],
imember:1,
ldoc:
[],
loc: [51,2,54,6]}
,"bd.test.mockXhr.asynchronous":{
type:
Tvariable,
sdoc:
["(bool) As set by bd.test.mockXhr.open."],
imember:1,
ldoc:
[],
loc: [56,2,59,8]}
,"bd.test.mockXhr.user":{
type:
Tvariable,
sdoc:
["(string) As set by bd.test.mockXhr.open."],
imember:1,
ldoc:
[],
loc: [61,2,64,6]}
,"bd.test.mockXhr.password":{
type:
Tvariable,
sdoc:
["(string) As set by bd.test.mockXhr.open."],
imember:1,
ldoc:
[],
loc: [66,2,69,6]}
,"bd.test.mockXhr.aborted":{
type:
Tvariable,
sdoc:
["(boolean) True if bd.test.mockXhr.abort has been called; false otherwise."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
loc: [71,2,75,9]}
,"bd.test.mockXhr.service":{
type:
Tvariable,
sdoc:
["(bd.test.mockXhr.service) Function that sets the response given the method, headers, URL, etc; initialized in constructor."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
loc: [77,2,81,8]}
,"bd.test.mockXhr.response":{
type:
Tvariable,
sdoc:
["(hash) The reponse returned by service; should include the properties responseText, responseXML, status."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
loc: [83,2,87,8]}
,"bd.test.mockXhr.constructor":{
type:
Tfunction,
sdoc:
["Create a new instance that answers requests by calling service."],
imember:1,
ldoc:
[],
params:
[["service",[["bd.test.mockXhr.service",
["Function that returns the response given the method, headers, URL, etc."]]]]],
loc: [89,2,95,3]}
,"bd.test.mockXhr.open":{
type:
Tfunction,
sdoc:
["As per standard XMLHttpRequest semantics."],
imember:1,
ldoc:
[],
params:
[["method",[["\"POST\" | \"GET\"",
["The HTTP method to use."]]]],
["url",[["string",
["The URL to which to send the request."]]]],
["asynchronous",[["boolean",
["[true] Perform the operation asynchronously (or not)"]]]],
["user",[["string",
["[\"\"] User name to use for authentication."]]]],
["password",[["string",
["[\"\"] Password to use for authentication."]]]]],
loc: [97,2,115,3]}
,"bd.test.mockXhr.setRequestHeader":{
type:
Tfunction,
sdoc:
["As per standard XMLHttpRequest semantics."],
imember:1,
ldoc:
[],
params:
[["key",[["string",
["The name of the header key to set."]]]],
["value",[["string",
["The value for the header key."]]]]],
loc: [117,2,124,3]}
,"bd.test.mockXhr.send":{
type:
Tfunction,
sdoc:
["As per standard XMLHttpRequest semantics."],
imember:1,
ldoc:
[],
params:
[["query",[["string, optional \"\"",
["The body of a POST, if any."]]]]],
loc: [126,2,142,3]}
,"bd.test.mockXhr.abort":{
type:
Tfunction,
sdoc:
["As per standard XMLHttpRequest semantics."],
imember:1,
ldoc:
[],
loc: [144,2,148,3]}
,"modules.bd/test/mockXhr":{
type:
Tmodule,
sdoc:
["Defines the class bd.test.mockXhr."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/test/mockXhr",
loc: [0,0,243,2]}
,"resources.bd/test/namespace":{
type:
Tresource,
sdoc:
["Defines the module bd/test/namespace"],
src:
"bd/test/namespace",
modules:
["bd/test/namespace"],
code:
["dojo.def(\"bd/test/namespace\", [\"bd\"], function(bd) {",
"///",
"// Augments the bd namespace with the bd.test namespace and defines Backdraft test machinery configuration options.",
"///",
"//note",
"// Typically, client programs do not load this module directly, but rather load",
"// the module bd/test. See module.bd.test.",
"",
"bd.test=",
"  ///namespace",
"  // Contains the Backdraft testing machinery.",
"  bd.test || {};",
"",
"var userConfig= bd.config.test || {};",
"bd.config.test= {",
"  ///",
"  // Holds several configuration flags for the Backdraft test framework. //Define this variable with",
"  // desired switch setting before loading the test framework (this is only required if you desire a",
"  // switch setting different than the default). For example, by default, the test framework aliases the",
"  // bd namespace into the global namespace, thereby making it convenient for use in the browser debug console. This",
"  // feature could be disabled by writing,",
"  //code",
"  // // set non-default configuration switches...",
"  // bd.config.test= {",
"  //   makeBdGlobal: false;",
"  // };",
"  // ",
"  // // load the test framework",
"  // dojo.reg(\"bd/test\");",
"  ///",
"  makeBdGlobal:",
"    ///",
"    // Cause the test framework to alias the bd namespace in the global namespace.",
"    true",
"};",
"",
"//user switches override defaults...",
"bd.mix(bd.config.test, userConfig);",
"",
"return bd.test;",
"",
"});"]}
,"bd.test":{
type:
Tnamespace,
sdoc:
["Contains the Backdraft testing machinery."],
ldoc:
[],
src:
"bd/test/namespace",
loc: [8,0,11,15],
module:"bd/test/namespace"}
,"bd.config.test":{
type:
Tvariable,
sdoc:
["Holds several configuration flags for the Backdraft test framework. "],
ldoc:
["Holds several configuration flags for the Backdraft test framework. Define this variable with\ndesired switch setting before loading the test framework (this is only required if you desire a\nswitch setting different than the default). For example, by default, the test framework aliases the\nbd namespace into the global namespace, thereby making it convenient for use in the browser debug console. This\nfeature could be disabled by writing,",
[CODE,"// set non-default configuration switches...\nbd.config.test= {\n  makeBdGlobal: false;\n};\n\n// load the test framework\ndojo.reg(\"bd/test\");"]],
props:
["makeBdGlobal",{
type:
Tvariable,
sdoc:
["Cause the test framework to alias the bd namespace in the global namespace."],
ldoc:
[],
loc: [33,4,33,8]}
],
src:
"bd/test/namespace",
loc: [14,0,34,1],
module:"bd/test/namespace"}
,"modules.bd/test/namespace":{
type:
Tmodule,
sdoc:
["Augments the bd namespace with the bd.test namespace and defines Backdraft test machinery configuration options."],
ldoc:
[[NOTE,"Typically, client programs do not load this module directly, but rather load\nthe module bd/test. See module.bd.test."]],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/test/namespace",
loc: [0,0,41,2]}
,"resources.bd/test/proc":{
type:
Tresource,
sdoc:
["Defines the module bd/test/proc"],
src:
"bd/test/proc",
modules:
["bd/test/proc"],
docLocs:
[[517,525],[52,67]],
code:
["dojo.def(\"bd/test/proc\", [",
"  \"dojo\", \"bd\", \"bd/test/namespace\"",
"], function(dojo, bd) {",
"///",
"// Defines the Backdraft test framework\'s test procedure class hierarchy.",
"",
"var getNameAndDoc= function(s) {",
"  var match= /^\\[(.+)\\](.*)/.exec(s);",
"  if (match) {",
"    return {name:match[1], doc:match[2]};",
"  } else if (/ /.test(s)) {",
"    //the string has a space; assume its a doc string",
"    return {doc:s};",
"  } else {",
"    return {name:s};",
"  }",
"};",
"",
"bd.declare(",
"  ///",
"  // The base class for test procedure classes. //Defines the minimum interface for",
"  // test procedure subclasses.",
"",
"  //class name",
"  \"bd:test.proc\", ",
"",
"  //superclasses",
"  [],",
" ",
"  //members",
"  {",
"  constructor: function(",
"    args ///(kwargs)",
"         //(string with no spaces) The value to initialize the name property.",
"         //(string with spaces) The value to initialize the rdoc property.",
"  ) {",
"    ///",
"    // Creates a new instance.",
"    ///",
"    // The new object is initialized with the following property values:",
"    //code",
"    // {",
"    //   name:\"\"",
"    //   doc:\"\", ",
"    //   parent:null, ",
"    //   children:[]",
"    // }",
"    ///",
"    // If createArgs is not a string, it is mixed into the new instance possibly changing these initial values.",
"    // If parent is given, then the new object is added to the children of the given parent.",
"    //",
"    // The new instance, o, has the property bd.test.proc.map[o.id]===o (if createArgs gives a value of id, it is ignored).",
"    bd.docGen(\"kwargs\", {",
"      ///",
"      // Describes how to initialize a bd.test.proc instance.",
"      doc: ",
"        ///(string) The documentation for the procedure.",
"        undefined,",
"      name:",
"        ///(string) The name of the procedure.",
"        undefined,",
"      parent:",
"        ///(bd.test.proc) The parent of the procedure.",
"        undefined,",
"      children: ",
"        ///(array or bd.test.proc) The children of this procedure.",
"        undefined",
"    });",
"",
"    if (dojo.isString(args)) {",
"      args= getNameAndDoc(args);",
"    }",
"    dojo.mix(this, {",
"      name:\"\",",
"      doc:\"\",",
"      parent:null,",
"      children:[]",
"    }, args || {});",
"    if (!this.name) {",
"      this.name= dojo.uid();",
"    }",
"    if (this.parent) {",
"      this.parent.children.push(this);",
"    }",
"    this.id= bd.test.proc.map.length;",
"    bd.test.proc.map.push(this);",
"  },",
"",
"  destroy: function() {",
"    ///",
"    // Destroy this instance. //Recursively destroy all children, and remove this",
"    // object from its parent and the bd.test.proc.map. Since these are the only ",
"    // references the test framework keeps of this instance, it should be garbage",
"    // collected.",
"    for (var children= this.children, i= 0, end= children.length; i<end; i++) {",
"      children[i].parent= null;",
"      children[i].destroy();",
"    }",
"    this.children= [];",
"    if (this.parent) {",
"      this.parent.removeChild(this);",
"    }",
"    bd.test.proc.map[this.id]= null;",
"  },",
"",
"  getPath: function() {",
"    var ",
"      result= [],",
"      p= this;",
"    while (p) {",
"      result.push(p.id);",
"      p= p.parent;",
"    }",
"    result.reverse();",
"    return result;",
"  },",
"",
"  getFullName: function() {",
"    ///",
"    // Get the full path and name of this module.",
"    //return",
"    //(string) Concatentation of all parents, starting from the root; each name is separated by a \"/\".",
"    var",
"      names= [],",
"      p= this;",
"    while (p!==bd.test.proc.root) {",
"      names.unshift(p.name);",
"      p= p.parent;",
"    }",
"    return names.join(\"/\");",
"  },",
"",
"  log: function() {",
"    return \"[\" + (this.name.charAt(0)==\"_\" ? \"\" : this.name) + \"]\" + this.doc;",
"  },",
"",
"  setParentOfChildren: function() {",
"    ///",
"    // Set the parent of all of this instance\'s children to this instance.",
"    for (var children= this.children, i= 0, end= children.length; i<end; i++) {",
"      children[i].parent= this;",
"    }",
"  },",
"",
"  removeChild: function(",
"    child ///(bd.test.proc) A child of this instance.",
"  ) {",
"    ///",
"    // Remove child from this instance\'s children.",
"    //warn",
"    // The child\'s parent is not edited; use caution to ensure that this pointer",
"    // is deallocated correctly.",
"    for (var children= this.children, i= 0, end= children.length; i<end; i++) {",
"      if (children[i]===child) {",
"        children.splice(i, 1);",
"        return;",
"      }",
"    }",
"  },",
"",
"  traverse: function(",
"    stream, ///(bd.test.space.stream) The stream to which to write the traversal.",
"    root    ///(boolean) If true, this is the root object of the traversal, and conversely.",
"  ) {",
"    ///",
"    // Traverses this subtree while preparing a script to execute.",
"    if (root) {",
"      var",
"        stack= [],",
"        p= this.parent;",
"      while (p && p!==bd.test.proc.root) {",
"        stack.push(p);",
"        p= p.parent;",
"      }",
"      for (var i= stack.length-1; i>=0; i--) {",
"        stream.push(stack[i], true);",
"      }",
"    }",
"    stream.push(this, true);",
"    for (var children= this.children, i= 0, end= children.length; i<end; i++) {",
"      children[i].traverse(stream, false);",
"    }",
"    stream.push(this, false);",
"    if (root) {",
"      for (i= 0, end= stack.length; i<end; i++) {",
"        stream.push(stack[i], false);",
"      }",
"    }",
"  },",
"",
"  traverseIn: function(",
"    space ///(bd.test.space) The space controlling this traversal.",
"  ) {",
"    ///",
"    // Execute any one-time preparations required for all tests under this node.",
"  },",
"",
"  traverseOut: function(",
"    space ///(bd.test.space) The space controlling this traversal.",
"  ) {",
"    ///",
"    // Execute any cleanup required after one-time preparations accomplished under traverseIn.",
"  },",
"",
"  exec: function(",
"    space ///(bd.test.space) The space controlling this traversal.",
"  ) {",
"    ///",
"    // Execute any each-time preparations required to execute a demonstration under this node. //If this",
"    // node is actually a demonstration, then execute the demonstration.",
"  },",
"",
"  unexec: function(",
"    space ///(bd.test.space) The space controlling this traversal.",
"  ) {",
"    ///",
"    // Reverse any each-time preparations accompished under exec",
"  }",
"});",
"dojo.mix(bd.test.proc, {",
"  failed:",
"    ///const",
"    // Object returned by scaffolds and/or demos to say that the procedure failed",
"    {},",
"",
"  map:",
"    ///",
"    // Map from bd.test.proc.id to bd.test.proc instance. //The machinery guarantees that",
"    // bd.test.proc.map[proc.id]===proc for some bd.test.proc instance proc.",
"    [null], // don\'t use id===0",
"",
"  get: function(",
"    moduleName ///(*bd.test.proc.get_.moduleName)",
"  ) {",
"    ///",
"    // Find the module given be moduleName in the test procedure tree. //If ",
"    // the module does not exist, then create a new module.",
"    // ",
"    //return",
"    //(bd.test.proc.module) The module which is identified by the full name moduleName.",
"    return bd.test.proc.get_(moduleName, true);",
"  },",
"",
"  find: function(",
"    moduleName ///(*bd.test.proc.get_.moduleName)",
"  ) {",
"    ///",
"    // Find the module given be moduleName in the test procedure tree.",
"    // ",
"    //return",
"    //(bd.test.proc.module) The module which is identified by the full name moduleName.",
"    //> A module with the full name moduleName exists.",
"    //(null)",
"    //> No module with the full name moduleName exists.",
"    return bd.test.proc.get_(moduleName, false);",
"  },",
"",
"  get_: function(",
"    moduleName, //(string) The full name (i.e., the name that is returned by ",
"                //bd.test.proc.getFullName) of the module to lookup.",
"    create      //(bool) Create the module if it does not already exist (or not).",
"  ) {",
"    // Find the module given be moduleName in the test procedure tree.",
"    // ",
"    //return",
"    //(bd.test.proc.module) The module which is identified by the full name moduleName.",
"    //> The module with the full name moduleName.",
"    //(null)",
"    //> No module with the full name moduleName exists and create was false.",
"",
"    if (!moduleName) {",
"      return bd.test.proc.root;",
"    }",
"    var",
"      names= moduleName.split(\"/\"),",
"      parent= bd.test.proc.root,",
"      i= 0,",
"      end= names.length;",
"    while (i<end) {",
"      var",
"        name= names[i++],",
"        nextParent= null;",
"      for (var children= parent.children, j= 0, jEnd= children.length; j<jEnd; j++) {",
"        if (children[j].name===name) {",
"          nextParent= children[j];",
"          break;",
"        }",
"      }",
"      if (!nextParent) {",
"        if (create) {",
"          nextParent= new bd.test.proc.module({name:name, parent:parent});",
"          dojo.publish(\"bd/test/proc/childrenChanged\", [parent]);",
"        } else {",
"          return null; //<null",
"                       //>The module does not exist and create was falsy.",
"        }",
"      } ",
"      parent= nextParent;",
"    }",
"    return parent; //<(bd.test.proc.module) The module instance with the name given by moduleName.",
"                   //>The module either existed on entry or was created.",
"  }",
"});",
"",
"//can\'t do this in the mixin above because the ctor needs bd.test.proc.map...",
"bd.test.proc.root=",
"  ///",
"  // Synthetic root: the mother of all test procedures.",
"  new bd.test.proc({name:\"__root__\"});",
"",
"bd.declare(",
"  ///",
"  // A tree of test descriptions and demonstrations. //Any tree",
"  // represented by a bd.test.proc.description instance will be a",
"  // subtree within a bd.test.proc.module instance.",
"",
"  //class name",
"  \"bd:test.proc.description\", ",
"",
"  //superclasses",
"  [bd.test.proc], ",
"",
"  //members",
"  {",
"  constructor: function(",
"    args,     ///(bd.test.proc.constructor.kwargs) Describes properties to mixin to new instance.",
"    scaffold, ///(bd.test.proc.scaffold, optional, {}) The scaffold required for the children of this description.",
"    children  ///(*bd.test.proc.constructor.module)",
"  ) {",
"    ///",
"    // Create a new instance.",
"    var i;",
"    if (scaffold && scaffold instanceof bd.test.proc.scaffold) {",
"      this.scaffold= scaffold;",
"      i= 2;",
"    } else {",
"      this.scaffold= {};",
"      i= 1;",
"    }",
"    for (var end= arguments.length; i<end; i++) {",
"      if (dojo.isArray(arguments[i])) {",
"        this.children= this.children.concat(arguments[i]);",
"      } else if (arguments[i]) {",
"        this.children.push(arguments[i]);",
"      }",
"    }",
"    this.setParentOfChildren();",
"  },",
"",
"  traverseIn: function(",
"    space",
"  ) {",
"    ///see-super",
"    if (this.scaffold.before && this.scaffold.execType===\"once\") {",
"      return this.scaffold.before(space);",
"    } else {",
"      return true;",
"    }",
"  },",
"",
"  traverseOut: function(",
"    space",
"  ) {",
"    ///see-super",
"    if (this.scaffold.after && this.scaffold.execType===\"once\") {",
"      return this.scaffold.after(space);",
"    } else {",
"      return true;",
"    }",
"  },",
"",
"  exec: function(",
"    space",
"  ) {",
"    ///see-super",
"    if (this.scaffold.before && this.scaffold.execType===\"each\") {",
"      return this.scaffold.before(space);",
"    } else {",
"      return true;",
"    }",
"  },",
"",
"  unexec: function(",
"    space",
"  ) {",
"    ///see-super",
"    if (this.scaffold.after && this.scaffold.execType===\"each\") {",
"      return this.scaffold.after(space);",
"    } else {",
"      return true;",
"    }",
"  }",
"});",
"",
"bd.declare(",
"  ///",
"  // A tree of test descriptions and demonstrations contained within a single",
"  // resource. //Individual instances may be loaded on demand and/or reloaded. ",
"  // This facilitates interative development of tests without having to",
"  // reload the page on each interaction.",
"",
"  //class name",
"  \"bd:test.proc.module\", ",
"",
"  //superclasses",
"  [bd.test.proc.description], ",
"",
"  //members",
"  {",
"  loadedVersion:",
"    ///",
"    // The bd.test.proc.loader.version at the time when this module was loaded. //",
"    // Zero indicates the module has not been loaded",
"    0,",
"",
"  constructor: function(",
"    args,    ///(bd.test.proc.constructor.kwargs) Describes properties to mixin to new instance.",
"    scaffold, ///(bd.test.proc.scaffold, optional, {}) The scaffold required for the children of this description.",
"    children ///(bd.test.testProc) The single non-module child of this module (additional ",
"             // children may be added after construction).",
"             //(array of bd.test.proc) The non-module children of this module.",
"  ) {",
"    ///",
"    // Create a new instance.",
"    this.loadedVersion= 0;",
"  },",
"",
"  getUrl: function() {",
"    ///",
"    // Get the URL for this module.",
"    //return",
"    //(string) The URL at which the resouce that defines the module resides.",
"    if (this.url) {",
"      return url;",
"    } else {",
"      return dojo.url(this.getFullName());",
"    }",
"  },",
"",
"  load: function() {",
"    ///",
"    // Retrieve and process the JavaScript resource associated with this module.",
"    bd.test.loader.load(this);",
"  },",
"",
"  reload: function() {",
"    ///",
"    // Retreive and process the JavaScript resource associated with this module;",
"    // force reloading the resource if it has already been loaded",
"    bd.test.loader.flushCache();",
"    this.load();",
"  },",
"",
"  set: function(",
"    args,     ///(bd.test.proc.constructor.kwargs) Describes properties to mixin to new instance.",
"    scaffold, ///(bd.test.proc.scaffold, optional, {}) The scaffold required for the children of this description.",
"    children  ///(bd.test.testProc) The single non-module child of this module.",
"              //(array of bd.test.proc) The non-module children of this module.",
"  ) {",
"    ///",
"    // Set the nonmodule children for this module. //Previous children that are not modules are discarded",
"",
"    //erase all the non-module children...",
"    var clean= [];",
"    dojo.forEach(this.children, function(child) {",
"      if (child instanceof bd.test.proc.module) {",
"        clean.push(child);",
"      }",
"    });",
"    this.children= clean;",
"",
"    if (dojo.isString(args)) {",
"      dojo.mix(this, getNameAndDoc(args));",
"    } else {",
"      dojo.mix(this. args);",
"    }",
"",
"    var i;",
"    if (scaffold && scaffold instanceof bd.test.proc.scaffold) {",
"      this.scaffold= scaffold;",
"      i= 2;",
"    } else {",
"      this.scaffold= {};",
"      i= 1;",
"    }",
"    for (var end= arguments.length; i<end; i++) {",
"      if (dojo.isArray(arguments[i])) {",
"        this.children= this.children.concat(arguments[i]);",
"      } else if (arguments[i]) {",
"        this.children.push(arguments[i]);",
"      }",
"    }",
"    this.setParentOfChildren();",
"    dojo.publish(\"bd/test/proc/childrenChanged\", [this]);",
"  }",
"});",
"",
"bd.declare(",
"  ///",
"  // Trivial class that holds scaffold functions.",
"",
"  //class name",
"  \"bd:test.proc.scaffold\", ",
"",
"  //superclasses",
"  [], ",
"",
"  //members",
"  {",
"  constructor: function(",
"    execType, ///(\"once\") Execute this scaffold once for the subtree.",
"              //(\"each\") execute this scaffold once for each demonstration while traversing the subtree.",
"    before,   ///(bd.test.scaffoldFunction) The function to execute while traversing in.",
"    after     ///(bd.test.scaffoldFunction) The function to execute while traversing out.",
"  ) {",
"    ///",
"    // Create a new instance.",
"    bd.docGen(\"overload\",",
"      function(",
"        execType,",
"        procs ///(array of bd.test.scaffoldFunction) The functions to execute while traversing in (procs[0]) and out (procs[1])",
"      ) {",
"        ///",
"        // Creates a new instance with the before property given by `procs[0]` and the after property given bye `procs[1]`.",
"      }",
"    );",
"    this.execType= execType;",
"    if (bd.isArray(before)) {",
"      this.before= before[0];",
"      this.after= before[1];",
"    } else {",
"      if (dojo.isFunction(before)) {",
"        this.before= before;",
"      }",
"      if (dojo.isFunction(after)) {",
"        this.after= after;",
"      }",
"    }",
"  }",
"});",
"",
"bd.test.reflectorScaffold= function(",
"    execType,        ///(*test.proc.scaffold.constructor.execType)",
"    context,         ///(*bd.hijack.context)",
"    functionName,    ///(*bd.hijack.functionName, optional)",
"    hijacker,        ///(function, optional, undefined) The replacement function.",
"    hijackerContext, ///(object, optional, bd.global) The context in which to call hijacker; falsy implies bd.global",
"    chain            ///(boolean, optional, false) Call the original function automatically after the hijacker finishes.",
"  ) {",
"    ///",
"    // Creates and returns a scaffold that hijacks/restores a function.",
"    ///",
"    // The scaffold\'s execType is set as given. The scaffold\'s before function hijacks context[functionName] with the",
"    // provided hijacker (if any), or a default hijacker as follows:",
"    //code",
"    // function() {",
"    //   arguments.callee.args= bd.array(arguments);",
"    // }",
"    ///",
"    // This allows test code to inspect what arguments where actually sent to a hijacked function without executing",
"    // that function (assuming chain is falsy).",
"    // ",
"    // The scaffold\'s after function restores the original function.",
"    // ",
"    // For example, dojo.style could be hijacked to see what styles are applied consequent to some exercise on a widget",
"    // that is in fact a mock and therefore doesn\'t have a dom node as follows:",
"    //code",
"    // var bd.test.describe(",
"    //   \"Exercise the method turnPsychodelic and check correct styling is applied via dojo.style\",",
"    //   test.reflectorScaffold(all, dojo, \"style\", function(node) {",
"    //     var args= bd.array(arguments);",
"    //     //stuff the arugments where we can get at them",
"    //     dojo.style.args= args;",
"    //     if (!node.mock) {",
"    //       return dojo.style.original.apply(dojo, args);",
"    //     }",
"    //     return 0;",
"    //   }),",
"    //   bd.test.demo(function() {",
"    //     myMockWidget.turnPsychodelic();",
"    //     the(dojo.style.args).hasValue(expected);",
"    //   })",
"    // );",
"    ///",
"    // When the description instance is executed, the before scaffold will hijack the dojo.style function. The demo",
"    // instance uses the hijacked function to check to see what actually happened when turnPsychodelic was called. Finally,",
"    // the after scaffold returns dojo.style to its original functionality.",
"    // ",
"    // Also notice in that this example chooses to forward some calls (namely, nodes that aren\'t mocks) to the ",
"    // actual dojo.style call. In this particular example (taken from a real test), the call ",
"    // `the(dojo.style.args).hasValue(expected)` might cause other code to execute that needs the real dojo.style service.",
"    var ",
"      result= 0,",
"      defaultHijacker= function() {",
"        arguments.callee.args= bd.array(arguments);          ",
"      },",
"      before= function() {",
"        result= bd.hijack(context, functionName, hijacker||defaultHijacker, hijackerContext, chain);",
"      },",
"      after= function() {",
"        bd.hijack(result);",
"      };",
"    return new bd.test.proc.scaffold(execType, before, after);",
"  };",
"",
"bd.declare(",
"  ///",
"  // A single demonstraction of functionality (test). //A bd.test.proc.demo",
"  // controls the execution of a function that runs some code, checks results,",
"  // and reports findings. A bd.test.proc.demo is a leaf node in the test tree.",
"",
"  //class name",
"  \"bd:test.proc.demo\", ",
"",
"  //superclasses",
"  [bd.test.proc],",
"",
"  //members",
"  {",
"  preamble:function(args, program) {",
"    if (arguments.length==1) {",
"      //args is missing...",
"      return [{}, args];",
"    } else {",
"      return [args, program];",
"    }",
"  },",
"",
"  constructor: function(",
"    args,    ///(bd.test.proc.constructor.kwargs) Describes properties to mixin to new instance.",
"    program ///(bd.test.demoFunction) The function that implements the demonstration",
"  ) {",
"    ///",
"    // Creates a new instance. //If neither name nor doc is given, then name is set to bd.test.proc.demo.defaultName.",
"    if (!this.name && !this.doc) {",
"      this.name= bd.test.proc.demo.defaultName;",
"    }",
"    //if program is missing, assume that args was missing and args is actually program",
"    this.program= program || args;",
"  },",
"",
"  traverseIn: function(",
"    space ///(bd.test.space) The space controlling this traversal.",
"  ) {",
"    ///",
"    // Execute the test function as given by the program property.",
"    var",
"      executer= bd.test.proc.demo.createExecuter(this, space),",
"      p= this.parent;",
"    while (p && p!==bd.test.proc.root) {",
"      executer.push(p);",
"      p= p.parent;",
"    }",
"    return executer.execute();",
"  },",
"",
"  traverseOut: function(",
"    space ///(bd.test.space) The space controlling this traversal.",
"  ){",
"    ///",
"    // No-op for this class.",
"  },",
"",
"  exec: function(",
"    space",
"  ) {",
"    ///see-super",
"    space.startDemo(this);",
"    return this.program(space);",
"  },",
"",
"  unexec: function(",
"    space",
"  ) {",
"    ///see-super",
"    space.endDemo(this);",
"  }",
"});",
"dojo.mix(bd.test.proc.demo, {",
"  defaultName: ",
"    ///",
"    // The default name for a bd.test.proc.demo instance.",
"    \"Demonstration\",",
"",
"  executer: {",
"    // An object that controls the execution of a single bd.test.proc.demo program.",
"",
"    push: function(",
"      proc",
"    ) {",
"      this.buffer.unshift({proc:proc, traverseIn:true});",
"      this.buffer.push({proc:proc, traverseIn:false});",
"    },",
"",
"    exhausted: function() {",
"      return this.current>=this.buffer.length;",
"    },",
"",
"    get: function() {",
"      return this.buffer[this.current++];",
"    },",
"",
"    skip: function() {",
"      var item= this.buffer[this.current-1];",
"      if (item && item.traverseIn) {",
"        var target= item.proc;",
"        while (this.buffer[this.current].proc!=target) {",
"          this.current++;",
"        }",
"      }",
"    },",
"",
"    execute: function() {",
"      var",
"        space= this.space,",
"        result= true,",
"        next;",
"      bd.test.pushActiveSpace(space);",
"      while(!this.exhausted()) {",
"        next= this.get();",
"        try {",
"          if (next.traverseIn) {",
"            result= next.proc.exec(space);",
"          } else {",
"            result= next.proc.unexec(space);",
"          }",
"        } catch (e) {",
"          //unexpected exception...",
"          space.unexpectedException(e, next.proc, next.proc===this.demoProc, \"executing\", next.traverseIn);",
"          this.skip();",
"          //the error has been handled; therefore...",
"          result= true;",
"        }",
"        if (result instanceof dojo.Deferred) {",
"          result.addCallbacks(",
"            dojo.hitch(this, function(result) {",
"              if (result===bd.test.proc.failed) {",
"                if (next.proc===this.demoProc) {",
"                  space.demoFailed(next.proc);",
"                } else {",
"                  space.scaffoldFailed(next.proc, next.traverseIn);",
"                }",
"                this.skip();",
"              }",
"              return this.execute();",
"            }),",
"            dojo.hitch(this, function(e) {",
"              space.unexpectedException(e, next.proc, next.proc===this.demoProc, \"executing\", next.traverseIn);",
"              this.skip();",
"              return this.execute();",
"            })",
"          );",
"          break;",
"        } else if (result===bd.test.proc.failed) {",
"          if (next.proc===this.demoProc) {",
"            space.demoFailed(next.proc);",
"          } else {",
"            space.scaffoldFailed(next.proc, next.traverseIn);",
"          }",
"          this.skip();",
"          //the error has been handled; therefore...",
"          result= true;",
"        }",
"      }",
"      bd.test.popActiveSpace();",
"      //the error have already been processed...",
"      return result;",
"    }",
"  },",
"",
"  createExecuter: function(",
"    proc,",
"    space",
"  ) {",
"    return dojo.delegate(bd.test.proc.demo.executer, {buffer:[{proc:proc, traverseIn:true}, {proc:proc, traverseIn:false}], current:0, space:space, demoProc:proc});",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.test.proc":{
type:
Tclass,
sdoc:
["The base class for test procedure classes. "],
ldoc:
["The base class for test procedure classes. Defines the minimum interface for\ntest procedure subclasses."],
src:
"bd/test/proc",
loc: [18,0,218,2],
module:"bd/test/proc"}
,"bd.test.proc.constructor":{
type:
Tfunction,
sdoc:
["Creates a new instance."],
imember:1,
ldoc:
["The new object is initialized with the following property values:",
[CODE,"{\n  name:\"\"\n  doc:\"\",\n  parent:null,\n  children:[]\n}"],
"If createArgs is not a string, it is mixed into the new instance possibly changing these initial values.\nIf parent is given, then the new object is added to the children of the given parent.\n\nThe new instance, o, has the property bd.test.proc.map[o.id]===o (if createArgs gives a value of id, it is ignored)."],
params:
[["args",[["kwargs",
[]],
["string with no spaces",
["The value to initialize the name property."]],
["string with spaces",
["The value to initialize the rdoc property."]]]]],
loc: [31,2,86,3]}
,"bd.test.proc.constructor.kwargs":{
type:
Tvariable,
sdoc:
["Describes how to initialize a bd.test.proc instance."],
ldoc:
[],
props:
["doc",{
type:
Tvariable,
loc: [57,8,57,17],
types:
[["string",
["The documentation for the procedure."]]]}
,
"name",{
type:
Tvariable,
loc: [60,8,60,17],
types:
[["string",
["The name of the procedure."]]]}
,
"parent",{
type:
Tvariable,
loc: [63,8,63,17],
types:
[["bd.test.proc",
["The parent of the procedure."]]]}
,
"children",{
type:
Tvariable,
loc: [66,8,66,17],
types:
[["array or bd.test.proc",
["The children of this procedure."]]]}
],
loc: [52,24,67,5]}
,"bd.test.proc.destroy":{
type:
Tfunction,
sdoc:
["Destroy this instance. "],
imember:1,
ldoc:
["Destroy this instance. Recursively destroy all children, and remove this\nobject from its parent and the bd.test.proc.map. Since these are the only\nreferences the test framework keeps of this instance, it should be garbage\ncollected."],
loc: [88,2,103,3]}
,"bd.test.proc.getFullName":{
type:
Tfunction,
sdoc:
["Get the full path and name of this module."],
imember:1,
ldoc:
[],
returns:
[["string",
["Concatentation of all parents, starting from the root; each name is separated by a \"/\"."]]],
loc: [117,2,130,3]}
,"bd.test.proc.setParentOfChildren":{
type:
Tfunction,
sdoc:
["Set the parent of all of this instance\'s children to this instance."],
imember:1,
ldoc:
[],
loc: [136,2,142,3]}
,"bd.test.proc.removeChild":{
type:
Tfunction,
sdoc:
["Remove child from this instance\'s children."],
imember:1,
ldoc:
[[WARN,"The child\'s parent is not edited; use caution to ensure that this pointer\nis deallocated correctly."]],
params:
[["child",[["bd.test.proc",
["A child of this instance."]]]]],
loc: [144,2,158,3]}
,"bd.test.proc.traverse":{
type:
Tfunction,
sdoc:
["Traverses this subtree while preparing a script to execute."],
imember:1,
ldoc:
[],
params:
[["stream",[["bd.test.space.stream",
["The stream to which to write the traversal."]]]],
["root",[["boolean",
["If true, this is the root object of the traversal, and conversely."]]]]],
loc: [160,2,188,3]}
,"bd.test.proc.traverseIn":{
type:
Tfunction,
sdoc:
["Execute any one-time preparations required for all tests under this node."],
imember:1,
ldoc:
[],
params:
[["space",[["bd.test.space",
["The space controlling this traversal."]]]]],
loc: [190,2,195,3]}
,"bd.test.proc.traverseOut":{
type:
Tfunction,
sdoc:
["Execute any cleanup required after one-time preparations accomplished under traverseIn."],
imember:1,
ldoc:
[],
params:
[["space",[["bd.test.space",
["The space controlling this traversal."]]]]],
loc: [197,2,202,3]}
,"bd.test.proc.exec":{
type:
Tfunction,
sdoc:
["Execute any each-time preparations required to execute a demonstration under this node. "],
imember:1,
ldoc:
["Execute any each-time preparations required to execute a demonstration under this node. If this\nnode is actually a demonstration, then execute the demonstration."],
params:
[["space",[["bd.test.space",
["The space controlling this traversal."]]]]],
loc: [204,2,210,3]}
,"bd.test.proc.unexec":{
type:
Tfunction,
sdoc:
["Reverse any each-time preparations accompished under exec"],
imember:1,
ldoc:
[],
params:
[["space",[["bd.test.space",
["The space controlling this traversal."]]]]],
loc: [212,2,217,3]}
,"bd.test.proc.root":{
type:
Tvariable,
sdoc:
["Synthetic root: the mother of all test procedures."],
ldoc:
[],
src:
"bd/test/proc",
loc: [305,0,308,37],
module:"bd/test/proc"}
,"bd.test.proc.description":{
type:
Tclass,
sdoc:
["A tree of test descriptions and demonstrations. "],
ldoc:
["A tree of test descriptions and demonstrations. Any tree\nrepresented by a bd.test.proc.description instance will be a\nsubtree within a bd.test.proc.module instance."],
src:
"bd/test/proc",
loc: [310,0,392,2],
supers:
["bd.test.proc"],
module:"bd/test/proc"}
,"bd.test.proc.description.constructor":{
type:
Tfunction,
sdoc:
["Create a new instance."],
imember:1,
ldoc:
[],
params:
[["args",[["bd.test.proc.constructor.kwargs",
["Describes properties to mixin to new instance."]]]],
["scaffold",[["bd.test.proc.scaffold, optional, {}",
["The scaffold required for the children of this description."]]]],
["children",[["*bd.test.proc.constructor.module",
[]]]]],
loc: [324,2,347,3]}
,"bd.test.proc.description.traverseIn":{
type:
Tfunction,
sdoc:
["/see-super"],
imember:1,
ldoc:
[],
params:
[["space",[]]],
loc: [349,2,358,3]}
,"bd.test.proc.description.traverseOut":{
type:
Tfunction,
sdoc:
["/see-super"],
imember:1,
ldoc:
[],
params:
[["space",[]]],
loc: [360,2,369,3]}
,"bd.test.proc.description.exec":{
type:
Tfunction,
sdoc:
["/see-super"],
imember:1,
ldoc:
[],
params:
[["space",[]]],
loc: [371,2,380,3]}
,"bd.test.proc.description.unexec":{
type:
Tfunction,
sdoc:
["/see-super"],
imember:1,
ldoc:
[],
params:
[["space",[]]],
loc: [382,2,391,3]}
,"bd.test.proc.module":{
type:
Tclass,
sdoc:
["A tree of test descriptions and demonstrations contained within a single\nresource. "],
ldoc:
["A tree of test descriptions and demonstrations contained within a single\nresource. Individual instances may be loaded on demand and/or reloaded.\nThis facilitates interative development of tests without having to\nreload the page on each interaction."],
src:
"bd/test/proc",
loc: [394,0,495,2],
supers:
["bd.test.proc.description"],
module:"bd/test/proc"}
,"bd.test.proc.module.loadedVersion":{
type:
Tvariable,
sdoc:
["The bd.test.proc.loader.version at the time when this module was loaded. "],
imember:1,
ldoc:
["The bd.test.proc.loader.version at the time when this module was loaded. \nZero indicates the module has not been loaded"],
loc: [409,2,413,5]}
,"bd.test.proc.module.constructor":{
type:
Tfunction,
sdoc:
["Create a new instance."],
imember:1,
ldoc:
[],
params:
[["args",[["bd.test.proc.constructor.kwargs",
["Describes properties to mixin to new instance."]]]],
["scaffold",[["bd.test.proc.scaffold, optional, {}",
["The scaffold required for the children of this description."]]]],
["children",[["bd.test.testProc",
["The single non-module child of this module (additional\n children may be added after construction)."]],
["array of bd.test.proc",
["The non-module children of this module."]]]]],
loc: [415,2,425,3]}
,"bd.test.proc.module.getUrl":{
type:
Tfunction,
sdoc:
["Get the URL for this module."],
imember:1,
ldoc:
[],
returns:
[["string",
["The URL at which the resouce that defines the module resides."]]],
loc: [427,2,437,3]}
,"bd.test.proc.module.load":{
type:
Tfunction,
sdoc:
["Retrieve and process the JavaScript resource associated with this module."],
imember:1,
ldoc:
[],
loc: [439,2,443,3]}
,"bd.test.proc.module.reload":{
type:
Tfunction,
sdoc:
["Retreive and process the JavaScript resource associated with this module;\nforce reloading the resource if it has already been loaded"],
imember:1,
ldoc:
[],
loc: [445,2,451,3]}
,"bd.test.proc.module.set":{
type:
Tfunction,
sdoc:
["Set the nonmodule children for this module. "],
imember:1,
ldoc:
["Set the nonmodule children for this module. Previous children that are not modules are discarded"],
params:
[["args",[["bd.test.proc.constructor.kwargs",
["Describes properties to mixin to new instance."]]]],
["scaffold",[["bd.test.proc.scaffold, optional, {}",
["The scaffold required for the children of this description."]]]],
["children",[["bd.test.testProc",
["The single non-module child of this module."]],
["array of bd.test.proc",
["The non-module children of this module."]]]]],
loc: [453,2,494,3]}
,"bd.test.proc.scaffold":{
type:
Tclass,
sdoc:
["Trivial class that holds scaffold functions."],
ldoc:
[],
src:
"bd/test/proc",
loc: [497,0,539,2],
module:"bd/test/proc"}
,"bd.test.proc.scaffold.constructor":{
type:
Tfunction,
sdoc:
["Create a new instance."],
imember:1,
ldoc:
[],
params:
[["execType",[["\"once\"",
["Execute this scaffold once for the subtree."]],
["\"each\"",
["execute this scaffold once for each demonstration while traversing the subtree."]]]],
["before",[["bd.test.scaffoldFunction",
["The function to execute while traversing in."]]]],
["after",[["bd.test.scaffoldFunction",
["The function to execute while traversing out."]]]]],
overloads:
[{
type:
Tfunction,
sdoc:
["Creates a new instance with the before property given by `procs[0]` and the after property given bye `procs[1]`."],
ldoc:
[],
params:
[["execType",[]],
["procs",[["array of bd.test.scaffoldFunction",
["The functions to execute while traversing in (procs[0]) and out (procs[1])"]]]]],
loc: [518,6,524,7]}
],
loc: [509,2,538,3]}
,"bd.test.reflectorScaffold":{
type:
Tfunction,
sdoc:
["Creates and returns a scaffold that hijacks/restores a function."],
ldoc:
["The scaffold\'s execType is set as given. The scaffold\'s before function hijacks context[functionName] with the\nprovided hijacker (if any), or a default hijacker as follows:",
[CODE,"function() {\n  arguments.callee.args= bd.array(arguments);\n}"],
"This allows test code to inspect what arguments where actually sent to a hijacked function without executing\nthat function (assuming chain is falsy).\n\nThe scaffold\'s after function restores the original function.\n\nFor example, dojo.style could be hijacked to see what styles are applied consequent to some exercise on a widget\nthat is in fact a mock and therefore doesn\'t have a dom node as follows:",
[CODE,"var bd.test.describe(\n  \"Exercise the method turnPsychodelic and check correct styling is applied via dojo.style\",\n  test.reflectorScaffold(all, dojo, \"style\", function(node) {\n    var args= bd.array(arguments);\n    //stuff the arugments where we can get at them\n    dojo.style.args= args;\n    if (!node.mock) {\n      return dojo.style.original.apply(dojo, args);\n    }\n    return 0;\n  }),\n  bd.test.demo(function() {\n    myMockWidget.turnPsychodelic();\n    the(dojo.style.args).hasValue(expected);\n  })\n);"],
"When the description instance is executed, the before scaffold will hijack the dojo.style function. The demo\ninstance uses the hijacked function to check to see what actually happened when turnPsychodelic was called. Finally,\nthe after scaffold returns dojo.style to its original functionality.\n\nAlso notice in that this example chooses to forward some calls (namely, nodes that aren\'t mocks) to the\nactual dojo.style call. In this particular example (taken from a real test), the call"],
params:
[["execType",[["*test.proc.scaffold.constructor.execType",
[]]]],
["context",[["*bd.hijack.context",
[]]]],
["functionName",[["*bd.hijack.functionName, optional",
[]]]],
["hijacker",[["function, optional, undefined",
["The replacement function."]]]],
["hijackerContext",[["object, optional, bd.global",
["The context in which to call hijacker; falsy implies bd.global"]]]],
["chain",[["boolean, optional, false",
["Call the original function automatically after the hijacker finishes."]]]]],
src:
"bd/test/proc",
loc: [541,0,603,3],
types:
[["dojo.style.args",
[".hasValue(expected)` might cause other code to execute that needs the real dojo.style service."]]],
module:"bd/test/proc"}
,"bd.test.proc.demo":{
type:
Tclass,
sdoc:
["A single demonstraction of functionality (test). "],
ldoc:
["A single demonstraction of functionality (test). A bd.test.proc.demo\ncontrols the execution of a function that runs some code, checks results,\nand reports findings. A bd.test.proc.demo is a leaf node in the test tree."],
src:
"bd/test/proc",
loc: [605,0,677,2],
supers:
["bd.test.proc"],
module:"bd/test/proc"}
,"bd.test.proc.demo.constructor":{
type:
Tfunction,
sdoc:
["Creates a new instance. "],
imember:1,
ldoc:
["Creates a new instance. If neither name nor doc is given, then name is set to bd.test.proc.demo.defaultName."],
params:
[["args",[["bd.test.proc.constructor.kwargs",
["Describes properties to mixin to new instance."]]]],
["program",[["bd.test.demoFunction",
["The function that implements the demonstration"]]]]],
loc: [628,2,639,3]}
,"bd.test.proc.demo.traverseIn":{
type:
Tfunction,
sdoc:
["Execute the test function as given by the program property."],
imember:1,
ldoc:
[],
params:
[["space",[["bd.test.space",
["The space controlling this traversal."]]]]],
loc: [641,2,654,3]}
,"bd.test.proc.demo.traverseOut":{
type:
Tfunction,
sdoc:
["No-op for this class."],
imember:1,
ldoc:
[],
params:
[["space",[["bd.test.space",
["The space controlling this traversal."]]]]],
loc: [656,2,661,3]}
,"bd.test.proc.demo.exec":{
type:
Tfunction,
sdoc:
["/see-super"],
imember:1,
ldoc:
[],
params:
[["space",[]]],
loc: [663,2,669,3]}
,"bd.test.proc.demo.unexec":{
type:
Tfunction,
sdoc:
["/see-super"],
imember:1,
ldoc:
[],
params:
[["space",[]]],
loc: [671,2,676,3]}
,"modules.bd/test/proc":{
type:
Tmodule,
sdoc:
["Defines the Backdraft test framework\'s test procedure class hierarchy."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/test/proc",
loc: [0,0,778,2]}
,"resources.bd/test/publisher":{
type:
Tresource,
sdoc:
["Defines the module bd/test/publisher"],
src:
"bd/test/publisher",
modules:
["bd/test/publisher"],
code:
["dojo.def(\"bd/test/publisher\", [",
"  \"dojo\", \"bd\", \"bd/test/namespace\"",
"], function(dojo, bd) {",
"///",
"// Defines the Backdraft test framework publishing machinery.",
"",
"var spaces= \"          \";",
"for (var i= 0; i<20; i++) {",
"  spaces+= \" \";",
"}",
"",
"bd.declare(",
"  ///",
"  // Publishes test messages. //The implementation publishes the messages to the debug console. Further, handlers for",
"  // all of  messages published by the Backdraft test framework are defined. These default behaviors can be",
"  // modified by deriving a subclass from bd.test.publisher. Since the class machinery is an extremely simple and",
"  // superclass methods are rarely applied from overrides, default behavior can also be modified by providing overrides",
"  // to the constructor.",
"",
"  //class name",
"  \"bd:test.publisher\", ",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  {",
"  indentSize:",
"    ///",
"    // The number of spaces to indent for each indent unit as given by the property `bd.test.publisher.indentValue`.",
"    5,",
"",
"  indentValue:",
"    ///",
"    // The number of indents to write before outputing the next message.",
"    0,",
"",
"  spaces:",
"    ///",
"    // A string of 200 spaces; convenient for formatting indents.",
"    spaces,",
"",
"  constructor: function(",
"    args",
"  ) {",
"    ///",
"    // Creates a new object.  //Mixes args into the new instance. This is a convenient technique to install",
"    // customized message handlers.",
"",
"    dojo.mix(this,  args);",
"  },",
"",
"  indent: function(",
"    delta",
"  ) {",
"    ///",
"    // Adjusts this.indentValue by delta (delta can be negative).",
"    this.indentValue+= delta;",
"  },",
"",
"  write: function(",
"    messageText",
"  ) {",
"    ///",
"    // Writes messageText. Default implementation writes to console; override or connect to do something interesting.",
"    console.log(spaces.substring(0, (this.indentValue * this.indentSize)) + messageText);",
"  },",
"",
"  publish: function(",
"    message,",
"    vargs",
"  ) {",
"    ///",
"    // Publishes message. //The message is published as follows:",
"    //",
"    // 1. Delegates to this[message] iff this[message] is truthy (it must be a function if it is truthy).",
"    // 2. Otherwise, no-op if this[message] is not undefined.",
"    // 3. Otherwise, calls this.write(message).",
"",
"    if (this[message]===false) {",
"      // explicitly do _not_ publish a message...",
"      return;",
"    } else if (this[message]) {",
"      // a handler exists for this message...",
"      this[message].apply(this, arguments);",
"    } else {",
"      // this[message]===undefined...",
"      this.write(message);",
"    }",
"  },",
"",
"  traverseIn: function(",
"    message,",
"    proc",
"  ) {",
"    ///",
"    // If proc.doc or proc.name exist then write it (prefer proc.doc) at the current indent level. Then unconditionally delta indent by 1.",
"    proc && this.write(proc.log() + \"\\n\");",
"    this.indent(1);",
"    if (proc && proc.program) {",
"      this.write(proc.program.toString() + \"\\n\");",
"    }",
"  },",
"",
"  traverseOut: function(",
"    message,",
"    proc",
"  ) {",
"    ///",
"    // Delta indent by -1.",
"    this.indent(-1);",
"  },",
"",
"  scaffoldFailed: function() {",
"    ///",
"    // Write \"SUBTREE ABORTED: scaffolding failed.\\n\" at the current indent level.",
"    this.write(\"SUBTREE ABORTED: scaffolding failed.\\n\");",
"  },",
"",
"  scaffoldThrew: function() {",
"    ///",
"    // Write \"SUBTREE ABORTED: scaffolding threw exception.\\n\" at the current indent level.",
"    this.write(\"SUBTREE ABORTED: scaffolding threw exception.\\n\");",
"  },",
"",
"  startDemo: function(",
"    message,",
"    proc",
"  ) {",
"    ///",
"    // Delta indent by 1 and then write the current indent level without a new-line.",
"    if (proc && proc.traits && proc.traits.extern) {",
"      this.write(\"external test follows...\\n\");",
"      this.indent(1);",
"    } else {",
"      this.indent(1);",
"    }",
"  },",
"",
"  endDemo: function(",
"    message,",
"    proc",
"  ) {",
"    ///",
"    // Close the current line with a newline and delta indent by -1.",
"    if (proc && proc.traits && proc.traits.extern) {",
"      this.indent(-1);",
"      this.write(\"end of external test.\\n\");",
"    } else {",
"      // Write a new-line and delta indent by -1.",
"      this.write(\"\\n\");",
"      this.indent(-1);",
"    }",
"  },",
"",
"  demoThrew: function(",
"    message,",
"    proc",
"  ) {",
"    ///",
"    // Write \"TEST ABORTED: demonstration threw exception.\\n\" at the current indent level.",
"    this.write(\"TEST ABORTED: demonstration threw exception.\\n\");",
"  },",
"",
"  result: function(",
"    message,",
"    arg",
"  ) {",
"    ///",
"    // Write the arg, interpretted as a test result. //Typically arg is something from bd.test.result:",
"    //",
"    // 1. Iff arg is falsey, write \"F\";",
"    // 2. Otherwise, iff arg.todo exists, write \"TODO\";",
"    // 3. Otherwise, iff arg.pass, write \"-\";",
"    // 4. Otherwise, write \"F\"",
"    //",
"    if (arg) {",
"      if (arg.todo!==undefined) {",
"        this.write(\"TODO\");",
"      } else if (arg.pass) {",
"        this.write(\"-\");",
"      } else {",
"        this.write(\"F\");",
"      }",
"    } else {",
"      this.write(\"F\");",
"    }",
"  },",
"",
"  abort: function() {",
"    ///",
"    // Write \"\\n\\n*** ABORT ***\\n\\n\"",
"    this.write(\"\\n\\n*** ABORT ***\\n\\n\");",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.test.publisher":{
type:
Tclass,
sdoc:
["Publishes test messages. "],
ldoc:
["Publishes test messages. The implementation publishes the messages to the debug console. Further, handlers for\nall of  messages published by the Backdraft test framework are defined. These default behaviors can be\nmodified by deriving a subclass from bd.test.publisher. Since the class machinery is an extremely simple and\nsuperclass methods are rarely applied from overrides, default behavior can also be modified by providing overrides\nto the constructor."],
src:
"bd/test/publisher",
loc: [11,0,194,2],
module:"bd/test/publisher"}
,"bd.test.publisher.indentSize":{
type:
Tvariable,
sdoc:
["The number of spaces to indent for each indent unit as given by the property `bd.test.publisher.indentValue`."],
imember:1,
ldoc:
[],
loc: [27,2,30,5]}
,"bd.test.publisher.indentValue":{
type:
Tvariable,
sdoc:
["The number of indents to write before outputing the next message."],
imember:1,
ldoc:
[],
loc: [32,2,35,5]}
,"bd.test.publisher.spaces":{
type:
Tvariable,
sdoc:
["A string of 200 spaces; convenient for formatting indents."],
imember:1,
ldoc:
[],
loc: [37,2,40,10]}
,"bd.test.publisher.constructor":{
type:
Tfunction,
sdoc:
["Creates a new object.  "],
imember:1,
ldoc:
["Creates a new object.  Mixes args into the new instance. This is a convenient technique to install\ncustomized message handlers."],
params:
[["args",[]]],
loc: [42,2,50,3]}
,"bd.test.publisher.indent":{
type:
Tfunction,
sdoc:
["Adjusts this.indentValue by delta (delta can be negative)."],
imember:1,
ldoc:
[],
params:
[["delta",[]]],
loc: [52,2,58,3]}
,"bd.test.publisher.write":{
type:
Tfunction,
sdoc:
["Writes messageText. Default implementation writes to console; override or connect to do something interesting."],
imember:1,
ldoc:
[],
params:
[["messageText",[]]],
loc: [60,2,66,3]}
,"bd.test.publisher.publish":{
type:
Tfunction,
sdoc:
["Publishes message. "],
imember:1,
ldoc:
["Publishes message. The message is published as follows:\n\n1. Delegates to this[message] iff this[message] is truthy (it must be a function if it is truthy).\n2. Otherwise, no-op if this[message] is not undefined.\n3. Otherwise, calls this.write(message)."],
params:
[["message",[]],
["vargs",[]]],
loc: [68,2,89,3]}
,"bd.test.publisher.traverseIn":{
type:
Tfunction,
sdoc:
["If proc.doc or proc.name exist then write it (prefer proc.doc) at the current indent level. Then unconditionally delta indent by 1."],
imember:1,
ldoc:
[],
params:
[["message",[]],
["proc",[]]],
loc: [91,2,102,3]}
,"bd.test.publisher.traverseOut":{
type:
Tfunction,
sdoc:
["Delta indent by -1."],
imember:1,
ldoc:
[],
params:
[["message",[]],
["proc",[]]],
loc: [104,2,111,3]}
,"bd.test.publisher.scaffoldFailed":{
type:
Tfunction,
sdoc:
["Write \"SUBTREE ABORTED: scaffolding failed.\\n\" at the current indent level."],
imember:1,
ldoc:
[],
loc: [113,2,117,3]}
,"bd.test.publisher.scaffoldThrew":{
type:
Tfunction,
sdoc:
["Write \"SUBTREE ABORTED: scaffolding threw exception.\\n\" at the current indent level."],
imember:1,
ldoc:
[],
loc: [119,2,123,3]}
,"bd.test.publisher.startDemo":{
type:
Tfunction,
sdoc:
["Delta indent by 1 and then write the current indent level without a new-line."],
imember:1,
ldoc:
[],
params:
[["message",[]],
["proc",[]]],
loc: [125,2,137,3]}
,"bd.test.publisher.endDemo":{
type:
Tfunction,
sdoc:
["Close the current line with a newline and delta indent by -1."],
imember:1,
ldoc:
[],
params:
[["message",[]],
["proc",[]]],
loc: [139,2,153,3]}
,"bd.test.publisher.demoThrew":{
type:
Tfunction,
sdoc:
["Write \"TEST ABORTED: demonstration threw exception.\\n\" at the current indent level."],
imember:1,
ldoc:
[],
params:
[["message",[]],
["proc",[]]],
loc: [155,2,162,3]}
,"bd.test.publisher.result":{
type:
Tfunction,
sdoc:
["Write the arg, interpretted as a test result. "],
imember:1,
ldoc:
["Write the arg, interpretted as a test result. Typically arg is something from bd.test.result:\n\n1. Iff arg is falsey, write \"F\";\n2. Otherwise, iff arg.todo exists, write \"TODO\";\n3. Otherwise, iff arg.pass, write \"-\";\n4. Otherwise, write \"F\""],
params:
[["message",[]],
["arg",[]]],
loc: [164,2,187,3]}
,"bd.test.publisher.abort":{
type:
Tfunction,
sdoc:
["Write \"\\n\\n*** ABORT ***\\n\\n\""],
imember:1,
ldoc:
[],
loc: [189,2,193,3]}
,"modules.bd/test/publisher":{
type:
Tmodule,
sdoc:
["Defines the Backdraft test framework publishing machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/test/publisher",
loc: [0,0,196,2]}
,"resources.bd/test/result":{
type:
Tresource,
sdoc:
["Defines the module bd/test/result"],
src:
"bd/test/result",
modules:
["bd/test/result"],
code:
["dojo.def(\"bd/test/result\", [",
"  \"dojo\", \"bd\", \"bd/test/namespace\"",
"], function(dojo, bd) {",
"///",
"// Defines machinery for returning results within the Backdraft test framework.",
"",
"bd.test.result=",
"  ///namespace",
"  // Contains the test result factories.",
"  bd.test.result || {};",
"",
"bd.mix(bd.test.result, {",
"  base: {",
"    ///",
"    // The object used for the JavaScript prototype for built-in result instances.",
"    toString: function() {",
"      ///",
"      // Returns a string to indicate test outcome.",
"      if (this.pass) {",
"        if (this.todo) {",
"          return \"TODO: test not implemented\"; // iff this.todo is true",
"        } else {",
"          return \"test passed\"; // iff this.pass && !this.todo",
"        }",
"      } else if (this.threw) {",
"        return \"test failed (test threw)\";  // iff this.threw",
"      } else if (this.timeout) {",
"        return \"test failed (test timed out)\"; // iff this.timeout",
"      } else {",
"        return \"test failed\"; // otherwise",
"      }",
"    }",
"  },",
"",
"  pass: function(",
"    vargs///(variableArgs, optional) Arguments to stuff into the args property of the result object",
"  ){",
"    ///",
"    // Creates a generic pass result object. //Returned Objects have:",
"    //",
"    // - pass: true",
"    // - args: the arguments object if any arguments passed to this fucntion; otherwise, undefined if none passed",
"    // - prototype: bd.test.result.base",
"    return dojo.delegate(bd.test.result.base, {pass:true, args: arguments.length ? arguments : undefined});",
"  },",
"",
"  fail: function(",
"    vargs///(variableArgs, optional) Arguments to stuff into the args property of the result object",
"  ){",
"    ///",
"    // Creates a generic fail result object. //Returned Objects have:",
"    //",
"    // - pass:false",
"    // - args: the arguments object if any arguments passed to this fucntion; otherwise, undefined if none passed",
"    // - prototype: bd.test.result.base",
"    return dojo.delegate(bd.test.result.base, {pass:false, args: arguments.length ? arguments : undefined});",
"  },",
"",
"  exception: function(",
"    vargs///(variableArgs, optional) Arguments to stuff into the args property of the result object",
"  ){",
"    ///",
"    // Creates a generic fail because test threw result object. //Returned Objects have:",
"    //",
"    // - pass: false",
"    // - threw: true",
"    // - args: the arguments object if any arguments passed to this fucntion; otherwise, undefined if none passed",
"    // - prototype: bd.test.result.base",
"    return dojo.delegate(bd.test.result.base, {pass:false, threw:true, args: arguments.length ? arguments : undefined});",
"  },",
"",
"  timeout: function(",
"    vargs///(variableArgs, optional) Arguments to stuff into the args property of the result object",
"  ){",
"    ///",
"    // Creates a generic fail because test timed out result object. //Returned Objects have:",
"    //",
"    // - pass: false",
"    // - timeout: true",
"    // - args: the arguments object if any arguments passed to this fucntion; otherwise, undefined if none passed",
"    // - prototype: bd.test.result.base",
"    return dojo.delegate(bd.test.result.base, {pass:false, timeout:true, args: arguments.length ? arguments : undefined});",
"  },",
"",
"  todo: function(",
"    vargs///(variableArgs, optional) Arguments to stuff into the args property of the result object",
"  ){",
"    ///",
"    // Creates a generic test wasn\'t implemented result object. //Returned Objects have:",
"    //",
"    // - pass: true",
"    // - todo: true",
"    // - args: the arguments object if any arguments passed to this fucntion; otherwise, undefined if none passed",
"    // - prototype: bd.test.result.base",
"    return dojo.delegate(bd.test.result.base, {pass:true, todo:true, args: arguments.length ? arguments : undefined});",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.test.result":{
type:
Tnamespace,
sdoc:
["Contains the test result factories."],
ldoc:
[],
src:
"bd/test/result",
loc: [6,0,9,22],
module:"bd/test/result"}
,"bd.test.result.base":{
type:
Tvariable,
sdoc:
["The object used for the JavaScript prototype for built-in result instances."],
ldoc:
[],
props:
["toString",{
type:
Tfunction,
sdoc:
["Returns a string to indicate test outcome."],
ldoc:
[],
loc: [15,14,31,5]}
],
src:
"bd/test/result",
loc: [12,2,32,3],
module:"bd/test/result"}
,"bd.test.result.pass":{
type:
Tfunction,
sdoc:
["Creates a generic pass result object. "],
ldoc:
["Creates a generic pass result object. Returned Objects have:\n\n- pass: true\n- args: the arguments object if any arguments passed to this fucntion; otherwise, undefined if none passed\n- prototype: bd.test.result.base"],
params:
[["vargs",[["variableArgs, optional",
["Arguments to stuff into the args property of the result object"]]]]],
src:
"bd/test/result",
loc: [34,2,44,3],
module:"bd/test/result"}
,"bd.test.result.fail":{
type:
Tfunction,
sdoc:
["Creates a generic fail result object. "],
ldoc:
["Creates a generic fail result object. Returned Objects have:\n\n- pass:false\n- args: the arguments object if any arguments passed to this fucntion; otherwise, undefined if none passed\n- prototype: bd.test.result.base"],
params:
[["vargs",[["variableArgs, optional",
["Arguments to stuff into the args property of the result object"]]]]],
src:
"bd/test/result",
loc: [46,2,56,3],
module:"bd/test/result"}
,"bd.test.result.exception":{
type:
Tfunction,
sdoc:
["Creates a generic fail because test threw result object. "],
ldoc:
["Creates a generic fail because test threw result object. Returned Objects have:\n\n- pass: false\n- threw: true\n- args: the arguments object if any arguments passed to this fucntion; otherwise, undefined if none passed\n- prototype: bd.test.result.base"],
params:
[["vargs",[["variableArgs, optional",
["Arguments to stuff into the args property of the result object"]]]]],
src:
"bd/test/result",
loc: [58,2,69,3],
module:"bd/test/result"}
,"bd.test.result.timeout":{
type:
Tfunction,
sdoc:
["Creates a generic fail because test timed out result object. "],
ldoc:
["Creates a generic fail because test timed out result object. Returned Objects have:\n\n- pass: false\n- timeout: true\n- args: the arguments object if any arguments passed to this fucntion; otherwise, undefined if none passed\n- prototype: bd.test.result.base"],
params:
[["vargs",[["variableArgs, optional",
["Arguments to stuff into the args property of the result object"]]]]],
src:
"bd/test/result",
loc: [71,2,82,3],
module:"bd/test/result"}
,"bd.test.result.todo":{
type:
Tfunction,
sdoc:
["Creates a generic test wasn\'t implemented result object. "],
ldoc:
["Creates a generic test wasn\'t implemented result object. Returned Objects have:\n\n- pass: true\n- todo: true\n- args: the arguments object if any arguments passed to this fucntion; otherwise, undefined if none passed\n- prototype: bd.test.result.base"],
params:
[["vargs",[["variableArgs, optional",
["Arguments to stuff into the args property of the result object"]]]]],
src:
"bd/test/result",
loc: [84,2,95,3],
module:"bd/test/result"}
,"modules.bd/test/result":{
type:
Tmodule,
sdoc:
["Defines machinery for returning results within the Backdraft test framework."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["bd",[]]],
src:
"bd/test/result",
loc: [0,0,98,2]}
,"resources.bd/test/space":{
type:
Tresource,
sdoc:
["Defines the module bd/test/space"],
src:
"bd/test/space",
modules:
["bd/test/space"],
docLocs:
[[53,77]],
code:
["dojo.def(\"bd/test/space\", [",
"  \"dojo\", \"dijit\", \"bd\", \"bd/test/robot\", \"bd/async\"",
"], function(dojo, dijit, bd, robot) {",
"///",
"// Defines the class bd.test.space and associated machinery.",
"",
"bd.test.spaces=",
"  ///",
"  // Holds all bd.test.space instances.",
"  ///",
"  // (map:``space``.id --> ``space``) Map from space instance `id` to space instance.",
"  {};",
"",
"bd.declare(",
"  ///",
"  // Manages the execution of a test tree. //Class instances are assigned a new unique identifier at",
"  // property `id` and stored in bd.test.spaces[```id```] upon construction. The framework anticipates",
"  // the possibility of concurent execution of multiple test trees, with each bd.test.space instance controlling",
"  // a single execution thread; see bd.test.activeSpace.",
"  ",
"  //class name",
" \"bd:test.space\",",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  {",
"  breakFrequency:",
"    ///",
"    // The frequency in milliseconds that the test executer stops to give others a chance to execute.",
"    1000,",
"",
"  debugOnFail:",
"    ///",
"    // Causes the text executer to call the debugger upon a failure if true, and conversely.",
"    false,",
"",
"  abortOnFail:",
"    ///",
"    // Causes the text executer to abort the test upon the first failure detected if true, and conversely.",
"    true,",
"",
"  abortOnScaffoldFail:",
"    ///",
"    // Causes the text executer to abort the test upon the first failure of a scaffold if true, and conversely.",
"    true,",
"",
"  constructor: function(",
"    args",
"  ) {",
"    ///",
"    // Creates a new instance. //Mixes args into new instance.",
"    bd.docGen(\"kwargs\", {",
"      breakFrequency:",
"        // (integer, optional, bd.test.space.breakFrequency) Override the default.",
"        undefined,",
"",
"      debugOnFail:",
"        // (boolean, optional, bd.test.space.debugOnFail) Override the default.",
"        undefined,",
"",
"      abortOnFail:",
"        // (boolean, optional, bd.test.space.abortOnFail) Override the default.",
"        undefined,",
"",
"      abortOnScaffoldFail:",
"        // (integer, optional, bd.test.space.abortOnScaffoldFail) Override the default.",
"        undefined,",
"",
"      name:",
"        // (string, optional, this.id) The `name` property value.",
"        undefined,",
"",
"      publisher:",
"        // (bd.test.publisher, optional, new bd.test.publisher()) The destination for test results.",
"        undefined",
"    });",
"    args && dojo.mix(this, args);",
"",
"    this.id= bd.uid();",
"    bd.test.spaces[this.id]= this;",
"    !this.name && (this.name= this.id);",
"    !this.publisher && (this.publisher= new bd.test.publisher());",
"  },",
"",
"  destroy: function() {",
"    ///",
"    // Removes the space from the bd.test.spaces collection.",
"    delete bd.test.spaces[this.id];",
"  },",
"",
"  execute: function(",
"    root,         ///(bd.test.proc) The root of the test tree to execute.",
"    finishHandler ///(function(bd.test.space) //Function to call upon completion of test; this space is passed as the single argument.",
"  ) {",
"    ///",
"    // Execute the test process given by the hierarchy rooted at root; call finishHandler when the process completes.",
"    if (this.stream) {",
"      console.warn(\"Space cannot start a new test sequence since it is currently executing a sequence.\");",
"      return false;",
"    }",
"    dojo.mix(this, {",
"      stream:new bd.test.space.stream(),",
"      finishHandler:finishHandler || bd.noop,",
"      passCount:0,",
"      failCount:0,",
"      toDoCount:0,",
"      scaffoldErrorCount:0,",
"      results:[],",
"      deferred:new dojo.Deferred()",
"    });",
"    root.traverse(this.stream, true);",
"    return this.execute_();",
"  },",
"",
"  execute_: function() {",
"    ///",
"    // The test execution engine.",
"    // `private",
"    //warn",
"    // This routine should not be called directly by client code; use bd.test.execute.",
"    if (!this.stream) {",
"      //some scaffold or demo panicked and probably called execAbort",
"      return false;",
"    }",
"    var",
"      stream= this.stream,",
"      startTime= bd.getTime(),",
"      result, next;",
"    bd.test.pushActiveSpace(this);",
"    while (!stream.exhausted()) {",
"      if ((this.scaffoldErrorCount && this.abortOnScaffoldFail) || (this.failCount && this.abortOnFail)) {",
"        this.execAbort();",
"        break;",
"      }",
"      if (bd.getTime()-startTime > this.breakFrequency) {",
"        var deferred= new dojo.Deferred();",
"        setTimeout(function(){ deferred.callback(true); }, 5);",
"        //add the continuation and then return the deferred to wait on before executing the contination...",
"        deferred.addCallback(this, \"execute_\");",
"        break;",
"      }",
"      next= stream.get();",
"      result= true;",
"      try {",
"        if (next.traverseIn) {",
"          this.publisher.publish(\"traverseIn\", next.proc);",
"          result= next.proc.traverseIn(this);",
"        } else {",
"          result= next.proc.traverseOut(this);",
"        }",
"      } catch (e) {",
"        //unexpected exception...",
"        //an executing phase proc should never get here because it should fully process all its own errors...",
"        this.unexpectedException(e, next.proc, false, \"scaffolding\", next.traverseIn);",
"        stream.skip();",
"      }",
"      if (result instanceof dojo.Deferred) {",
"        result.addCallbacks(",
"          dojo.hitch(this, function(result) {",
"            if (result===bd.test.proc.failed) {",
"              //an executing phase proc should never get here because it should fully process all its own errors...",
"              this.scaffoldFailed(next.proc, next.traverseIn);",
"              stream.skip();",
"            }",
"            if (!next.traverseIn) {",
"              this.publisher.publish(\"traverseOut\", next.proc);",
"            }",
"            return this.execute_();",
"          }),",
"          dojo.hitch(this, function(e) {",
"            //an executing phase proc should never get here because it should fully process all its own errors...",
"            this.unexpectedException(e, next.proc, false, \"scaffolding\", next.traverseIn);",
"            if (!next.traverseIn) {",
"              this.publisher.publish(\"traverseOut\", next.proc);",
"            }",
"            stream.skip();",
"            return this.execute_();",
"          })",
"        );",
"        break;",
"      } else if (result===bd.test.proc.failed) {",
"        //an executing phase proc should never get here because it should fully process all its own errors...",
"        this.scaffoldFailed(next.proc, next.traverseIn);",
"        if (!next.traverseIn) {",
"          this.publisher.publish(\"traverseOut\", next.proc);",
"        }",
"        stream.skip();",
"      } else if (!next.traverseIn) {",
"        this.publisher.publish(\"traverseOut\", next.proc);",
"      }",
"    }",
"    if (stream && stream.exhausted() && !(result instanceof dojo.Deferred)) {",
"      this.finishExec();",
"    }",
"    bd.test.popActiveSpace();",
"    return result;",
"  },",
"",
"  execAbort: function() {",
"    ///",
"    // Called by the test execution engine to abort a test process. //Attempts to clean up",
"    // scaffold (but no guarantee), and then calls bd.test.space.finishExec.",
"    if (this.stream) {",
"      //assume the previous this.stream.get was fully executed",
"      this.publisher.publish(\"abort\");",
"      var next= this.stream.get();",
"      if (next) {",
"        var p= next.traverseIn ? next.proc.parent : next.proc;",
"        while (p && p!==bd.test.proc.root) {",
"          try {",
"            p.traverseOut(this);",
"          } catch (e) {",
"            //quiet...",
"          }",
"          p= p.parent;",
"        }",
"      }",
"      this.finishExec();",
"    }",
"  },",
"",
"  finishExec: function() {",
"    ///",
"    // Calls the finishHandler for this test process and then deletes all process properties. //If",
"    // the client (the code that started the test) wants to keep the results around after the",
"    // test process has completed, then it should take its own reference in the finish handler.",
"    this.finishHandler(this);",
"    delete this.stream;",
"    delete this.finishHandler;",
"    delete this.passCount;",
"    delete this.failCount;",
"    delete this.toDoCount;",
"    delete this.scaffoldErrorCount;",
"    delete this.results;",
"    delete this.deferred;",
"  },",
"",
"  startDemo: function(",
"    proc",
"  ) {",
"    ///",
"    // Called by the test execution engine just before a demo function--including associated each scaffolds--is executed.",
"    this.publisher.publish(\"startDemo\", proc);",
"  },",
"",
"  endDemo: function(",
"    proc",
"  ) {",
"    ///",
"    // Called by the test execution engine just after a demo function--including associated each scaffolds--has executed.",
"    this.publisher.publish(\"endDemo\", proc);",
"  },",
"",
"  scaffoldFailed: function(",
"    proc,",
"    traverseIn",
"  ) {",
"    ///",
"    // Called by the test execution engine when a scaffold failure is detected.",
"    this.adviseResult(bd.test.result.fail(proc, traverseIn));",
"    this.publisher.publish(\"scaffoldFailed\", proc, traverseIn);",
"    this.scaffoldErrorCount++;",
"  },",
"",
"  demoFailed: function(",
"    proc,",
"    traverseIn",
"  ) {",
"    ///",
"    // Called by the test execution engine when a demo failure is detected.",
"    ///",
"    // no-op; normally, this should be published directly in the demo (e.g., \"the(something).is(expected)\").",
"    // This hook is here for symetric completeness of the interface: client code can either override or dojo.connect to this method.",
"  },",
"",
"  unexpectedException: function(",
"    e,         /// (anything) the exception object",
"    proc,      /// (bd.test.proc) the proc that caused the exception",
"    demo,      /// (boolean) false => scaffold; true => demo",
"    phase,     /// (\"scaffolding\" | \"executing\") the phase of the test runner algorithm in which the error occured",
"    traverseIn /// (boolean) traversing in or out during phase",
"  ){",
"    ///",
"    // Called by the test execution engine when an exception happens that the test code did not anticipate.",
"    console.error(e);",
"    this.adviseResult(bd.test.result.exception(e, proc, demo, phase, traverseIn));",
"    if (demo) {",
"      this.publisher.publish(\"demoThrew\", proc, traverseIn);",
"      this.failCount++;",
"    } else {",
"      this.publisher.publish(\"scaffoldThrew\", proc, traverseIn);",
"      this.scaffoldErrorCount++;",
"    }",
"  },",
"",
"  adviseResult: function(",
"    result",
"  ) {",
"    ///",
"    // Called when a result is determined; typically by bd.test.the.",
"    this.results.push(result);",
"    this.publisher.publish(\"result\", result);",
"    if (result.pass) {",
"      this.passCount++;",
"    } else {",
"      this.failCount++;",
"      if (this.debugOnFail) {",
"        debugger;",
"      }",
"    }",
"  },",
"",
"  scheduleProc: function(",
"    delay, ///(integer) The delay in milliseconds before proc is executed.",
"    proc   ///(function(bd.test.space) The function to execute.",
"  ) {",
"    ///",
"    // Execute proc after delay milliseconds.",
"    ///",
"    // Sets bd.test.activeSpace to this space before calling proc; passes this space as the sole argument to proc.",
"    // `return The a dojo.deferred object that waits for proc to execute; the deferred returns the result of proc.",
"    var",
"      me= this,",
"      result= new dojo.Deferred();",
"",
"    setTimeout(",
"      function() {",
"        bd.test.activeSpace= me;",
"        result.callback(proc(me));",
"      },",
"      delay",
"    );",
"    return result;",
"  },",
"",
"  watch: function(",
"    frequency, ///(integer) The frequency in milliseconds to execute proc.",
"    maxDelay,  ///(integer) The maximum number of milliseconds to try proc before assuming failure.",
"    proc       ///(function(bd.test.space) The function to execute.",
"  ) {",
"    ///",
"    // Execute proc every frequency milliseconds until proc returns true or maxDelay is reached.",
"    ///",
"    // Returns a dojo.deferred that waits for proc to return true of maxDelay milliseconds to elapse. The Deferred returns",
"    // true if proc returned true in time; false if proc fails to return true in  maxDelay milliseconds or if proc threw an exception. ",
"    // Further, if proc throws an exception, then the error object is advised as a result.",
"    var",
"      me= this,",
"      result= new dojo.Deferred(),",
"      startTime= bd.getTime(),",
"      timerId= setInterval(",
"        function() {",
"          bd.test.activeSpace= me;",
"          try {",
"            var testDone= proc(me);",
"          } catch (e) {",
"            clearInterval(timerId);",
"            me.adviseResult(bd.test.result.exception(e));",
"            result.callback(false);",
"          }",
"          if (testDone) {",
"            clearInterval(timerId);",
"            result.callback(true);",
"          } else if (maxDelay < bd.getTime()-startTime) {",
"            clearInterval(timerId);",
"            me.adviseResult(bd.test.result.timeout());",
"            result.callback(false);",
"          }",
"        }, frequency",
"      );",
"    return result;",
"  },",
"",
"  sandbox: function(",
"    module,",
"    testName,",
"    maxLoadDelay",
"  ) {",
"    maxLoadDelay= maxLoadDelay || 10000;",
"    var",
"      me= this,",
"      result= new dojo.Deferred(),",
"      startTime= bd.getTime(),",
"      timerId= setInterval(",
"        function() {",
"          if (maxLoadDelay < bd.getTime()-startTime) {",
"            clearInterval(timerId);",
"            timerId= 0;",
"            me.adviseResult(bd.test.result.timeout());",
"            result.callback(false);",
"          }",
"        }, 100",
"      ),",
"      frame= this.getIframe(),",
"      url= module.substring(0, 4)==\"url:\" ? module.substring(4) : dojo.url(module);",
"    frame.attr(\"src\", url);",
"    var h= dojo.subscribe(\"frame-loaded\", function(frameWindow) {",
"      if (frame.iframeNode.contentWindow===frameWindow) {",
"        dojo.unsubscribe(h);",
"        frameWindow.dojo.def([\"bd/test\"], function(test) { ",
"          test.loader.load(testName, function(module) {",
"            var tempSpace= new test.space({publisher:me.publisher});",
"            if (timerId) {",
"              //the test has NOT timed out yet; therefore, proceed...",
"              clearInterval(timerId);",
"              tempSpace.execute(module, function() {",
"                me.passCount+= tempSpace.passCount;",
"                me.failCount+= tempSpace.failCount;",
"                me.toDoCount+= tempSpace.toDoCount;",
"                me.scaffoldErrorCount+= tempSpace.scaffoldErrorCount;",
"                result.callback(tempSpace.failCount+tempSpace.scaffoldErrorCount==0);",
"              });",
"            } else {",
"              //TODO clean up the iframe",
"            }",
"          });",
"        });",
"      }",
"    });",
"    return result;",
"  },",
"",
"  getNode: function(",
"    target //(id) a string that gives a DOM id; the id must not start with \"wid:\"",
"           //(widget-id) a string of the form \"wid:<widget-id>\" that gives a widget id",
"           //(node) a DOM node",
"           //(widget) a widget instance",
"           //([context, child]) context implies a DOM node or widget instance and may",
"           // be given as an id, widget-id, node, or widget as described above; child ",
"           // (always a string) defines an decendent of context:",
"           //   1. a property of context; context must be a widget; the property name must not begin with \"css:\", \"child:\", or \"xpath:\" (see next)",
"           //   2. a CSS selector given by \"css:<selector>\" rooted at context (if context implies a DOM node) or context.domNode (if context implies a widget)",
"           //   3. a decendent path given by \"child:< <child-name>/<grand-child-name>/.../<target-name> >\"; context must be a widget",
"           //   4. an xpath query given by \"xpath:<query>\" rooted at context (if context implies a DOM node) or context.domNode (if context implies a widget)",
"  ) {",
"    var node, parts;",
"    if (dojo.isArray(target)) {",
"      parts= target[1].split(\":\");",
"      switch (parts[0]) {",
"        case \"child\":",
"          node= dojo.isString(target[0]) ? dijit.byId(target[0].substring(4)) : target[0];",
"          dojo.forEach(parts[1].split(\"/\"), function(childName) {",
"            node= node.getChild(childName);",
"          });",
"          node= node.domNode;",
"          break;",
"        case \"css\":",
"          node= this.getNode(target[0]);",
"          //TODO",
"          break;",
"        case \"xpath\":",
"          node= this.getNode(target[0]);",
"          //TODO",
"          break;",
"        default:",
"          node= (dojo.isString(target[0]) ? (/^wid:/.test(target[0]) ? dijit.byId(target[0].substring(4)) : dojo.byId(target[0])) : target[0])[target[1]];",
"      }",
"    }",
"    return node || (dojo.isString(target) ? (/^wid:/.test(target) ? dijit.byId(target.substring(4)).domNode : dojo.byId(target)) : target.domNode || target);",
"  },",
"",
"  getShift: function(",
"    kwargs",
"  ) {",
"    if (dojo.isString(kwargs.shift)) {",
"      var shiftState= kwargs.shift.toLowserCase();",
"      kwargs.shift= shiftState.charAt(0)==\"s\";",
"      kwargs.control= shiftState.charAt(0)==\"c\";",
"      kwargs.alt= shiftState.charAt(0)==\"a\";",
"      kwargs.meta= shiftState.charAt(0)==\"m\";",
"    }",
"  },",
"",
"  play: function(",
"    action,",
"    target,",
"    kwargs,",
"    continuation",
"  ) {",
"    if (/^mouse/.test(action)) {",
"      this.playMouse.apply(this, arguments);",
"    } else if (/^kb/.test(action)) {",
"      this.playKeyboard.apply(this, arguments);",
"    } else {",
"      //todo",
"    }",
"  },",
"",
"  playMouse: function(",
"    action,",
"    target,",
"    kwargs,",
"    continuation",
"  ) {",
"    var node= this.getNode(target);",
"    if (dojo.isFunction(kwargs)) {",
"      continuation= kwargs;",
"      kwargs= {};",
"    } else {",
"      kwargs= kwargs || {};",
"    }",
"    if (!kwargs.clientX || !kwargs.clientY) {",
"      var coords= dojo.position(node);",
"      kwargs.clientX= coords.x + (coords.w/2);",
"      kwargs.clientY= coords.y + (coords.h/2);",
"    }",
"    this.getShift(kwargs);",
"    this[\"play_\"+action](node, kwargs);",
"  },",
"",
"  play_mouseclick: function(",
"    node,",
"    kwargs",
"  ) {",
"    robot.mouseEvent(node, \"mousedown\", kwargs.control, kwargs.alt, kwargs.shift, kwargs.meta, kwargs.clientX, kwargs.clientY, kwargs.screenX, kwargs.screenY, kwargs.detail);",
"    if (dijit._curFocus!==node && dijit.isTabNavigable(node)) {",
"      node.focus();",
"    }",
"    robot.mouseEvent(node, \"mouseup\", kwargs.control, kwargs.alt, kwargs.shift, kwargs.meta, kwargs.clientX, kwargs.clientY, kwargs.screenX, kwargs.screenY, kwargs.detail);",
"    robot.htmlEvent(node, \"click\");",
"  },",
"",
"  decodeKeys: function(",
"    keys //(string | number)",
"  ) {",
"    if (dojo.isString(keys)) {",
"      var ",
"        keymap= bd.test.robot.keymap,",
"        result= [],",
"        i= 0, ",
"        length= keys.length,",
"        c, keyMapItem, match, shiftState;",
"      while (i<length) {",
"        c= keys.charAt(i++);",
"        if (c==\"\\\\\") {",
"          if (keys.charAt(i)==\"\\\\\") {",
"            i++;",
"            keyMapItem= keymap[\"\\\\\"];",
"            result.push({shift:keyMapItem[0], keyCode:keyMapItem[1], charCode:keyMapItem[2]});",
"          } else {",
"            match= keys.substring(i).match(/^(([^-]*)-)?(\\S*)\\s/);",
"            if (match) {",
"              keyMapItem= keymap[match[3]];",
"              shiftState= match[2].toLowerCase() || \"xxxx\";",
"              result.push({shift:keyMapItem[0]||shiftState.charAt(0)==\"s\", control:shiftState.charAt(1)==\"c\", alt:shiftState.charAt(2)==\"a\", meta:shiftState.charAt(3)==\"m\", keyCode:keyMapItem[1], charCode:keyMapItem[2]});",
"              keys= keys.substring(i + match[0].length);",
"              i= 0;",
"              length= keys.length;",
"            } else {",
"              throw new Error(\"unknown keys for play keyboard\");",
"            }",
"          }",
"        } else {",
"          keyMapItem= keymap[c];",
"          result.push({shift:keyMapItem[0], keyCode:keyMapItem[1], charCode:keyMapItem[2]});",
"        }",
"      }",
"    } else {",
"      result.push({keyCode:keys, charCode:0});",
"    }",
"    return result;",
"  },",
"",
"  playKeyboard: function(",
"    action,       //(kbDown, kbPress, kbUp, kbType)",
"    target,       //(DOM node | dijit id | DOM id | falsey) if falsy, then play to current focus (if any) or document (if no current focus)",
"    keys,         //(robot key string)",
"    shiftState,   //(string, optional) a shift string (S|s|x)[(C|c|x)[(A|a|x)[(M|m|x)]]]",
"    continuation //function, optional)",
"  ) {",
"    var node= (target ? (this.getNode(target) || document) : dijit._curFocus);",
"    if (node!=dijit._curFocus) {",
"      node.focus();",
"    }",
"    keys= this.decodeKeys(keys);",
"    var shift;",
"    if (dojo.isString(shiftState)) {",
"      shift={shift:shiftState};",
"      this.getShift(args);",
"    } else {",
"      continuation= shiftState;",
"      shift= {shift:0, control:0, alt:0, meta:0};",
"    }",
"    this[\"play_\"+action](node, keys, shift);",
"  },",
"",
"  play_kbType: function(",
"    node,",
"    keys,",
"    shift",
"  ) {",
"    dojo.forEach(keys, function(key) {",
"      robot.keyboardEvent(node, \"keydown\", key.keyCode, 0, key.shift||shift.shift, key.control||shift.control, key.alt||shift.alt, key.meta||shift.meta);",
"      var",
"        control= key.control||shift.control,",
"        alt= key.alt||shift.alt,",
"        meta= key.meta||shift.meta,",
"        keyCode= 0,",
"        charCode= key.charCode;",
"      if (control || alt || meta) {",
"        keyCode= key.keyCode;",
"        charCode= 0;",
"      }",
"      robot.keyboardEvent(node, \"keypress\", keyCode, charCode, key.shift||shift.shift, control, alt, meta);",
"      robot.keyboardEvent(node, \"keyup\", key.keyCode, 0, key.shift||shift.shift, key.control||shift.control, key.alt||shift.alt, key.meta||shift.meta);",
"    });",
"  },",
"",
"  play_kbDown: function(",
"    node,",
"    keys,",
"    shift",
"  ) {",
"    robot.keyboardEvent(node, \"keydown\", key.keyCode, 0, key.shift||shift.shift, shift.control, shift.alt, shift.meta);",
"  },",
"",
"  play_kbPress: function(",
"    node,",
"    keys,",
"    shift",
"  ) {",
"    ///",
"    robot.keyboardEvent(node, \"keypress\", 0, key.charCode, key.shift||shift.shift, shift.control, shift.alt, shift.meta);",
"  },",
"",
"  play_keyup: function(",
"    node,",
"    keys,",
"    shift",
"  ) {",
"    robot.keyboardEvent(node, \"keyup\", key.keyCode, 0, key.shift||shift.shift, shift.control, shift.alt, shift.meta);",
"  }",
"});",
"",
"bd.declare(",
"  ///",
"  // A trivial FIFO stream object that helps with the test execution engine.",
"  ///",
"  // Records (via push) then plays (via get) the test tree traversal. The function skip skips over all",
"  // nodes between a closing traverseOut when an opening traverseIn fails.",
"  // `private",
"",
"  //class name",
"  \"bd:test.space.stream\",",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  {",
"  constructor: function() {",
"    this.buffer= [];",
"    this.current= 0;",
"  },",
"",
"  exhausted: function() {",
"    return this.current>=this.buffer.length;",
"  },",
"",
"  get: function() {",
"    return this.buffer[this.current++];",
"  },",
"",
"  skip: function() {",
"    var item= this.buffer[this.current-1];",
"    if (item && item.traverseIn) {",
"      var target= item.proc;",
"      while (this.buffer[this.current].proc!=target) {",
"        this.current++;",
"      }",
"    }",
"  },",
"",
"  push: function(",
"    proc,",
"    traverseIn",
"  ) {",
"    this.buffer.push({traverseIn:traverseIn, proc:proc});",
"  }",
"});",
"",
"bd.test.activeSpace=",
"  ///",
"  // The current active bd.test.space object.",
"  ///",
"  // The test execution algorithm ensures that scaffolding and demo functions are called with bd.test.activeSpace",
"  // set to the space that is executing the particular scaffold/demo. However, since scaffolds/demos may implement",
"  // asynchronous algorithms, they may need to manipulate the activeSpace directly to ensure the proper space is",
"  // referenced (for example, when advising results via bd.test.the). It is usually best to use bd.test.pushActiveSpace",
"  // and bd.test.popActiveSpace for this purpose.",
"  null;",
"",
"bd.test.activeSpaces=",
"  ///",
"  // `private",
"  // The stack of active test spaces; see bd.test.pushActiveSpace and bd.test.popActiveSpace.",
"  [null];",
"",
"bd.test.pushActiveSpace= function(",
"  space ///(bd.test.space) space to make the new active space",
") {",
"  ///",
"  // Push the current value of bd.test.activeSpace onto the stack maintained at bd.test.activeSpaces, then make that space the active space.",
"  bd.test.activeSpaces.push(space);",
"  bd.test.activeSpace= space;",
"};",
"",
"bd.test.popActiveSpace= function() {",
"  ///",
"  // Pop the top of bd.test.activeSpaces; replace bd.test.activeSpace with the new top of the bd.test.activesSpaces.",
"  ///",
"  // Assuming the bd.test.activeSpace is manipulated via bd.test.pushActiveSpace and bd.test.popActiveSpace, then",
"  // bd.back(bd.test.activeSpaces)===bd.test.activeSpace is always true.",
"  //",
"  // `return The old top of bd.test.activeSpaces.",
"  var result= bd.test.activeSpaces.pop();",
"  bd.test.activeSpace= bd.back(bd.test.activeSpaces);",
"  return result;",
"};",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.test.spaces":{
type:
Tvariable,
sdoc:
["Holds all bd.test.space instances."],
ldoc:
["(map:``space``.id --> ``space``) Map from space instance `id` to space instance."],
src:
"bd/test/space",
loc: [6,0,11,4],
module:"bd/test/space"}
,"bd.test.space":{
type:
Tclass,
sdoc:
["Manages the execution of a test tree. "],
ldoc:
["Manages the execution of a test tree. Class instances are assigned a new unique identifier at\nproperty `id` and stored in bd.test.spaces[```id```] upon construction. The framework anticipates\nthe possibility of concurent execution of multiple test trees, with each bd.test.space instance controlling\na single execution thread; see bd.test.activeSpace."],
src:
"bd/test/space",
loc: [13,0,634,2],
module:"bd/test/space"}
,"bd.test.space.breakFrequency":{
type:
Tvariable,
sdoc:
["The frequency in milliseconds that the test executer stops to give others a chance to execute."],
imember:1,
ldoc:
[],
loc: [28,2,31,8]}
,"bd.test.space.debugOnFail":{
type:
Tvariable,
sdoc:
["Causes the text executer to call the debugger upon a failure if true, and conversely."],
imember:1,
ldoc:
[],
loc: [33,2,36,9]}
,"bd.test.space.abortOnFail":{
type:
Tvariable,
sdoc:
["Causes the text executer to abort the test upon the first failure detected if true, and conversely."],
imember:1,
ldoc:
[],
loc: [38,2,41,8]}
,"bd.test.space.abortOnScaffoldFail":{
type:
Tvariable,
sdoc:
["Causes the text executer to abort the test upon the first failure of a scaffold if true, and conversely."],
imember:1,
ldoc:
[],
loc: [43,2,46,8]}
,"bd.test.space.constructor":{
type:
Tfunction,
sdoc:
["Creates a new instance. "],
imember:1,
ldoc:
["Creates a new instance. Mixes args into new instance."],
params:
[["args",[]]],
loc: [48,2,84,3]}
,"bd.test.space.destroy":{
type:
Tfunction,
sdoc:
["Removes the space from the bd.test.spaces collection."],
imember:1,
ldoc:
[],
loc: [86,2,90,3]}
,"bd.test.space.execute":{
type:
Tfunction,
sdoc:
["Execute the test process given by the hierarchy rooted at root; call finishHandler when the process completes."],
imember:1,
ldoc:
[],
params:
[["root",[["bd.test.proc",
["The root of the test tree to execute."]]]],
["finishHandler",[["",
["(function(bd.test.space) //Function to call upon completion of test; this space is passed as the single argument."]]]]],
loc: [92,2,114,3]}
,"bd.test.space.execute_":{
type:
Tfunction,
sdoc:
["The test execution engine."],
imember:1,
ldoc:
[[WARN,"This routine should not be called directly by client code; use bd.test.execute."]],
flags:
[Fprivate],
loc: [116,2,198,3]}
,"bd.test.space.execAbort":{
type:
Tfunction,
sdoc:
["Called by the test execution engine to abort a test process. "],
imember:1,
ldoc:
["Called by the test execution engine to abort a test process. Attempts to clean up\nscaffold (but no guarantee), and then calls bd.test.space.finishExec."],
loc: [200,2,221,3]}
,"bd.test.space.finishExec":{
type:
Tfunction,
sdoc:
["Calls the finishHandler for this test process and then deletes all process properties. "],
imember:1,
ldoc:
["Calls the finishHandler for this test process and then deletes all process properties. If\nthe client (the code that started the test) wants to keep the results around after the\ntest process has completed, then it should take its own reference in the finish handler."],
loc: [223,2,237,3]}
,"bd.test.space.startDemo":{
type:
Tfunction,
sdoc:
["Called by the test execution engine just before a demo function--including associated each scaffolds--is executed."],
imember:1,
ldoc:
[],
params:
[["proc",[]]],
loc: [239,2,245,3]}
,"bd.test.space.endDemo":{
type:
Tfunction,
sdoc:
["Called by the test execution engine just after a demo function--including associated each scaffolds--has executed."],
imember:1,
ldoc:
[],
params:
[["proc",[]]],
loc: [247,2,253,3]}
,"bd.test.space.scaffoldFailed":{
type:
Tfunction,
sdoc:
["Called by the test execution engine when a scaffold failure is detected."],
imember:1,
ldoc:
[],
params:
[["proc",[]],
["traverseIn",[]]],
loc: [255,2,264,3]}
,"bd.test.space.demoFailed":{
type:
Tfunction,
sdoc:
["Called by the test execution engine when a demo failure is detected."],
imember:1,
ldoc:
["no-op; normally, this should be published directly in the demo (e.g., \"the(something).is(expected)\").\nThis hook is here for symetric completeness of the interface: client code can either override or dojo.connect to this method."],
params:
[["proc",[]],
["traverseIn",[]]],
loc: [266,2,275,3]}
,"bd.test.space.unexpectedException":{
type:
Tfunction,
sdoc:
["Called by the test execution engine when an exception happens that the test code did not anticipate."],
imember:1,
ldoc:
[],
params:
[["e",[["",
["(anything) the exception object"]]]],
["proc",[["",
["(bd.test.proc) the proc that caused the exception"]]]],
["demo",[["",
["(boolean) false => scaffold; true => demo"]]]],
["phase",[["",
["(\"scaffolding\" | \"executing\") the phase of the test runner algorithm in which the error occured"]]]],
["traverseIn",[["",
["(boolean) traversing in or out during phase"]]]]],
loc: [277,2,295,3]}
,"bd.test.space.adviseResult":{
type:
Tfunction,
sdoc:
["Called when a result is determined; typically by bd.test.the."],
imember:1,
ldoc:
[],
params:
[["result",[]]],
loc: [297,2,312,3]}
,"bd.test.space.scheduleProc":{
type:
Tfunction,
sdoc:
["Execute proc after delay milliseconds."],
imember:1,
ldoc:
["Sets bd.test.activeSpace to this space before calling proc; passes this space as the sole argument to proc."],
params:
[["delay",[["integer",
["The delay in milliseconds before proc is executed."]]]],
["proc",[["",
["(function(bd.test.space) The function to execute."]]]]],
loc: [314,2,335,3]}
,"bd.test.space.watch":{
type:
Tfunction,
sdoc:
["Execute proc every frequency milliseconds until proc returns true or maxDelay is reached."],
imember:1,
ldoc:
["Returns a dojo.deferred that waits for proc to return true of maxDelay milliseconds to elapse. The Deferred returns\ntrue if proc returned true in time; false if proc fails to return true in  maxDelay milliseconds or if proc threw an exception.\nFurther, if proc throws an exception, then the error object is advised as a result."],
params:
[["frequency",[["integer",
["The frequency in milliseconds to execute proc."]]]],
["maxDelay",[["integer",
["The maximum number of milliseconds to try proc before assuming failure."]]]],
["proc",[["",
["(function(bd.test.space) The function to execute."]]]]],
loc: [337,2,373,3]}
,"bd.test.space.play_kbPress":{
type:
Tfunction,
imember:1,
params:
[["node",[]],
["keys",[]],
["shift",[]]],
loc: [618,2,625,3]}
,"bd.test.space.stream":{
type:
Tclass,
sdoc:
["A trivial FIFO stream object that helps with the test execution engine."],
ldoc:
["Records (via push) then plays (via get) the test tree traversal. The function skip skips over all\nnodes between a closing traverseOut when an opening traverseIn fails."],
flags:
[Fprivate],
src:
"bd/test/space",
loc: [636,0,681,2],
module:"bd/test/space"}
,"bd.test.activeSpace":{
type:
Tvariable,
sdoc:
["The current active bd.test.space object."],
ldoc:
["The test execution algorithm ensures that scaffolding and demo functions are called with bd.test.activeSpace\nset to the space that is executing the particular scaffold/demo. However, since scaffolds/demos may implement\nasynchronous algorithms, they may need to manipulate the activeSpace directly to ensure the proper space is\nreferenced (for example, when advising results via bd.test.the). It is usually best to use bd.test.pushActiveSpace\nand bd.test.popActiveSpace for this purpose."],
src:
"bd/test/space",
loc: [683,0,692,6],
module:"bd/test/space"}
,"bd.test.activeSpaces":{
type:
Tvariable,
sdoc:
["The stack of active test spaces; see bd.test.pushActiveSpace and bd.test.popActiveSpace."],
ldoc:
[],
flags:
[Fprivate],
src:
"bd/test/space",
loc: [694,0,698,8],
module:"bd/test/space"}
,"bd.test.pushActiveSpace":{
type:
Tfunction,
sdoc:
["Push the current value of bd.test.activeSpace onto the stack maintained at bd.test.activeSpaces, then make that space the active space."],
ldoc:
[],
params:
[["space",[["bd.test.space",
["space to make the new active space"]]]]],
src:
"bd/test/space",
loc: [700,0,707,1],
module:"bd/test/space"}
,"bd.test.popActiveSpace":{
type:
Tfunction,
sdoc:
["Pop the top of bd.test.activeSpaces; replace bd.test.activeSpace with the new top of the bd.test.activesSpaces."],
ldoc:
["Assuming the bd.test.activeSpace is manipulated via bd.test.pushActiveSpace and bd.test.popActiveSpace, then\nbd.back(bd.test.activeSpaces)===bd.test.activeSpace is always true."],
src:
"bd/test/space",
loc: [709,0,720,1],
module:"bd/test/space"}
,"modules.bd/test/space":{
type:
Tmodule,
sdoc:
["Defines the class bd.test.space and associated machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["dijit",[]],
["bd",[]],
["robot",[]]],
src:
"bd/test/space",
loc: [0,0,722,2]}
,"resources.bd/visual":{
type:
Tresource,
sdoc:
["Defines the module bd/visual"],
src:
"bd/visual",
modules:
["bd/visual"],
code:
["dojo.def(\"bd/visual\", [",
"  \"bd\",",
"  \"dojo\",",
"  \"bd/creatable\",",
"  \"bd/id\",",
"  \"bd/stateful\",",
"  \"bd/connectable\",",
"  \"bd/cssStateful\",",
"  \"bd/containable\"",
"], function(bd, dojo) {",
"///",
"// Defines the bd.visual class and associated machinery.",
"",
"bd.domAttr= function(",
"  name,         ///(string) The property name.",
"  defaultValue, ///(any) The initial value for the attribute; undefined indicates no value should be set.",
"  target,       ///(string) attribute in node is given by this.domNode.target",
"                //(pair of [domNode, target]) attribute in node is given by this[target[0]].[target[1]]",
"                //(single of [domNode]) attribute in node is given by this[target[0]].[name]",
"                //(falsy) attribute in node is given by this.domNode[name]",
"  setter,       ///(function(newValue), optional, see description) Function that sets the property to newValue and returns the previous value.",
"  getter        ///(function(), optional, see description) Function that returns the current value of property.",
") {",
"  ///",
"  // Similar to bd.attr except that the attibute is a DOM attribute on the DOM node implied by target.",
"  ///",
"  // See bd.attr and bd.stateful for more details on getters and setters.",
"",
"  // argument juggle",
"  var nodeName= \"domNode\";",
"  if (bd.isArray(target)) {",
"    nodeName= target[0];",
"    target= target.length==2 ? target[1] : name;",
"  } else if (!bd.isString(target)) {",
"    target= name;",
"  }",
"",
"  var ",
"    result= {},",
"    setterName= name + \"Set\",",
"    getterName= name + \"Get\";",
"  result[name]= defaultValue;",
"  result[setterName]= setter || function(value) {",
"    var",
"      node= this[nodeName],",
"      oldValue= this[name];",
"    if (node) {",
"      if (value===undefined) {",
"        node && node.removeAttribute(target);",
"      } else {",
"        node.setAttribute(target, value);",
"      }",
"    }",
"    this[name]= value;",
"    return oldValue;",
"  };",
"  result[getterName]= getter || function() {",
"    return this[name];",
"  };",
"  return result;",
"};",
"",
"bd.constDomAttr= function(",
"  name,         ///(string) The property name.",
"  defaultValue, ///(any) The initial value for the property.",
"  target,       ///(string) attribute in node is given by this.domNode.target",
"                //(pair of [domNode, target]) attribute in node is given by this[target[0]].[target[1]]",
"                //(single of [domNode]) attribute in node is given by this[target[0]].[name]",
"                //(falsy) attribute in node is given by this.domNode[name]",
"  getter        ///(function(), optional, see description) Function that returns the current value of property.",
") {",
"  ///",
"  // Similar to bd.domAttr except that no setter is defined",
"  var result= bd.domAttr(name, defaultValue, target, 0, getter);",
"  delete result[name + \"Set\"];",
"  return result;",
"};",
"",
"bd.declare(",
"  ///",
"  // Base class for a Backdraft widget.",
"  ///",
"  // A Backdraft class with a visual presentation that is creatable by bd.createWidget is termed a Backdraft",
"  // widget, and this class is designed to be used as the base class to build such classes. The key requirement",
"  // of a backdraft widget is that it must be constructable with a single argument of type bd.createWidget.kwargs and must be",
"  // findable via the widget registry (bd.object.registry). The widget registry requirement implies widgets must",
"  // contain a page-unique identifier.",
"  /// ",
"  // Although not required, a few more features are almost-always desired:",
"  // ",
"  //   * the features of bd.stateful",
"  //   * the features of bd.id",
"  //   * the features of bd.connectable",
"  //   * the features of bd.cssStateful",
"  //   * the features of bd.containable",
"  //   * a visual presentation via a DOM subtree",
"  // ",
"  // This class provides these features by deriving from the above-mentioned classes and",
"  // providing foundational machinery for creating and controlling a DOM subtree.",
"  //note ",
"  // Backdraft widgets need not include a DOM presentation--it is perfectly accepable and",
"  // useful to define widget classes that work as controller/processing automatons within the widget tree of an application.",
"  //note",
"  // It is not a requirement that a Backdraft widget is derived from this class. Other widget systems (e.g., Dojo\'s dijit",
"  // widgets) can be lightly wrapped to allow for creation by bd.createWidget.",
"",
"  //class name",
"  \"bd:visual\",",
"",
"  //superclasses",
"  [bd.creatable, bd.id, bd.stateful, bd.connectable, bd.cssStateful, bd.containable], ",
"",
"  //members",
"  bd.attr(",
"    ///",
"    //(string) The name associated with this widget instance.",
"    ///",
"    // The name associated with this widget. //Typically, names are not page-unique, but rather are unique among siblings.",
"    \"name\", ",
"    ",
"    \"\" //default value",
"  ), ",
"",
"  bd.attr(",
"    ///",
"    //(boolean) true if this widget is visible; false otherwise.",
"    ///",
"    // Controls the presence of CSS state \'hidden\' in the cssStateful string. //If true, ",
"    // then the cssStateful class toggles the state `hidden` off, and conversely. So",
"    // long as an appropriate CSS style sheet is loaded, this will control whether or not",
"    // the DOM subtree is visible. Attempting to set visible to false when the DOM subtree",
"    // has the focus or is selected will fail and result in a no-op.",
"    \"visible\", ",
"",
"    true, //default value",
"",
"    function(value) { //setter",
"      value= !!value;",
"      var oldValue= this.visible;",
"      if (oldValue!==value) {",
"        if (!value) {",
"          if (this.get(\"focused\")) {",
"            dojo.onError(\"trying to hide a widget with the focus\", [this]);",
"            return bd.failed;",
"          }",
"          if (this.get(\"selected\")) {",
"            this.set(\"selected\", false);",
"          }",
"        }",
"        this.visible= value;",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.constDomAttr(",
"    ///",
"    //(string) The DOM `lang` attribute.",
"    //(undefined) The DOM `lang` attribute is not set.",
"    ///",
"    // The DOM `lang` attribute for this.domNode.",
"    \"lang\"",
"  ), ",
"  ",
"  bd.domAttr(",
"    ///",
"    //(string) The DOM `title` attribute.",
"    //(undefined) The DOM `title` attribute is not set.",
"    ///",
"    // The DOM `title` attribute for this.domNode.",
"    \"title\"",
"  ), ",
"",
"  bd.domAttr(",
"    ///",
"    //(string) The DOM `class` attribute.",
"    ///",
"    // The DOM `class` attribute for this.domNode.",
"    ///",
"    // Setting a new class value results in removing the old class value from this.domNode. However,",
"    // manipulating the class value through this attribute will not affect other classes that have been",
"    // set on the DOM node through other means. For example, assuming `o` is a bd.visual-derived instance",
"    // variable that currently has no class attribute,",
"    //code",
"    // o.set(\"class\", \"myClass\");",
"    // dojo.addClass(o.domNode, \"someOtherClass\");",
"    // dojo.getClass(o.domNode); //returns \"myClass someOtherClass\"",
"    // o.set(\"class\", \"myOtherClass\");",
"    // dojo.getClass(o.domNode); //returns \"myOtherClass someOtherClass\"",
"    \"class\", ",
"",
"    undefined, //default value",
"",
"    0, //target is domNode",
"",
"    function(value) { //setter",
"      var ",
"        node= this.classNode || this.domNode,",
"        oldValue= this[\"class\"];",
"      if (node) {",
"       dojo.removeClass(node, oldValue);",
"       value && dojo.addClass(node, value);",
"      }",
"      this[\"class\"]= value;",
"      return oldValue;",
"    }",
"  ),",
" ",
"  bd.domAttr(",
"    ///",
"    //(string) For the setter, a DOM style string suitable for `dojo.style`.",
"    //(hash)  For the setter, a hash of DOM style attributes suitable for `dojo.style`.",
"    //(string) For the getter, a DOM style cssText string.",
"    ///",
"    // The DOM `style` attribute.",
"    \"style\",",
"",
"    undefined, //default value",
"",
"    0, //target is domNode",
"",
"    function(value) { //setter",
"      var ",
"        node= this.styleNode || this.domNode,",
"        oldValue= this.style;",
"      if (node) {",
"        if (bd.isString(value)) {",
"          if (node.style.cssText) {",
"            node.style.cssText += \"; \" + value;",
"          } else {",
"            node.style.cssText = value;",
"          }",
"        } else if (value) {",
"          dojo.style(node, value);",
"        }",
"      }",
"      this.style= node.style.cssText;",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.constAttr(",
"    ///",
"    //(boolean) true is the widget or any of its decendents will not react to any user input; false otherwise.",
"    ///",
"    // True indicates the widget is either incapable of reacting, or, because of its current state, will not react to *any* user",
"    // input; false indicates the widget is capable of and will react to some kinds of user interaction (typcially, keyboard or mouse);",
"    //note",
"    // Since bd.visual does not define any kind of user interaction, it is always disabled. Classes derived from",
"    // bd.visual will often override this constant value and provide the setter.",
"    \"disabled\", ",
"",
"    true //constant value",
"  ),",
"",
"  bd.constAttr(",
"    ///",
"    //(boolean) false is the widget and all of its decendents has/have no use for the focus; true otherwise.",
"    ///",
"    //note",
"    // Since bd.visual does not define any kind of user interaction, focusable is always false. Classes derived from",
"    // bd.visual will often override this constant value and provide the setter.",
"    \"focusable\", ",
"",
"    false //constant value",
"  ),",
"",
"  bd.constAttr(",
"    ///",
"    //(boolean) true if this widget has the focus; false otherwise.",
"    ///",
"    // The focused attribute is not used to set the focus: it is strinctly a read-only attribute. Use the method `focus`",
"    // to set the focus to a particular widget instance.",
"    \"focused\", ",
"",
"    false //constant value",
"  ),",
"",
"  bd.constDomAttr(",
"    ///",
"    //(string) The DOM `dir` attribute.",
"    //(undefined) The DOM `dir` attribute is not set.",
"    ///",
"    // The DOM `dir` attribute for this.domNode.",
"    \"dir\", ",
"  ",
"    undefined, //default value",
"",
"    0,",
"",
"    function() {",
"	    return (this.dir ? this.dir : (dojo._isBodyLtr() ? \"ltr\" : \"rtl\"));",
"    }",
"  ),",
"",
"  {",
"  initAttrs:",
"    ///",
"    // (set) Gives the set of attributes to initialize during DOM creation.",
"    ///",
"    // The set of attributes to create when the root DOM node is created. //For every key in initAttrs, an attribute",
"    // of that name is created with the value `this[key]`. For example, if initAttributes is {dir:1, lang:1}, then",
"    // attributes are set as follows in the createDom phase of construction:",
"    //code",
"    // if (this.dir!==undefined) this.domNode.setAttribute(\"dir\", this.dir);",
"    // if (this.lang!==undefined) this.domNode.setAttribute(\"lang\", this.lang);",
"    ///",
"    // Notice that, as with all sets, the values of the properties in the object are ignored.",
"    {dir:1, lang:1, \"class\":1, style:1, title:1},",
"",
"  cssStatefulWatch: ",
"    ///",
"    // The list of attributes for cssStateful to watch. //This is frequently",
"    // overridden by subclasses.",
"    {visible:0, disabled:0, focused:0},",
"",
"  kwargs:",
"    ///",
"    // The argument passed to the constructor. //Although the constructor stores the argument passed into this",
"    // attribute, subclasses are free to discard part or all of this object during create processing.",
"    bd.nodoc,",
"",
"  domNode:",
"    ///",
"    // The root DOM node controlled by each instance.",
"    0,",
"",
"  createDom: function() {",
"    ///",
"    // Creates a DOM div node. //Initializes the node with attributes given by the method `getCreateDomAttributes`.",
"    this.domNode= dojo.create(\'div\', this.getCreateDomAttributes());",
"  }",
"});",
"",
"});",
"// Copyright (c) 2008-2010, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.domAttr":{
type:
Tfunction,
sdoc:
["Similar to bd.attr except that the attibute is a DOM attribute on the DOM node implied by target."],
ldoc:
["See bd.attr and bd.stateful for more details on getters and setters."],
params:
[["name",[["string",
["The property name."]]]],
["defaultValue",[["any",
["The initial value for the attribute; undefined indicates no value should be set."]]]],
["target",[["string",
["attribute in node is given by this.domNode.target"]],
["pair of [domNode, target]",
["attribute in node is given by this[target[0]].[target[1]]"]],
["single of [domNode]",
["attribute in node is given by this[target[0]].[name]"]],
["falsy",
["attribute in node is given by this.domNode[name]"]]]],
["setter",[["function(newValue), optional, see description",
["Function that sets the property to newValue and returns the previous value."]]]],
["getter",[["function(), optional, see description",
["Function that returns the current value of property."]]]]],
src:
"bd/visual",
loc: [13,0,60,1],
module:"bd/visual"}
,"bd.constDomAttr":{
type:
Tfunction,
sdoc:
["Similar to bd.domAttr except that no setter is defined"],
ldoc:
[],
params:
[["name",[["string",
["The property name."]]]],
["defaultValue",[["any",
["The initial value for the property."]]]],
["target",[["string",
["attribute in node is given by this.domNode.target"]],
["pair of [domNode, target]",
["attribute in node is given by this[target[0]].[target[1]]"]],
["single of [domNode]",
["attribute in node is given by this[target[0]].[name]"]],
["falsy",
["attribute in node is given by this.domNode[name]"]]]],
["getter",[["function(), optional, see description",
["Function that returns the current value of property."]]]]],
src:
"bd/visual",
loc: [62,0,76,1],
module:"bd/visual"}
,"bd.visual":{
type:
Tclass,
sdoc:
["Base class for a Backdraft widget."],
ldoc:
["A Backdraft class with a visual presentation that is creatable by bd.createWidget is termed a Backdraft\nwidget, and this class is designed to be used as the base class to build such classes. The key requirement\nof a backdraft widget is that it must be constructable with a single argument of type bd.createWidget.kwargs and must be\nfindable via the widget registry (bd.object.registry). The widget registry requirement implies widgets must\ncontain a page-unique identifier.",
"Although not required, a few more features are almost-always desired:\n\n  * the features of bd.stateful\n  * the features of bd.id\n  * the features of bd.connectable\n  * the features of bd.cssStateful\n  * the features of bd.containable\n  * a visual presentation via a DOM subtree\n\nThis class provides these features by deriving from the above-mentioned classes and\nproviding foundational machinery for creating and controlling a DOM subtree.",
[NOTE,"Backdraft widgets need not include a DOM presentation--it is perfectly accepable and\nuseful to define widget classes that work as controller/processing automatons within the widget tree of an application."],
[NOTE,"It is not a requirement that a Backdraft widget is derived from this class. Other widget systems (e.g., Dojo\'s dijit\nwidgets) can be lightly wrapped to allow for creation by bd.createWidget."]],
src:
"bd/visual",
loc: [78,0,332,2],
supers:
["bd.creatable","bd.id","bd.stateful","bd.connectable","bd.cssStateful","bd.containable"],
module:"bd/visual"}
,"bd.visual.dir":{
type:
Tvariable,
sdoc:
["The DOM `dir` attribute for this.domNode."],
imember:1,
ldoc:
[],
flags:
[Froattr],
loc: [278,2,293,3],
types:
[["string",
["The DOM `dir` attribute."]],
["undefined",
["The DOM `dir` attribute is not set."]]]}
,"bd.visual.focused":{
type:
Tvariable,
sdoc:
["The focused attribute is not used to set the focus: it is strinctly a read-only attribute. Use the method `focus`\nto set the focus to a particular widget instance."],
imember:1,
ldoc:
[],
flags:
[Froattr],
loc: [267,2,276,3],
types:
[["boolean",
["true if this widget has the focus; false otherwise."]]]}
,"bd.visual.focusable":{
type:
Tvariable,
imember:1,
ldoc:
[[NOTE,"Since bd.visual does not define any kind of user interaction, focusable is always false. Classes derived from\nbd.visual will often override this constant value and provide the setter."]],
flags:
[Froattr],
loc: [255,2,265,3],
types:
[["boolean",
["false is the widget and all of its decendents has/have no use for the focus; true otherwise."]]]}
,"bd.visual.disabled":{
type:
Tvariable,
sdoc:
["True indicates the widget is either incapable of reacting, or, because of its current state, will not react to *any* user\ninput; false indicates the widget is capable of and will react to some kinds of user interaction (typcially, keyboard or mouse);"],
imember:1,
ldoc:
[[NOTE,"Since bd.visual does not define any kind of user interaction, it is always disabled. Classes derived from\nbd.visual will often override this constant value and provide the setter."]],
flags:
[Froattr],
loc: [241,2,253,3],
types:
[["boolean",
["true is the widget or any of its decendents will not react to any user input; false otherwise."]]]}
,"bd.visual.style":{
type:
Tvariable,
sdoc:
["The DOM `style` attribute."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [208,2,239,3],
types:
[["string",
["For the setter, a DOM style string suitable for `dojo.style`."]],
["hash",
["For the setter, a hash of DOM style attributes suitable for `dojo.style`."]],
["string",
["For the getter, a DOM style cssText string."]]]}
,"bd.visual.class":{
type:
Tvariable,
sdoc:
["The DOM `class` attribute for this.domNode."],
imember:1,
ldoc:
["Setting a new class value results in removing the old class value from this.domNode. However,\nmanipulating the class value through this attribute will not affect other classes that have been\nset on the DOM node through other means. For example, assuming `o` is a bd.visual-derived instance\nvariable that currently has no class attribute,",
[CODE,"o.set(\"class\", \"myClass\");\ndojo.addClass(o.domNode, \"someOtherClass\");\ndojo.getClass(o.domNode); //returns \"myClass someOtherClass\"\no.set(\"class\", \"myOtherClass\");\ndojo.getClass(o.domNode); //returns \"myOtherClass someOtherClass\""]],
flags:
[Fattr],
loc: [173,2,206,3],
types:
[["string",
["The DOM `class` attribute."]]]}
,"bd.visual.title":{
type:
Tvariable,
sdoc:
["The DOM `title` attribute for this.domNode."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [164,2,171,3],
types:
[["string",
["The DOM `title` attribute."]],
["undefined",
["The DOM `title` attribute is not set."]]]}
,"bd.visual.lang":{
type:
Tvariable,
sdoc:
["The DOM `lang` attribute for this.domNode."],
imember:1,
ldoc:
[],
flags:
[Froattr],
loc: [155,2,162,3],
types:
[["string",
["The DOM `lang` attribute."]],
["undefined",
["The DOM `lang` attribute is not set."]]]}
,"bd.visual.visible":{
type:
Tvariable,
sdoc:
["Controls the presence of CSS state \'hidden\' in the cssStateful string. "],
imember:1,
ldoc:
["Controls the presence of CSS state \'hidden\' in the cssStateful string. If true,\nthen the cssStateful class toggles the state `hidden` off, and conversely. So\nlong as an appropriate CSS style sheet is loaded, this will control whether or not\nthe DOM subtree is visible. Attempting to set visible to false when the DOM subtree\nhas the focus or is selected will fail and result in a no-op."],
flags:
[Fattr],
loc: [123,2,153,3],
types:
[["boolean",
["true if this widget is visible; false otherwise."]]]}
,"bd.visual.name":{
type:
Tvariable,
sdoc:
["The name associated with this widget. "],
imember:1,
ldoc:
["The name associated with this widget. Typically, names are not page-unique, but rather are unique among siblings."],
flags:
[Fattr],
loc: [113,2,121,3],
types:
[["string",
["The name associated with this widget instance."]]]}
,"bd.visual.initAttrs":{
type:
Tvariable,
sdoc:
["(set) Gives the set of attributes to initialize during DOM creation."],
imember:1,
ldoc:
["The set of attributes to create when the root DOM node is created. //For every key in initAttrs, an attribute\nof that name is created with the value `this[key]`. For example, if initAttributes is {dir:1, lang:1}, then\nattributes are set as follows in the createDom phase of construction:",
[CODE,"if (this.dir!==undefined) this.domNode.setAttribute(\"dir\", this.dir);\nif (this.lang!==undefined) this.domNode.setAttribute(\"lang\", this.lang);"],
"Notice that, as with all sets, the values of the properties in the object are ignored."],
loc: [296,2,308,48]}
,"bd.visual.cssStatefulWatch":{
type:
Tvariable,
sdoc:
["The list of attributes for cssStateful to watch. "],
imember:1,
ldoc:
["The list of attributes for cssStateful to watch. This is frequently\noverridden by subclasses."],
loc: [310,2,314,38]}
,"bd.visual.kwargs":{
type:
Tvariable,
sdoc:
["The argument passed to the constructor. "],
imember:1,
ldoc:
["The argument passed to the constructor. Although the constructor stores the argument passed into this\nattribute, subclasses are free to discard part or all of this object during create processing."],
loc: [316,2,320,12]}
,"bd.visual.domNode":{
type:
Tvariable,
sdoc:
["The root DOM node controlled by each instance."],
imember:1,
ldoc:
[],
loc: [322,2,325,5]}
,"bd.visual.createDom":{
type:
Tfunction,
sdoc:
["Creates a DOM div node. "],
imember:1,
ldoc:
["Creates a DOM div node. Initializes the node with attributes given by the method `getCreateDomAttributes`."],
loc: [327,2,331,3]}
,"modules.bd/visual":{
type:
Tmodule,
sdoc:
["Defines the bd.visual class and associated machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/visual",
loc: [0,0,334,2]}
,"resources.bd/widget/borderContainer":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/borderContainer"],
src:
"bd/widget/borderContainer",
modules:
["bd/widget/borderContainer"],
docLocs:
[[731,775]],
code:
["dojo.def(\"bd/widget/borderContainer\", [",
"  \"bd\",",
"  \"dojo\",",
"  \"bd/visual\",",
"  \"bd/focusable\",",
"  \"bd/mouseable\",",
"  \"bd/css\",",
"  \"bd/mouse\"",
"], function(bd, dojo) {",
"///",
"// Defines the bd.widget.borderContainer class.",
"",
"var",
"  top     = \"top\",",
"  left    = \"left\",",
"  bottom  = \"bottom\",",
"  right   = \"right\",",
"  regions = [top, left, bottom, right],",
"  others= [",
"    {top: [left, right], bottom: [left, right]}, //headline",
"    {left: [top, bottom], right: [top, bottom]}  //sidebar",
"  ],",
"  makeDragFunction= function(region, container) {",
"    // cache a lot of variables to make the actual functions easy to write and fast to compute...",
"    var",
"      // the region that\'s being dragged...",
"      regionInfo= container[region],",
"      child= regionInfo.child,",
"      childNode= regionInfo.child.domNode,",
"      childBox= regionInfo.box,",
"      splitterNode= regionInfo.splitter.domNode,",
"      splitterBox= regionInfo.splitterBox,",
"      dragMin= regionInfo.dragMin,",
"      dragMax= regionInfo.dragMax,",
"",
"      // the other regions tha are affected...",
"      centerBox= container.centerBox,",
"      othersAffected= others[this.design==\"headline\" ? 0 : 1][region],",
"      affected= []; //a vector of (widget, domNode, marginBox) of the other widgets affected by this drag",
"    affected.push([container.center, container.center && container.center.domNode, container.centerBox]);",
"    bd.forEach(others[container.design==\"headline\" ? 0 : 1][region], function(region) {",
"      var info= container[region];",
"      info.child && affected.push([info.child, info.child.domNode, info.box, container[region]]);",
"      info.splitter && affected.push([info.child, info.splitter.domNode, info.splitterBox]);",
"    });",
"",
"    var",
"      // scratch variables for the compute function",
"      i, ",
"      end= affected.length,",
"      scratchBox1= {},",
"      scratchBox2= {},",
"      scratchBox3= {},",
"      box, widget, size;",
"",
"    // note: it\'s just easier to write two functions instead of trying to contort one function for all four circumstances",
"",
"    function makeTopOrLeft(t, h) {",
"      return function(delta, live, finish) {",
"        size= childBox[h];",
"        delta= Math.max(dragMin, Math.min(size + centerBox[h], size + delta, dragMax)) - size;",
"        size= childBox[h] + delta;",
"        scratchBox1[t]= splitterBox[t] + delta;",
"        dojo.marginBox(splitterNode, scratchBox1);",
"        if (live || finish) {",
"          scratchBox2[h]= childBox[h] + delta;",
"          dojo.marginBox(childNode, scratchBox2);",
"          child.layout && child.layout(childBox.h + (h==\"h\" ? delta : 0), childBox.w + (h==\"w\" ? delta : 0));",
"          scratchBox3[t]= centerBox[t] + delta;",
"          scratchBox3[h]= centerBox[h] - delta;",
"          for (i= 0; i<end; i++) {",
"            var info= affected[i];",
"            info[1] && dojo.marginBox(info[1], scratchBox3);",
"            (widget= info[0]) && widget.layout && widget.layout(info[2].h - (h==\"h\" ? delta : 0), info[2].w - (h==\"w\" ? delta : 0));",
"          }",
"        }",
"        if (finish) {",
"          childBox[h]+= delta;",
"          splitterBox[t]+= delta;",
"          regionInfo.size= size;",
"          for (i= 0; i<end; i++) {",
"            box= affected[i][2];",
"            box[t]= scratchBox3[t];",
"            box[h]= scratchBox3[h];",
"            affected[i][3] && (affected[i][3].size= box[h]);",
"          }",
"        }",
"      };",
"    }",
"",
"    function makeBottomOrRight(t, h) {",
"      return function(delta, live, finish) {",
"        size= childBox[h];",
"        delta= size - Math.max(dragMin, Math.min(size + centerBox[h], size - delta, dragMax));",
"        size= centerBox[h] - delta;",
"        scratchBox1[t]= splitterBox[t] + delta;",
"        dojo.marginBox(splitterNode, scratchBox1);",
"        if (live || finish) {",
"          scratchBox2[t]= childBox[t] + delta;",
"          scratchBox2[h]= childBox[h] - delta;",
"          dojo.marginBox(childNode, scratchBox2);",
"          child.layout && child.layout(childBox.h - (h==\"h\" ? delta : 0), childBox.w - (h==\"w\" ? delta : 0));",
"          scratchBox3[h]= centerBox[h] + delta;",
"          for (i= 0; i<end; i++) {",
"            affected[i][1] && dojo.marginBox(affected[i][1], scratchBox3);",
"            (widget= affected[i][0]) && widget.layout && widget.layout(affected[i][2].h + (h==\"h\" ? delta : 0), affected[i][2].w + (h==\"w\" ? delta : 0));",
"          }",
"        }",
"        if (finish) {",
"          childBox[t]+= delta;",
"          childBox[h]-= delta;",
"          splitterBox[t]+= delta;",
"          regionInfo.size= size;",
"          for (i= 0; i<end; i++) {",
"            affected[i][2][h]= scratchBox3[h];",
"            affected[i][3] && (affected[i][3].size= scratchBox3[h]);",
"          }",
"        }",
"      };",
"    }",
"    switch (region) {",
"      case \"top\": return makeTopOrLeft(\"t\", \"h\");",
"      case \"left\": return makeTopOrLeft(\"l\", \"w\");",
"      case \"bottom\": return makeBottomOrRight(\"t\", \"h\");",
"      case \"right\": return makeBottomOrRight(\"l\", \"w\");",
"    }",
"    return 0;",
"  };",
"",
"bd.declare(",
"  ///",
"  // A dragable splitter bar widget for use with bd.widget.borderContainer.",
"  ///",
"  // The widget consists of an a \"bar\" that\'s presented as a simple, empty, usually colored, div that\'s intended to be absolutely positioned by the owning",
"  // border container. The widget is derived from bd.focusable, bd.mouseable, and bd.cssStateful with the focused and hover states watched",
"  // by bd.cssStateful. This allows the bar to be stylized when the mouse hovers over it (e.g., by changing it\'s background color).",
"  // ",
"  // A non-trivial `onMouseDown` connection point is included that captures the mouse and sends coordinates to a drag function as the mouse",
"  // is dragged. The drag function, provided by the owning parent, calculates a new position for the bar based on the mouse coordinates and",
"  // then places the bar at this position. Naturally, the capture process gracefully releases the mouse at the completion of the drag",
"  // opertation.",
"  ",
"  // classname",
"  \"bd:widget.splitter\", ",
"",
"  //superclasses",
"  [bd.visual, bd.focusable, bd.mouseable],",
"",
"  //members",
"  {",
"  initAttrs:",
"    {\"class\":1, style:1},",
"",
"  cssStatefulWatch: ",
"    {visible:0, disabled:0, focused:0, hover:0},",
"",
"  precreateDom: function() {",
"    this.inherited(arguments);",
"    this.cssStatefulBases= /top|bottom/.test(this.region) ? {dijitReset: 0, bdSplitterH:0} : {dijitReset: 0, bdSplitterV:0};",
"  },",
"",
"  onMouseDown: function(",
"    e ///(DOM event object) The DOM event object consequent to the mousedown event.",
"  ){",
"    ///",
"    // Stops the event, captures the mouse, sends all mouse movements to a drag function provided by the owning container; ",
"    // releases capture on mouseup. //Upon capture, adds the DOM class \"bdSplitterActive\"; removes this class upon capture release.",
"    dojo.stopEvent(e);",
"    var",
"      parent= this.parent,",
"      region= this.region,",
"      regionInfo= parent[region],",
"      coordPlane= /top|bottom/.test(region) ? \"clientY\" : \"clientX\",",
"      coordStart= e[coordPlane],",
"      lastDelta= 0;",
"",
"    regionInfo.drag= makeDragFunction(region, parent);",
"    dojo.addClass(this.domNode, \"bdSplitterActive\");",
"    parent.curtain.style.zIndex= 1;",
"    bd.mouse.capture(this, {",
"      mousemove: function(e){",
"        lastDelta= e[coordPlane] - coordStart;",
"        regionInfo.drag(lastDelta, parent.live, false);",
"      },",
"      mouseup: function(e){",
"        try {",
"          lastDelta= e[coordPlane] - coordStart;",
"        } finally {",
"          bd.mouse.release();",
"        }",
"      }",
"    }, dojo.hitch(this, function() {",
"      bd.mouse.release();",
"      parent.curtain.style.zIndex= -1;",
"      dojo.removeClass(this.domNode, \"bdSplitterActive\");",
"      regionInfo.drag(lastDelta, true, true);",
"    }));",
"  },",
"",
"  destroy: function() {",
"    if (bd.mouse.capture.by===this) {",
"      bd.mouse.release();",
"    }",
"    delete this.parent;",
"    this.inherited(arguments);",
"  }",
"});",
"",
"return bd.declare(",
"  ///",
"  // A container that can hold, manage, and layout up to five children widgets--four in fixed or user-sizeable regions along each side of a center rectangle, and a fifth in the center rectangle.",
"  ///",
"  // The container always consists of a center region. Optionally, additional regions may be added along",
"  // each side (top, bottom, left, right) of the workspace. When both horizontal (top and/or bottom) and vertical",
"  // (left and/or right) children are added, then one or the other must be dominate (span the entire available",
"  // area) and the other must be subordinate (span between the inner borders of the dominate containers children).",
"  // The attribute `design` controls this aspect of the layout, with the value `\"headline\"` indicating the top/bottom",
"  // regions are dominate and the value `\"sidebar\"` indicating the left/right\" regions are dominate.",
"  // ",
"  // Children are added/removed to/from the top, left, bottom, right, and center regions through the `top`, `left`, `bottom`, `right`,",
"  // and `center` attributes. Since the center region has no sizing information (it gets whatever is left over from the other regions, ",
"  // the `center` attribute simply controls the child (if any) that exists in the center region.",
"  // ",
"  // The remaining region attributes control a composite value that contains the following properties:",
"  // ",
"  // * child: the child widget to place in the region.",
"  // * splitter: boolean, says the region is sizeable.",
"  // * splitterClass: (string) gives the class name to use for the region, non-empty implies the property splitter is true.",
"  // * delegateSize: (boolean) says the child will calculate its desired size during layout.",
"  // * size: (integer or percent) says the precise size in pixels or percent the child desires.",
"  // * min: (integer or percent) says the minimize size in pixels or percent the child desires.",
"  // * max: (integer or percent) says the maximum size in pixels or percent the child desires.",
"  // ",
"  // See bd.widget.borderContainer.setRegion for details.",
"  // ",
"  // Sizes are advisory, but the border container will attempt to fulfill requests so long as there is enough room to show",
"  // all existing containers. This can be guaranteed by ensuring the border container itself is never resized smaller than",
"  // some reasonable minimum, but this is the responsibility of the parent of the border container.",
"  // ",
"  // Given a set of children, possibly with splitters and a design attribute, the layout method calculates the layout and",
"  // absolutely positions the children within the container.",
"  // ",
"  // If any border children contain a splitter, then when that splitter is dragged, the associated child and the center region",
"  // are resized consequent to the drag, restricted by any min/max sizes placed on the region.",
"",
"  // classname",
"  \"bd:widget.borderContainer\",",
"",
"  // superclasses",
"  [bd.visual, bd.focusable],",
"",
"  //members",
"  bd.constAttr(",
"    ///",
"    // Indicates which border regions are dominate.",
"    ///",
"    //(\"headline\", default) The top and/or bottom regions (if any) span the entire width of the container and the left and/or right",
"    // regions (if any) are fit between the top and/or bottom.",
"    //(\"sidebar\") The left and/or right regions (if any) span the entire height of the container and the top and/or bottom",
"    // regions (if any) are fit between the left and/or right.",
"    \"design\", ",
"    \"headline\" //default value",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Controls whether or not child widgets are redrawn when splitter bars are dragged",
"    ///",
"    //(boolean, optional, true) Child widgets are redrawn during splitter bar dragging iff true; child widgets ",
"    // remain stationary during splitter bar dragging otherwise.",
"    \"live\",",
"    true //default value",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Gives the class name to use for the splitter bars.",
"    ///",
"    //(string, optional, \"bd:widget.splitter\") The class name to user for the splitter bars.",
"    \"splitterClass\",",
"    \"bd:widget.splitter\" //default value",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Controls the configuration of the top region (if any). //It is not required that all region",
"    // configuration properties be provided to the setter. When a region is set with a subset of the",
"    // configuration properties, the current properties or defaults are used to fill in the missing",
"    // properties. This allows, for example, changing the child while keeping sizing and splitter",
"    // configuration constant. See bd.widget.borderContainer.setRegion for details.",
"    ///",
"    //(bd.widget.borderContainer.regionInfo) The properties controlling the region.",
"    \"top\",",
"",
"    0, //per-instance explicit initialization handled in precreateDom",
"",
"    function(value) { //setter",
"      return this.setRegion(\"top\", value);",
"    },",
"",
"    function() { //getter",
"      return this.getRegion(\"top\");",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Controls the configuration of the left region (if any). //It is not required that all region",
"    // configuration properties be provided to the setter. When a region is set with a subset of the",
"    // configuration properties, the current properties or defaults are used to fill in the missing",
"    // properties. This allows, for example, changing the child while keeping sizing and splitter",
"    // configuration constant. See bd.widget.borderContainer.setRegion for details.",
"    ///",
"    //(bd.widget.borderContainer.regionInfo) The properties controlling the region.",
"    \"left\",",
"",
"    0, //per-instance explicit initialization handled in precreateDom",
"",
"    function(value) { //setter",
"      return this.setRegion(\"left\", value);",
"    },",
"",
"    function() { //getter",
"      return this.getRegion(\"left\");",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Controls the configuration of the bottom region (if any). //It is not required that all region",
"    // configuration properties be provided to the setter. When a region is set with a subset of the",
"    // configuration properties, the current properties or defaults are used to fill in the missing",
"    // properties. This allows, for example, changing the child while keeping sizing and splitter",
"    // configuration constant. See bd.widget.borderContainer.setRegion for details.",
"    ///",
"    //(bd.widget.borderContainer.regionInfo) The properties controlling the region.",
"    \"bottom\",",
"",
"    0, //per-instance explicit initialization handled in precreateDom",
"",
"    function(value) { //setter",
"      return this.setRegion(\"bottom\", value);",
"    },",
"",
"    function() { //getter",
"      return this.getRegion(\"bottom\");",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Controls the configuration of the right region (if any). //It is not required that all region",
"    // configuration properties be provided to the setter. When a region is set with a subset of the",
"    // configuration properties, the current properties or defaults are used to fill in the missing",
"    // properties. This allows, for example, changing the child while keeping sizing and splitter",
"    // configuration constant. See bd.widget.borderContainer.setRegion for details.",
"    ///",
"    //(bd.widget.borderContainer.regionInfo) The properties controlling the region.",
"    \"right\",",
"",
"    0, //per-instance explicit initialization handled in precreateDom",
"",
"    function(value) { //setter",
"      return this.setRegion(\"right\", value);",
"    },",
"",
"    function() { //getter",
"      return this.getRegion(\"right\");",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Controls the contents of the center region (if any). //Unlike the top, left, bottom, and right regions,",
"    // the center region has no sizing or splitter configuration.",
"    ///",
"    //(widget) The widget to place in the region; null to remove the current widget from the region.",
"    \"center\",",
"",
"    0, //per-instance explicit initialization handled in precreateDom",
"",
"    function(value) { //setter",
"      var oldValue= this.center;",
"      if (value!==oldValue) {",
"        this.center && this.domNode.removeChild(this.center.domNode);",
"        this.center= value;",
"        value.parent= this;",
"        value && dojo.place(value.domNode, this.domNode, \"last\");",
"        this.started && bd.startupChild(value);",
"      }",
"    },",
"",
"    function() { //getter",
"      return this.center;",
"    }",
"  ),",
"",
"  {",
"  initAttrs:",
"    {dir:1, lang:1, \"class\":1, style:1},",
"",
"  cssStatefulBases: ",
"    {dijitReset: 0, bdBorderContainer:1},",
"",
"  cssStatefulWatch: ",
"    {visible:0, disabled:0},",
"",
"  precreateDom: function() {",
"    ///",
"    // Initializes a new border container.",
"    ///",
"    // The descriptor may contain the properties top, left, bottom, and right of type bd.widget.borderContainer.regionInfo that",
"    // preconfigure the regions. However, this method of initialization is not typically used. Instead, a particular child",
"    // usually informs the border container of its layout desires through is the regionInfo property in its parent space. See bd.widget.borderContainer.setRegion.",
"    this.inherited(arguments);",
"    dojo.forEach(regions, function(region) {",
"      this[region]= bd.mix({}, {",
"        child: 0,         // (widget)",
"        splitter: 0,      // (widget)",
"        splitterClass: 0, // (string) class name ",
"        splitterSize: 0,  // the last calculated size of the splitter (h for top/bottom, w for left/right)",
"        size: 0,          // number implies px, string implies percent (e.g., \"25%\")",
"        delegateSize: 0,  // ask the child how big it wants to be?",
"        min: \"5%\",        // number or percent or missing",
"        max: \"80%\",       // number of percent or missing",
"        dragMin: 0,       // pixels last calculated",
"        dragMax: 0        // pixels last calculated",
"      }, this.descriptor[region]);",
"    }, this);",
"  },",
"",
"  createDom: function() {",
"    this.inherited(arguments);",
"    this.curtain= dojo.create(\"div\", {\"class\":\"bdBorderContainerCurtain\"}, this.domNode);",
"  },",
"",
"  startup: function(top) {",
"    if (!this.started) {",
"      bd.forEach(regions, function(region) {",
"        bd.startupChild(this[region].child);",
"      }, this);",
"      bd.startupChild(this.center);",
"      this.inherited(arguments);",
"    }",
"  },",
"",
"  startupChild: function(",
"    region",
"  ) {",
"    // note: this routine does not call layout; it is called by either startup or setRegion, both of which",
"    // ensure layout is called iff required.",
"    var child= this[region].child;",
"    if (this.started && child) {",
"      bd.startupChild(child);",
"      this[region].splitter && bd.startupChild(this[region].splitter);",
"    }",
"  },",
"",
"  destroy: function() {",
"    //TODO",
"  },",
"",
"  disabledSet: function(",
"    value",
"  ) {",
"    this.curtain.style.zIndex= value ? 3 : -1;",
"  },",
"",
"  getRegion: function(",
"    region ///(\"top\", \"left\", \"bottom\", \"right\", \"center\") Identifies the region of interest.",
"  ) {",
"    ///",
"    // Returns the region information for a the region `region`.",
"    return bd.mix({}, this[region]);",
"  },",
"",
"  setRegion: function(",
"    region, ///(\"top\", \"left\", \"bottom\", \"right\") Identifies the region of interest.",
"    newRegionInfo ///(bd.widget.borderContainer.regionInfo) Specifies new configuration for the region.",
"  ) {",
"    ///",
"    // The entry point to add/modify/remove a top, left, bottom, right region.",
"    ///",
"    // Clients should not access this method directly, but rather should set a region\'s configuration through",
"    // the `top`, `left`, `bottom`, `right` attributes. That said, all of these setters delegate to this method;",
"    // and, therefore, function identically as follows:",
"    // ",
"    // The region indicated is configured as given by newRegionInfo together with the current configuration for",
"    // the given region:",
"    // ",
"    // * If child is truthy, then any existing child is removed and the given child is placed in the region; if",
"    //   child is falsy but not undefined, then any existing child is removed from the region; if child is undefined",
"    //   then nothing is done with the child.",
"    // * If splitter or splitterClass exists, then the region is made resizeable with a splitter; if splitterClass",
"    //   is undefined, then the border containers `splitterClass` attribute is used to determine the splitter class. If",
"    //   splitter and splitterClass are undefined, the the splitter status is not changed.",
"    // * If delegateSize, size, min, or max are undefined, then the given values are used to control the region\'s layout; otherwise",
"    //   the existing value for the particular attribute is not changed.",
"    // ",
"    // After the region is reconfigured, the border container\'s layout is recalculated.",
"    //",
"    // Since the center region has no configurable splitters or sizing, it is set directly by the `center` attibute.",
"    if (!(/top|left|bottom|right/.test(region))) {",
"      console.warn(\"illigal region in bd:widget.borderContainer.setRegion\", region);",
"      return {};",
"    }",
"    var ",
"      regionInfo= this[region],",
"      oldRegionInfo= bd.mix({}, regionInfo),",
"      removeSplitter= function() {",
"        if (regionInfo.splitter) {",
"          regionInfo.splitter.destroy();",
"          regionInfo.splitter= 0;",
"        }",
"      },",
"      setSplitter= function(splitter, splitterClass, container) {",
"        if (splitter===undefined) {",
"          // newRegionInfo didn\'t mention splitter",
"          splitterClass= splitterClass || regionInfo.splitterClass;",
"        } else if (!splitter) {",
"          // newRegionInfo specifically said no spliter",
"          splitterClass= 0;",
"        } else if (splitter) {",
"          // newRegionInfo specifically said do a splitter",
"          splitterClass= splitterClass || regionInfo.splitterClass || container.splitterClass;",
"        } else {",
"          // if newRegionInfo gave a splitter class or regionInfo has a splitter class; then we have a splitter, and conversely",
"          splitterClass= splitterClass || regionInfo.splitterClass;",
"        }",
"        if (splitterClass) {",
"          (regionInfo.splitterClass!==splitterClass) && removeSplitter();",
"          if (regionInfo.child && !regionInfo.splitter) {",
"            bd.createWidget(",
"              {descriptor:{className: splitterClass, region:region}},",
"              function(splitter) { ",
"                splitter.parent= container;",
"                dojo.place(splitter.domNode, container.domNode, \"last\");",
"                regionInfo.splitter= splitter; ",
"              } ",
"            );",
"          }",
"        }",
"      };",
"",
"    // set child before splitter since a non-null child will also set the splitter",
"    // and attempting to set the splitter before a non-null child exists won\'t work",
"    if (\"child\" in newRegionInfo) {",
"      if (newRegionInfo.child && newRegionInfo.child!==regionInfo.child) {",
"        // adding or changing a child",
"        regionInfo.child && this.domNode.removeChild(regionInfo.child.domNode);",
"        regionInfo.child= newRegionInfo.child;",
"        regionInfo.child.parent= this;",
"        dojo.place(regionInfo.child.domNode, this.domNode, \"last\");",
"        setSplitter(newRegionInfo.splitter, newRegionInfo.splitterClass, this);",
"        this.startupChild(region);",
"      } else if (!newRegionInfo.child && regionInfo.child) {",
"        // removing a child",
"        this.domNode.removeChild(regionInfo.child.domNode);",
"        removeSplitter();",
"      }",
"    } else if (\"splitter\" in newRegionInfo || \"splitterClass\" in newRegionInfo) {",
"      setSplitter(newRegionInfo.splitter, newRegionInfo.splitterClass, this);",
"    }",
"",
"    // order doesn\'t matter for the rest of the attributes",
"    for (var p in newRegionInfo) {",
"      switch (p) {",
"        case \"delegateSize\":",
"        case \"size\":",
"        case \"min\":",
"        case \"max\":",
"          regionInfo[p]= newRegionInfo[p];",
"        break;",
"      }",
"    }",
"",
"    this.layout();",
"    return oldRegionInfo;",
"  },",
"",
"  addChild: function(",
"    child,",
"    regionInfo",
"  ) {",
"    // adds a child to this DOM subtree; private; clients should use the top, left, bottom, right attributes.",
"    if (!regionInfo) {",
"      regionInfo= bd.getParentProp(child, \"regionInfo\", 0);",
"      if (!regionInfo || regionInfo.region==\"center\") {",
"        this.set(\"center\", child);",
"        return;",
"      }",
"    }",
"    this.set(regionInfo.region, bd.mix({}, regionInfo, {child:child}));",
"  },",
"",
"  removeChild: function(",
"    child",
"  ) {",
"    // removes a child from this DOM subtree; private; clients should use the top, left, bottom, right attributes.",
"    var region= (this.left.child===child ? left : (this.right.child===child ? right : (this.top.child===child ? top : (this.bottom.child===child ? bottom : 0))));",
"    if (region) {",
"      this.setRegion(region, {child:0});",
"    } else if (this.center===child) {",
"      this.center= 0;",
"    }",
"    return child;",
"  },",
"",
"  layout: function() {",
"    // computes and sets the position of each child; private",
"    if (!this.started) {",
"      return;",
"    }",
"    var",
"      workingRect= bd.mix(dojo.contentBox(this.domNode), {t:0, l:0, b:0, r:0}),",
"      availableRect= {h:workingRect.h, w:workingRect.w},",
"      variables= {",
"        top: [\"t\", \"h\"],    // computing top implies top and height",
"        bottom: [\"t\", \"h\"], // etc.",
"        left: [\"l\", \"w\"],   // etc.",
"        right: [\"l\", \"w\"]   // etc.",
"      },",
"      getPercent= function(minMax, available, defaultValue) {",
"        if (bd.isString(minMax)) {",
"          //it must be a percent",
"          minMax= Number(minMax.substring(0, minMax.length-1));",
"          if (isNaN(minMax)) {",
"            return defaultValue;",
"          } else {",
"            return Math.round((minMax * available / 100));",
"          }",
"        }",
"        return minMax;",
"      },",
"      placeChild= function(t, h, region, info, splitterSize, splitterNode) {",
"        var ",
"          child= info.child,",
"          childNode= child && child.domNode,",
"          min= info.min || 0,",
"          max= info.max || \"100%\",",
"          size= info.size,",
"          box= {},",
"          childLayoutCalled= 0;",
"        if (!child || !childNode) {",
"          return;",
"        }",
"        dojo.style(childNode, {position:\"absolute\"});",
"        min= info.dragMin= Math.min(Math.max(getPercent(min, availableRect[h], 0), 0), availableRect[h]);",
"        max= info.dragMax= Math.max(Math.min(getPercent(max, availableRect[h], availableRect[h]), availableRect[h]), min);",
"",
"        if (info.delegateSize) {",
"          // delegate sizing to the child...",
"          // set the child\'s fixed direction, free its variable direction...",
"          dojo.style(childNode, t==\"t\" ? {width:availableRect.w+\"px\", height:\"\"} : {width:\"\", height:availableRect.h+\"px\"});",
"          if (child.layout) {",
"            // if the child has layout, let it layout itself and return its margin box",
"            size= child.layout(t==\"t\" ? null : availableRect.h, t==\"t\" ? availableRect.w : null)[h];",
"            childLayoutCalled= 1;",
"          } else {",
"            // otherwise, layout must be CSS determined; therefore, just take its margin box",
"            size= dojo.marginBox(childNode)[h];",
"          }",
"        } else if (bd.isString(size)) {",
"          size= getPercent(size, availableRect[h], Math.round(availableRect[h] / 4));",
"        } else {",
"          // not a string and not falsy; therefore must be a number (px) or not specified (allocate min)",
"          size= Number(size);",
"          isNaN(size) && (size= min);",
"        }",
"        //at this point, size says how tall(wide) this child would like to be",
"",
"        //chop it to min/max iff required",
"        var chopSize= Math.min(Math.max(min, size), max);",
"        info.size= chopSize;",
"        box= {",
"          t: workingRect.t,",
"          l: workingRect.l,",
"          h:(h==\"h\" ? chopSize : workingRect.h), ",
"          w:(h==\"h\" ? workingRect.w : chopSize)",
"        };",
"        (region==\"bottom\") && (box.t+= (workingRect.h - chopSize));",
"        (region==\"right\") && (box.l+= (workingRect.w - chopSize));",
"        dojo.marginBox(childNode, (info.box= box));",
"        if (/top|left/.test(region)) {",
"          workingRect[t]+= chopSize;",
"          workingRect[h]-= chopSize;",
"        } else {",
"          workingRect[h]-= chopSize;",
"        }",
"        if ((!childLayoutCalled || chopSize!=size) && child.layout) {",
"          child.layout(box.h, box.w);",
"        }",
"        if (splitterSize) {",
"          var splitterBox= info.splitterBox= bd.mix({}, box);",
"          if (/top|left/.test(region)) {",
"            splitterBox[t]+= chopSize;",
"            splitterBox[h]= splitterSize;",
"            workingRect[t]+= splitterSize;",
"            workingRect[h]-= splitterSize;",
"          } else {",
"            (region==\"bottom\") && (splitterBox.t-= splitterSize);",
"            (region==\"right\") && (splitterBox.l-= splitterSize);",
"            splitterBox[h]= splitterSize;",
"            workingRect[h]-= splitterSize;",
"          }",
"          dojo.marginBox(splitterNode, splitterBox);",
"        }",
"      };",
"    bd.forEach(this.design==\"headline\" ? [top, bottom, left, right] : [left, right, top, bottom], function(region) {",
"      var info= this[region];",
"      if (info.child) {",
"        var splitter= info.splitter;",
"        if (info.splitter) {",
"          var ",
"            dimension= {top: \'h\', bottom: \'h\', left: \'w\', right: \'w\'}[region],",
"            splitterSize= info.splitterSize= dojo.marginBox(splitter.domNode)[dimension];",
"          availableRect[dimension]-= splitterSize;",
"        }",
"        placeChild.apply(this, variables[region].concat([region, info, splitterSize, info.splitter.domNode]));",
"      }",
"    }, this);",
"    var center= this.center;",
"    if (center) {",
"      dojo.style(this.center.domNode, {position:\"absolute\"});",
"      dojo.marginBox(center.domNode, {t:workingRect.t, l:workingRect.l, h:workingRect.h, w:workingRect.w});",
"      center.layout && center.layout(workingRect.h, workingRect.w);",
"    }",
"    this.centerBox= workingRect;",
"  }",
"});",
"",
"bd.docGen(\"bd.widget.borderContainer\", {",
"  regionInfo: {",
"    ///type",
"    // Contains configuration values for a top, left, bottom, or right region.",
"",
"    child:",
"      ///",
"      //(widget) The widget to place in the region,",
"      //(falsy) The current widget should be removed from the region.",
"      bd.nodoc,",
"",
"    splitter:",
"      ///",
"      //(boolean) Truthy says the region should be resizable with a splitter bar; falsy indicates the converse.",
"      bd.nodoc,",
"",
"    splitterClass:",
"      ///",
"      //(string) Gives the class name for the splitter bar that should be used for the region. A non-empty value implies the splitter property is true.",
"      bd.nodoc,",
"",
"    delegateSize:",
"      ///",
"      //(boolean) Truthy says the layout routine should query the child for its desired size; falsy says use another means to determine the child.",
"      bd.nodoc,",
"",
"    size:",
"      ///",
"      //(integer) The hard size in pixels desired by the child.",
"      //(percent) A string of the form /d?d%/ (e.g., \"20%\") that gives the percent of the total available height (for the top/bottom regions) or width (for the left/right regions) desired by the child.",
"      bd.nodoc,",
"",
"    mins:",
"      ///",
"      //(integer) The minimum size in pixels desired by the child.",
"      //(percent) A string of the form /d?d%/ (e.g., \"20%\") that gives the minimum percent of the total available height (for the top/bottom regions) or width (for the left/right regions) desired by the child.",
"      bd.nodoc,",
"",
"    size:",
"      ///",
"      //(integer) The maximum size in pixels desired by the child.",
"      //(percent) A string of the form /d?d%/ (e.g., \"20%\") that gives the maximum percent of the total available height (for the top/bottom regions) or width (for the left/right regions) desired by the child.",
"      bd.nodoc",
"  }",
"});",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.widget.splitter":{
type:
Tclass,
sdoc:
["A dragable splitter bar widget for use with bd.widget.borderContainer."],
ldoc:
["The widget consists of an a \"bar\" that\'s presented as a simple, empty, usually colored, div that\'s intended to be absolutely positioned by the owning\nborder container. The widget is derived from bd.focusable, bd.mouseable, and bd.cssStateful with the focused and hover states watched\nby bd.cssStateful. This allows the bar to be stylized when the mouse hovers over it (e.g., by changing it\'s background color).\n\nA non-trivial `onMouseDown` connection point is included that captures the mouse and sends coordinates to a drag function as the mouse\nis dragged. The drag function, provided by the owning parent, calculates a new position for the bar based on the mouse coordinates and\nthen places the bar at this position. Naturally, the capture process gracefully releases the mouse at the completion of the drag\nopertation."],
src:
"bd/widget/borderContainer",
loc: [129,0,206,2],
supers:
["bd.visual","bd.focusable","bd.mouseable"],
module:"bd/widget/borderContainer"}
,"bd.widget.splitter.onMouseDown":{
type:
Tfunction,
sdoc:
["Stops the event, captures the mouse, sends all mouse movements to a drag function provided by the owning container;\nreleases capture on mouseup. "],
imember:1,
ldoc:
["Stops the event, captures the mouse, sends all mouse movements to a drag function provided by the owning container;\nreleases capture on mouseup. Upon capture, adds the DOM class \"bdSplitterActive\"; removes this class upon capture release."],
params:
[["e",[["DOM event object",
["The DOM event object consequent to the mousedown event."]]]]],
loc: [161,2,197,3]}
,"bd.widget.borderContainer":{
type:
Tclass,
sdoc:
["A container that can hold, manage, and layout up to five children widgets--four in fixed or user-sizeable regions along each side of a center rectangle, and a fifth in the center rectangle."],
ldoc:
["The container always consists of a center region. Optionally, additional regions may be added along\neach side (top, bottom, left, right) of the workspace. When both horizontal (top and/or bottom) and vertical\n(left and/or right) children are added, then one or the other must be dominate (span the entire available\narea) and the other must be subordinate (span between the inner borders of the dominate containers children).\nThe attribute `design` controls this aspect of the layout, with the value `\"headline\"` indicating the top/bottom\nregions are dominate and the value `\"sidebar\"` indicating the left/right\" regions are dominate.\n\nChildren are added/removed to/from the top, left, bottom, right, and center regions through the `top`, `left`, `bottom`, `right`,\nand `center` attributes. Since the center region has no sizing information (it gets whatever is left over from the other regions,\nthe `center` attribute simply controls the child (if any) that exists in the center region.\n\nThe remaining region attributes control a composite value that contains the following properties:\n\n* child: the child widget to place in the region.\n* splitter: boolean, says the region is sizeable.\n* splitterClass: (string) gives the class name to use for the region, non-empty implies the property splitter is true.\n* delegateSize: (boolean) says the child will calculate its desired size during layout.\n* size: (integer or percent) says the precise size in pixels or percent the child desires.\n* min: (integer or percent) says the minimize size in pixels or percent the child desires.\n* max: (integer or percent) says the maximum size in pixels or percent the child desires.\n\nSee bd.widget.borderContainer.setRegion for details.\n\nSizes are advisory, but the border container will attempt to fulfill requests so long as there is enough room to show\nall existing containers. This can be guaranteed by ensuring the border container itself is never resized smaller than\nsome reasonable minimum, but this is the responsibility of the parent of the border container.\n\nGiven a set of children, possibly with splitters and a design attribute, the layout method calculates the layout and\nabsolutely positions the children within the container.\n\nIf any border children contain a splitter, then when that splitter is dragged, the associated child and the center region\nare resized consequent to the drag, restricted by any min/max sizes placed on the region."],
src:
"bd/widget/borderContainer",
loc: [208,7,729,2],
supers:
["bd.visual","bd.focusable"],
module:"bd/widget/borderContainer"}
,"bd.widget.borderContainer.center":{
type:
Tvariable,
sdoc:
["Controls the contents of the center region (if any). "],
imember:1,
ldoc:
["Controls the contents of the center region (if any). Unlike the top, left, bottom, and right regions,\nthe center region has no sizing or splitter configuration."],
flags:
[Fattr],
loc: [371,2,395,3],
types:
[["widget",
["The widget to place in the region; null to remove the current widget from the region."]]]}
,"bd.widget.borderContainer.right":{
type:
Tvariable,
sdoc:
["Controls the configuration of the right region (if any). "],
imember:1,
ldoc:
["Controls the configuration of the right region (if any). It is not required that all region\nconfiguration properties be provided to the setter. When a region is set with a subset of the\nconfiguration properties, the current properties or defaults are used to fill in the missing\nproperties. This allows, for example, changing the child while keeping sizing and splitter\nconfiguration constant. See bd.widget.borderContainer.setRegion for details."],
flags:
[Fattr],
loc: [349,2,369,3],
types:
[["bd.widget.borderContainer.regionInfo",
["The properties controlling the region."]]]}
,"bd.widget.borderContainer.bottom":{
type:
Tvariable,
sdoc:
["Controls the configuration of the bottom region (if any). "],
imember:1,
ldoc:
["Controls the configuration of the bottom region (if any). It is not required that all region\nconfiguration properties be provided to the setter. When a region is set with a subset of the\nconfiguration properties, the current properties or defaults are used to fill in the missing\nproperties. This allows, for example, changing the child while keeping sizing and splitter\nconfiguration constant. See bd.widget.borderContainer.setRegion for details."],
flags:
[Fattr],
loc: [327,2,347,3],
types:
[["bd.widget.borderContainer.regionInfo",
["The properties controlling the region."]]]}
,"bd.widget.borderContainer.left":{
type:
Tvariable,
sdoc:
["Controls the configuration of the left region (if any). "],
imember:1,
ldoc:
["Controls the configuration of the left region (if any). It is not required that all region\nconfiguration properties be provided to the setter. When a region is set with a subset of the\nconfiguration properties, the current properties or defaults are used to fill in the missing\nproperties. This allows, for example, changing the child while keeping sizing and splitter\nconfiguration constant. See bd.widget.borderContainer.setRegion for details."],
flags:
[Fattr],
loc: [305,2,325,3],
types:
[["bd.widget.borderContainer.regionInfo",
["The properties controlling the region."]]]}
,"bd.widget.borderContainer.top":{
type:
Tvariable,
sdoc:
["Controls the configuration of the top region (if any). "],
imember:1,
ldoc:
["Controls the configuration of the top region (if any). It is not required that all region\nconfiguration properties be provided to the setter. When a region is set with a subset of the\nconfiguration properties, the current properties or defaults are used to fill in the missing\nproperties. This allows, for example, changing the child while keeping sizing and splitter\nconfiguration constant. See bd.widget.borderContainer.setRegion for details."],
flags:
[Fattr],
loc: [283,2,303,3],
types:
[["bd.widget.borderContainer.regionInfo",
["The properties controlling the region."]]]}
,"bd.widget.borderContainer.splitterClass":{
type:
Tvariable,
sdoc:
["Gives the class name to use for the splitter bars."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [274,2,281,3],
types:
[["string, optional, \"bd:widget.splitter\"",
["The class name to user for the splitter bars."]]]}
,"bd.widget.borderContainer.live":{
type:
Tvariable,
sdoc:
["Controls whether or not child widgets are redrawn when splitter bars are dragged"],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [264,2,272,3],
types:
[["boolean, optional, true",
["Child widgets are redrawn during splitter bar dragging iff true; child widgets\n remain stationary during splitter bar dragging otherwise."]]]}
,"bd.widget.borderContainer.design":{
type:
Tvariable,
sdoc:
["Indicates which border regions are dominate."],
imember:1,
ldoc:
[],
flags:
[Froattr],
loc: [252,2,262,3],
types:
[["\"headline\", default",
["The top and/or bottom regions (if any) span the entire width of the container and the left and/or right\n regions (if any) are fit between the top and/or bottom."]],
["\"sidebar\"",
["The left and/or right regions (if any) span the entire height of the container and the top and/or bottom\n regions (if any) are fit between the left and/or right."]]]}
,"bd.widget.borderContainer.precreateDom":{
type:
Tfunction,
sdoc:
["Initializes a new border container."],
imember:1,
ldoc:
["The descriptor may contain the properties top, left, bottom, and right of type bd.widget.borderContainer.regionInfo that\npreconfigure the regions. However, this method of initialization is not typically used. Instead, a particular child\nusually informs the border container of its layout desires through is the regionInfo property in its parent space. See bd.widget.borderContainer.setRegion."],
loc: [407,2,429,3]}
,"bd.widget.borderContainer.getRegion":{
type:
Tfunction,
sdoc:
["Returns the region information for a the region `region`."],
imember:1,
ldoc:
[],
params:
[["region",[["\"top\", \"left\", \"bottom\", \"right\", \"center\"",
["Identifies the region of interest."]]]]],
loc: [468,2,474,3]}
,"bd.widget.borderContainer.setRegion":{
type:
Tfunction,
sdoc:
["The entry point to add/modify/remove a top, left, bottom, right region."],
imember:1,
ldoc:
["Clients should not access this method directly, but rather should set a region\'s configuration through\nthe `top`, `left`, `bottom`, `right` attributes. That said, all of these setters delegate to this method;\nand, therefore, function identically as follows:\n\nThe region indicated is configured as given by newRegionInfo together with the current configuration for\nthe given region:\n\n* If child is truthy, then any existing child is removed and the given child is placed in the region; if\n  child is falsy but not undefined, then any existing child is removed from the region; if child is undefined\n  then nothing is done with the child.\n* If splitter or splitterClass exists, then the region is made resizeable with a splitter; if splitterClass\n  is undefined, then the border containers `splitterClass` attribute is used to determine the splitter class. If\n  splitter and splitterClass are undefined, the the splitter status is not changed.\n* If delegateSize, size, min, or max are undefined, then the given values are used to control the region\'s layout; otherwise\n  the existing value for the particular attribute is not changed.\n\nAfter the region is reconfigured, the border container\'s layout is recalculated.\n\nSince the center region has no configurable splitters or sizing, it is set directly by the `center` attibute."],
params:
[["region",[["\"top\", \"left\", \"bottom\", \"right\"",
["Identifies the region of interest."]]]],
["newRegionInfo",[["bd.widget.borderContainer.regionInfo",
["Specifies new configuration for the region."]]]]],
loc: [476,2,578,3]}
,"bd.widget.borderContainer.regionInfo":{
type:
Ttype,
sdoc:
["Contains configuration values for a top, left, bottom, or right region."],
ldoc:
[],
props:
["child",{
type:
Tvariable,
loc: [740,6,740,14],
types:
[["widget",
["The widget to place in the region,"]],
["falsy",
["The current widget should be removed from the region."]]]}
,
"splitter",{
type:
Tvariable,
loc: [745,6,745,14],
types:
[["boolean",
["Truthy says the region should be resizable with a splitter bar; falsy indicates the converse."]]]}
,
"splitterClass",{
type:
Tvariable,
loc: [750,6,750,14],
types:
[["string",
["Gives the class name for the splitter bar that should be used for the region. A non-empty value implies the splitter property is true."]]]}
,
"delegateSize",{
type:
Tvariable,
loc: [755,6,755,14],
types:
[["boolean",
["Truthy says the layout routine should query the child for its desired size; falsy says use another means to determine the child."]]]}
,
"size",{
type:
Tvariable,
loc: [761,6,761,14],
types:
[["integer",
["The hard size in pixels desired by the child."]],
["percent",
["A string of the form /d?d%/ (e.g., \"20%\") that gives the percent of the total available height (for the top/bottom regions) or width (for the left/right regions) desired by the child."]]]}
,
"mins",{
type:
Tvariable,
loc: [767,6,767,14],
types:
[["integer",
["The minimum size in pixels desired by the child."]],
["percent",
["A string of the form /d?d%/ (e.g., \"20%\") that gives the minimum percent of the total available height (for the top/bottom regions) or width (for the left/right regions) desired by the child."]]]}
,
"size",{
type:
Tvariable,
loc: [773,6,773,14],
types:
[["integer",
["The maximum size in pixels desired by the child."]],
["percent",
["A string of the form /d?d%/ (e.g., \"20%\") that gives the maximum percent of the total available height (for the top/bottom regions) or width (for the left/right regions) desired by the child."]]]}
],
src:
"bd/widget/borderContainer",
loc: [732,2,774,3],
module:"bd/widget/borderContainer"}
,"modules.bd/widget/borderContainer":{
type:
Tmodule,
sdoc:
["Defines the bd.widget.borderContainer class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/widget/borderContainer",
loc: [0,0,776,2]}
,"resources.bd/widget/checkBox":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/checkBox"],
src:
"bd/widget/checkBox",
modules:
["bd/widget/checkBox"],
code:
["dojo.def(\"bd/widget/checkBox\", [",
"  \"bd\",",
"  \"dojo\",",
"  \"bd/widget/stateButton\",",
"  \"bd/widget/labeled\"",
"], function(bd, dojo) {",
"///",
"// Defines the bd.widget.checkBox class.",
"",
"return bd.declare(",
"  ///",
"  // A container that can hold, manage, and layout a single bd.widget.statebutton inside a bd.widget.labeled widget.",
"  ///",
"  // Packages a bd.widget.statebutton, usually styled as a checkBox, inside a bd.widget.labeled widget. This",
"  // allows the statebutton label, the button itself, and the box controlling the layout to be specified in",
"  // a terse, yet easy-to-understand descriptor. For example, the descriptor",
"  //code",
"  // {",
"  //   className:\"bd:widget.checkBox\",",
"  //   label:\"Are checkBoxes awesome?\",",
"  //   style: {height:\"3em\", width:\"20em\"}",
"  // }",
"  ///",
"  // Specifies a 3x20 em box with the checkBox centered vertically on the left side of the box and the text",
"  // \"Are checkBoxes awesome?\" centered vertically to the right of the checkBox.",
"  // ",
"  // By default, the contained bd.widget.stateButton is described by",
"  //code",
"  // {className:\"bd:widget.stateButton\", cssStatefulBases:{bdCheckBoxBox:0}}",
"  ///",
"  // However, any or all of this description can be overridden by providing a `checkBox` property in the descriptor. See ",
"  // bd.widget.checkBox.loadChildren for details.",
"  // ",
"  // Layout is controlled with the `format` attribute together with the CSS styles. The root DOM node of the subtree of",
"  // the entire widget as well as the root DOM node of the state button subtree contain the CSS class \"bdCheckBox\"",
"  // in the DOM class string attribute. As usual, styles and classes can be added/subtracted on a per-descriptor or per-instance",
"  // basis.",
"",
"  //class name",
"  \"bd:widget.checkBox\",",
"",
"  //superclasses",
"  [bd.widget.labeled],",
"",
"  //members",
"  bd.attr(",
"    ///",
"    // Describes how to layout the checkBox. //The value must be a string of the form xx-xx-y-zz-zz, where",
"    // xx-xx and zz-zz are both bd.css.cornerPosit values. The y value may be \"l\", indicating the left",
"    // side of the content box holds the state button and space occupied by the state button \"chopped off\" ",
"    // and the remaining box is used as the reference box when positioning the label; analogously for \"r\".",
"    // ",
"    // Although some legal configurations may result in ugly checkBoxes, all nice looking checkBoxes are also",
"    // well-described by this notation.",
"",
"    \"format\",",
"",
"    \"cl-cl-l-cl-cl\", //initial value",
"",
"    function(value) { //setter",
"      var oldValue= this.format;",
"      if (oldValue!==value) {",
"        this.format= value;",
"        this.layout();",
"      }",
"    }   ",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Reflects the value state to/from the contained bd.widget.stateButton. //When the contained widget is created,",
"    // if the value is other than bd.noValue, then the value property of the contained widget is set accordingly.",
"    //(any, optional, bd.noValue) This initial value is only used to initialize the contained bd.widget.stateButton;",
"    // thereafter, value is reflected to/from the contained stateButton.",
"",
"    \"value\",",
"",
"    bd.noValue, //bd.noValue says don\'t initialize the contained stateButton (the child descriptor should contain an initial value).",
"",
"    function(value) { //setter",
"      var child= this.children[0];",
"      if (child) {",
"        return child.set(\"value\", value);",
"      } else {",
"        var oldValue= this.value;",
"        this.value= value;",
"        return oldValue;",
"      }",
"    },",
"",
"    function() { //getter",
"      var child= this.children[0];",
"      return (child && child.get(\"value\")) || this.value;",
"    }",
"  ),",
"",
"  {",
"  cssStatefulBases: ",
"    {dijitReset: 0, bdCheckBox:1},",
"",
"  loadChildren: function(",
"    onCreates",
"  ) {",
"    ///",
"    // Loads the contained bd.widget.stateButton. //The descriptor property `checkBox` can be used to override the",
"    // default stateButton descriptor given by:",
"    //code",
"    // {",
"    //   className:\"bd:widget.stateButton\", ",
"    //   cssStatefulBases:{bdCheckBoxBox:0}, ",
"    //   sequence:[[false, \"\", \"unchecked\"], [true, \"\", \"checked\"]]",
"    // }",
"    ///",
"    // The disabled and tabIndex attribute values are passed to the stateButton; if the value attribute hold a value other than bd.noValue, then it is are also passed to the stateButton.",
"    var ",
"      descriptor= bd.mix({className:\"bd:widget.stateButton\", cssStatefulBases:{bdCheckBoxBox:0}, sequence:[[false, \"\", \"unchecked\"], [true, \"\", \"checked\"]]}, this.descriptor.checkBox || {});",
"    descriptor.disabled= this.disabled;",
"    descriptor.tabIndex= this.tabIndex;",
"    if (this.value!==bd.noValue) {",
"      descriptor.value= this.value;",
"      delete this.value;",
"    }",
"    return bd.createWidget(bd.mix({}, this.kwargs, {parent:this, descriptor:descriptor}), 0, onCreates);",
"  },",
"",
"  addChild:function(",
"    child",
"  ) {",
"    this.inherited(arguments);",
"    child.watch(\"value\", function(newValue, oldValue) { this.adviseWatchers(\"value\", oldValue, newValue); }, this);",
"    dojo.setSelectable(this.domNode, false);",
"  },",
"",
"  layout: function() {",
"    ///",
"    // Layout the widget, return the margin box.",
"    // `private",
"    if (!this.started) {",
"      return 0;",
"    }",
"    // format is xx-xx-y-zz-zz; xx-xx is the child posit, zz-zz is the label posit",
"    // if y is l then the left of the whole box is chopped to get the label reference box",
"    // if y is r then the right of the whole box is chopped to get the label reference box",
"    var format= this.format.toLowerCase();",
"    if (!/(t|c|b)(l|c|r)\\-(t|c|b)(l|c|r)\\-(l|r)\\-(t|c|b)(l|c|r)\\-(t|c|b)(l|c|r)/.test(format)) {",
"      return this.inherited(arguments);",
"    }",
"    var",
"      labelBox, labelRefBox,",
"      domNode= this.domNode,",
"      mb= bd.mix(dojo.marginBox(domNode), {t:0, l:0}),",
"      label= this.label.length && this.label,",
"      labelNode= label && this.domNode.firstChild,",
"      labelPosit= format.substring(8),",
"      child= this.children[0],",
"      childNode= child && child.domNode,",
"      childBox= childNode && dojo.marginBox(childNode),",
"      childPosit= format.substring(0, 5);",
"    if (childNode) {",
"      childBox.t= bd.css.cornerCalculators.getTop(childPosit, childBox, mb);",
"      childBox.l= bd.css.cornerCalculators.getLeft(childPosit, childBox, mb);",
"      dojo.marginBox(childNode, childBox);      ",
"    }",
"    if (format.charAt(6)==\"l\") {",
"      labelRefBox= {t:mb.t, h:mb.h, l:childBox.l+childBox.w, w:mb.w-childBox.l-childBox.w};",
"    } else {",
"      labelRefBox= {t:mb.t, h:mb.h, l:0, w:childBox.l};",
"    }",
"    if (label && labelPosit) {",
"      dojo.style(labelNode, {position:\"absolute\", width:labelRefBox.w+\"px\"});",
"      labelBox= dojo.marginBox(labelNode);",
"      labelBox.t= bd.css.cornerCalculators.getTop(labelPosit, labelBox, labelRefBox);",
"      labelBox.l= bd.css.cornerCalculators.getLeft(labelPosit, labelBox, labelRefBox);",
"      dojo.marginBox(labelNode, labelBox);",
"    }",
"    return mb;",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.widget.checkBox":{
type:
Tclass,
sdoc:
["A container that can hold, manage, and layout a single bd.widget.statebutton inside a bd.widget.labeled widget."],
ldoc:
["Packages a bd.widget.statebutton, usually styled as a checkBox, inside a bd.widget.labeled widget. This\nallows the statebutton label, the button itself, and the box controlling the layout to be specified in\na terse, yet easy-to-understand descriptor. For example, the descriptor",
[CODE,"{\n  className:\"bd:widget.checkBox\",\n  label:\"Are checkBoxes awesome?\",\n  style: {height:\"3em\", width:\"20em\"}\n}"],
"Specifies a 3x20 em box with the checkBox centered vertically on the left side of the box and the text\n\"Are checkBoxes awesome?\" centered vertically to the right of the checkBox.\n\nBy default, the contained bd.widget.stateButton is described by",
[CODE,"{className:\"bd:widget.stateButton\", cssStatefulBases:{bdCheckBoxBox:0}}"],
"However, any or all of this description can be overridden by providing a `checkBox` property in the descriptor. See\nbd.widget.checkBox.loadChildren for details.\n\nLayout is controlled with the `format` attribute together with the CSS styles. The root DOM node of the subtree of\nthe entire widget as well as the root DOM node of the state button subtree contain the CSS class \"bdCheckBox\"\nin the DOM class string attribute. As usual, styles and classes can be added/subtracted on a per-descriptor or per-instance\nbasis."],
src:
"bd/widget/checkBox",
loc: [9,7,177,2],
supers:
["bd.widget.labeled"],
module:"bd/widget/checkBox"}
,"bd.widget.checkBox.value":{
type:
Tvariable,
sdoc:
["Reflects the value state to/from the contained bd.widget.stateButton. "],
imember:1,
ldoc:
["Reflects the value state to/from the contained bd.widget.stateButton. When the contained widget is created,\nif the value is other than bd.noValue, then the value property of the contained widget is set accordingly."],
flags:
[Fattr],
loc: [68,2,94,3],
types:
[["any, optional, bd.noValue",
["This initial value is only used to initialize the contained bd.widget.stateButton;\n thereafter, value is reflected to/from the contained stateButton."]]]}
,"bd.widget.checkBox.format":{
type:
Tvariable,
sdoc:
["Describes how to layout the checkBox. "],
imember:1,
ldoc:
["Describes how to layout the checkBox. The value must be a string of the form xx-xx-y-zz-zz, where\nxx-xx and zz-zz are both bd.css.cornerPosit values. The y value may be \"l\", indicating the left\nside of the content box holds the state button and space occupied by the state button \"chopped off\"\nand the remaining box is used as the reference box when positioning the label; analogously for \"r\".\n\nAlthough some legal configurations may result in ugly checkBoxes, all nice looking checkBoxes are also\nwell-described by this notation."],
flags:
[Fattr],
loc: [45,2,66,3]}
,"bd.widget.checkBox.loadChildren":{
type:
Tfunction,
sdoc:
["Loads the contained bd.widget.stateButton. "],
imember:1,
ldoc:
["Loads the contained bd.widget.stateButton. The descriptor property `checkBox` can be used to override the\ndefault stateButton descriptor given by:",
[CODE,"{\n  className:\"bd:widget.stateButton\",\n  cssStatefulBases:{bdCheckBoxBox:0},\n  sequence:[[false, \"\", \"unchecked\"], [true, \"\", \"checked\"]]\n}"],
"The disabled and tabIndex attribute values are passed to the stateButton; if the value attribute hold a value other than bd.noValue, then it is are also passed to the stateButton."],
params:
[["onCreates",[]]],
loc: [100,2,123,3]}
,"bd.widget.checkBox.layout":{
type:
Tfunction,
sdoc:
["Layout the widget, return the margin box."],
imember:1,
ldoc:
[],
flags:
[Fprivate],
loc: [133,2,176,3]}
,"modules.bd/widget/checkBox":{
type:
Tmodule,
sdoc:
["Defines the bd.widget.checkBox class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/widget/checkBox",
loc: [0,0,179,2]}
,"resources.bd/widget/console":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/console"],
src:
"bd/widget/console",
modules:
["bd/widget/console"],
code:
["dojo.def(\"bd/widget/console\", [",
"  \"bd\", \"dijit\",",
"  \"bd/visual\"",
"], function(bd, dijit) {",
"///",
"// Defines the bd.widget.console class.",
"",
"return bd.declare(",
"  ///",
"  // A container that dynamically displays lines of text. //This class can be used to simulate a very simple",
"  // teletype output console.",
"",
"  //class name",
"  \"bd:widget.console\",",
"",
"  //superclasses",
"  [bd.visual], ",
"",
"  //members",
"  {",
"  cssStatefulBases: {dijitReset: 0, bdDijitConsole:0},",
"",
"  cssStatefulWatch: {visible:0},",
"",
"  baseClass: \"bdDijitConsole\",",
"",
"  precreateDom: function() {",
"    this.inherited(arguments);",
"    this.lineOpen= false;",
"    this.indentValue= 0;",
"  },",
"",
"  indent: function(",
"    delta",
"  ) {",
"    ///",
"    // Causes subsequent lines to be indented by the current indent value + `delta` ems. //The indent value starts at",
"    // zero and may be accessed directly through `this.indent`.",
"    this.indentValue+= delta;",
"  },",
"",
"  write: function(",
"    text ///(string) The text to write.",
"  ) {",
"    ///",
"    // Outputs text to the containing node. //newline characters cause new lines to be started; conversely, multiple",
"    // write applications with text that does not include any newline characters will all be written on the same line. All new",
"    // lines are indented by the current indent value as given by `this.indent`.",
"    var ",
"      lastNode= 0,",
"      style= \"padding-left:\" + (this.indentValue) + \"em;\";",
"    if (!text) {",
"      return;",
"    }",
"    text= text.replace(/</g, \"&lt;\");",
"    text= text.split(\"\\n\");",
"    for (var i= 0, end= text.length-1; i<end; i++) {",
"      if (!this.lineOpen) {",
"        lastNode= dojo.create(\'pre\', {innerHTML:text[i], style:style}, this.domNode, \"last\");",
"      } else {",
"        this.lineOpen.innerHTML= this.lineOpen.innerHTML + text[i];",
"        this.lineOpen= false;",
"      }",
"    }",
"    if (text[i]) {",
"      //ended in a line without a new-line",
"      if (!this.lineOpen) {",
"        lastNode= this.lineOpen= dojo.create(\'pre\', {innerHTML:text[i], style:style}, this.domNode, \"last\");",
"      } else {",
"        this.lineOpen.innerHTML= this.lineOpen.innerHTML + text[i];",
"      }",
"    }",
"    lastNode && dijit.scrollIntoView(lastNode);",
"  },",
"",
"  clear: function() {",
"    ///",
"    // Clears all output in the containing node.",
"    this.domNode.innerHTML= \"\";",
"    this.lineOpen= false;",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.widget.console":{
type:
Tclass,
sdoc:
["A container that dynamically displays lines of text. "],
ldoc:
["A container that dynamically displays lines of text. This class can be used to simulate a very simple\nteletype output console."],
src:
"bd/widget/console",
loc: [7,7,81,2],
supers:
["bd.visual"],
module:"bd/widget/console"}
,"bd.widget.console.indent":{
type:
Tfunction,
sdoc:
["Causes subsequent lines to be indented by the current indent value + `delta` ems. "],
imember:1,
ldoc:
["Causes subsequent lines to be indented by the current indent value + `delta` ems. The indent value starts at\nzero and may be accessed directly through `this.indent`."],
params:
[["delta",[]]],
loc: [32,2,39,3]}
,"bd.widget.console.write":{
type:
Tfunction,
sdoc:
["Outputs text to the containing node. "],
imember:1,
ldoc:
["Outputs text to the containing node. newline characters cause new lines to be started; conversely, multiple\nwrite applications with text that does not include any newline characters will all be written on the same line. All new\nlines are indented by the current indent value as given by `this.indent`."],
params:
[["text",[["string",
["The text to write."]]]]],
loc: [41,2,73,3]}
,"bd.widget.console.clear":{
type:
Tfunction,
sdoc:
["Clears all output in the containing node."],
imember:1,
ldoc:
[],
loc: [75,2,80,3]}
,"modules.bd/widget/console":{
type:
Tmodule,
sdoc:
["Defines the bd.widget.console class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/widget/console",
loc: [0,0,83,2]}
,"resources.bd/widget/dialog":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/dialog"],
src:
"bd/widget/dialog",
modules:
["bd/widget/dialog"],
code:
["dojo.def(\"bd/widget/dialog\", [",
"  \"dojo\", \"dijit\", \"bd\",",
"  \"bd/visual\",",
"  \"bd/focusable\",",
"  \"bd/mouseable\",",
"  \"bd/container\",",
"  \"bd/navigator\",",
"  \"bd/command/accelerators\",",
"  \"bd/htmlGen\",",
"  \"bd/async\",",
"  \"bd/mouse\",",
"  \"dojo/dnd/Moveable\",",
"  \"dojo/dnd/TimedMoveable\",",
"  \"i18n!dijit/nls/common\"",
"], function(dojo, dijit, bd) {",
"///",
"// Defines the bd.widget.dialog and associated machinery.",
"",
"var ",
"  dialogCurtain= 0,",
"  getDialogCurtain= function() {",
"    return dialogCurtain || (dialogCurtain= dojo.create(\"div\", {\"class\":\"bdDialogCurtain\"}, dojo.body(), \"first\"));",
"  };",
"",
"bd.dialogStack= ",
"  ///",
"  // The current stack of active dialog box widgets. //The dialog box machinery installs a \"curtain\" (implemented",
"  // as a semitransparent div node absolutely positioned over the entire document (height, width, and z-index) *except*",
"  // for the currently active dialog (if any) which is on top of the curtain. This has the effect of rendering all of the",
"  // document DOM tree disabled except for the currently active dialog. ",
"  // ",
"  // As dialog boxes are nested and dismissed, the z-index is computed as follows:",
"  // ",
"  // * the dialog box at bd.dialogStack[i] has a z-index of ((i+1) * 1000) + 1",
"  // * the curtain has a z-index of one less than the z-index of the active dialog box, or -1000 if no dialog",
"  //   box is active.",
"  // ",
"  // This algorithm gives dialog boxes a wide operating range for their own z-index requirements.",
"  // ",
"  // bd.widget.dialog implements this algorithm. If client code defines other dialog box classes (possibly not",
"  // derived from bd.widget.dialog), they should use this algorithm, bd.dialogStack, and the",
"  // dialog curtain to ensure interoperability with the framework. The function bd.setDialogCurtain is available to",
"  // help with this task.",
"  [];",
"",
"bd.setDialogCurtain= function(",
"    zIndex ///(integer) The CSS z-index value to set.",
"  ) {",
"    ///",
"    // Sets the Backdraft dialog manager\'s curtain\'s z-index; see bd.dialogStack.",
"    dojo.style(getDialogCurtain(), {zIndex:zIndex});",
"  };",
"",
"return bd.declare(",
"  ///",
"  // A sizeable, positionable, draggable modal dialog box. //In addition to coordinating with the dialog manager",
"  // as described in bd.dialogStack, this class pushes the current accelerators when a dialog instance",
"  // becomes the active and restores the accelerators when the dialog is hidden. This effectively disables global command accelerator",
"  // machinery when a dialog is active.",
"",
"  // class name",
"  \"bd:widget.dialog\",",
"",
"  // superclasses",
"  [bd.visual, bd.navigator, bd.mouseable, bd.container],",
"",
"  //members",
"  bd.constAttr(",
"   ///",
"   // Indicates whether or not the dialog can be moved by dragging the title bar",
"   //(boolean, optional, true) The dialog can be dragged if truthy, and conversely.",
"",
"   \"draggable\",",
"",
"   true //default value",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Gives the reference box from which to calculate the dialog\'s size and position. //See bd.widget.dialog.position.",
"    ///",
"    //(object with property domNode) The reference box is given by the margin box of the property domNode.",
"    //(DOM node) The reference box is given by the margin box of the DOM node.",
"    //(bd.css.abbreviatedBox) The reference box is the given rectangle in viewport coordinates (pixels).",
"    //(falsy, default) The reference box is the rectangle given by the entire viewport. ",
"",
"    \"positRef\",",
"",
"    0 // default value",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Gives the position with respect to the `positRef` attribute at which to place the dialog.",
"    ///",
"    //(bd.css.cornerPosit, optional, \"cc-cc\") The position with respect to the `positRef` attribute at which to place the dialog.",
"",
"    \"posit\",",
"",
"    \"cc-cc\" // default value",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Indicates if the dialog box is sizeable. //If the dialog box is sizeable, then hovering the mouse on the frame",
"    // causes the appropriate resizing cursor to appear; pressing the left mouse button and dragging the mouse causes",
"    // mouse capture and the box is resized consequent to the drag.",
"    ///",
"    //(boolean, optional, true) If truthy, the dialog box is sizeable, and conversely.",
"",
"    \"sizeable\",",
"",
"    true // default value",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Controls the size of the dialog box content frame. //The content frame is defined as the entire dialog except the title bar ",
"    // and frame; this part of the dialog is contained in the `containerNode` property.",
"    // ",
"    //(CSS style object) A CSS style object suitable for dojo.style.",
"    //(falsy, default) The size of the container node is not initialized/set by the class machinery.",
"",
"    \"frameSize\",",
"",
"    0, // default value",
"",
"    function(value) { //setter",
"      var oldValue= this.frameSize;",
"      if (oldValue!=value) {",
"        this.containerNode && dojo.style(this.containerNode, value);",
"        this.started && this.position();",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Controls the minimum size of the dialog box content frame (see bd.widget.dialog.frameSize).",
"    ///",
"    //(bd.css.abbriviatedBox with h and w metrics, optional, {h:25, w:50}) The minimum dimensions in pixels for the content frame.",
"",
"    \"frameSizeMin\",",
"",
"    {h:25, w:50}, //default value",
"",
"    function(value) { //setter",
"      if (isNaN(value.h) || isNan(value.w)) {",
"        return bd.failed;",
"      }",
"      var oldValue= this.frameSizeMin;",
"      if (oldValue!=value) {",
"        if (value.h<oldValue.h || value.h<oldValue.h && this.started) {",
"          this.position();",
"        }",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Controls automatic destruction of the dialog box. //When all side effects of a dialog are completed",
"    // in the onOK/onCancel connection points, `this.persist` can be set to false, thereby eliminating any need for ",
"    // client code to manage the dialog after showing it (i.e., client code doesn\'t even need to keep a reference to",
"    // the dialog--it will be cleaned up and fully destroyed automatically). On the other hand, if a particular single",
"    // instance is intended to be shown/hidden frequently, `this.persist` can be set to true and client code",
"    // can keep a reference to an already-constructed dialog, simplifying and speeding display.",
"    // ",
"    //(boolean, optional, false) Automatically destroy the dialog box upon during `this.endDialog` processing if false, and conversely.",
"",
"    \"persist\",",
"",
"    false // default value",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Causes navigation to cycle within the dialog. See bd.navigator.cycleNavigation.",
"    ///",
"    //(boolean, optional, true) Truthy if navigation should cycle within the children controlled by this navigator, and conversely.",
"",
"    \"cycleNavigation\",",
"",
"    true // default value",
"  ),",
"",
"  {",
"  template: bd.compileHtmlTemplate(",
"    {div: [{dclass:\"bdDialog\", id:\"{id}\", widgetId:\"{id}\"}, \"domNode\", [",
"      {div: [{dclass:\"bdDialogTitleBar\"}, \"titleBarNode\", [",
"        {span: [{dclass:\"bdDialogTitle\", id:\"{id}_title\"}, [\"{title}\"]]},",
"        {div: [{dclass:\"bdDialogClose\", title:\"{buttonCancel}\"}, \"closeButtonNode\", {click:\"onCancel\", mouseenter:\"onCloseEnter\", mouseleave:\"onCloseLeave\"}, [",
"          {span: [{dclass:\"bdDialogCloseIcon\"}]},",
"          {span: [{dclass:\"bdDialogCloseText\"}, \"closeText\", [\"\\u2715\"]]}]]}]]},",
"      {div: [{dclass:\"bdDialogContentFrame {class}\"}, \"containerNode\"]}]]}),",
"",
"  titleBarNode:",
"    ///",
"    // Holds a reference to the DOM node that contains the title bar.",
"    0,",
"",
"  containerNode:",
"    ///",
"    // Holds a reference to the DOM node that contains the content frame",
"    0,",
"",
"  buttonCloseNode:",
"    ///",
"    // Holds a reference to the DOM node that contains the close button on the title bar.",
"    0,",
"",
"  createDom: function() {",
"      //TODO: improve template to pass dir and lang",
"      //TODO: improve template to utilize i18n!dijit/nls/common",
"      this.l10n= dojo.module(\"i18n!dijit/nls/common\");",
"      this.domNode= bd.generateHtmlTemplate(this.template, this, {id:this.id, \"class\":this[\"class\"], title:this.title, buttonCancel:\"cancel\"});",
"      this.dir!==undefined && dojo.attr(this.domNode, \"dir\", this.dir);",
"      this.lang!==undefined && dojo.attr(this.domNode, \"lang\", this.lang);",
"      this.style!==undefined && dojo.style(this.domNode, this.style);",
"      this.frameSize && dojo.style(this.containerNode, this.frameSize);",
"  },",
"",
"  postcreateDom: function() {",
"    this.inherited(arguments);",
"    if (this.titleBarNode && this.draggable) {",
"      this._moveable= (dojo.isIE == 6) ?",
"        new dojo.dnd.TimedMoveable(this.domNode, { handle: this.titleBarNode }) :   // prevent overload, see #5285",
"        new dojo.dnd.Moveable(this.domNode, { handle: this.titleBarNode, timeout: 0 });",
"      dojo.subscribe(\"/dnd/move/stop\", this, \"endDrag\");",
"    } else {",
"      dojo.addClass(node,\"dijitDialogFixed\");",
"    }",
"    bd.subscribe(\"bd/viewportResize\", \"position\", this);",
"    bd.subscribe(\"bd/viewportScroll\", \"position\", this);",
"  },",
"",
"  endDrag: function(e) {",
"    if (e && e.node && e.node===this.domNode) {",
"      var",
"        vp= dijit.getViewport(),",
"        p= e._leftTop || dojo.coords(e.node, true);",
"      this._relativePosition= {",
"        t: p.t - vp.t,",
"        l: p.l - vp.l",
"      };",
"    }",
"  },",
"",
"//TODO show and focus and analgous",
"//TODO make sure the CSS for dialog gives overflow auto, posit relative",
"//TODO save _savedFocus",
"",
"  destroy: function() {",
"    if (this._moveable) {",
"      this._moveable.destroy();",
"    }",
"    dojo.forEach(this._modalconnects, dojo.disconnect);",
"    this._savedFocus && this._savedFocus.focus();",
"    this.inherited(arguments);",
"  },",
"",
"  position: function() {",
"    ///",
"    // Sets the size and position of the dialog box each time show is called.",
"    ///",
"    // The desired dialog box size is given by the size of the containerNode + the titleNode\'s height.",
"    // The size of the containerNode may be set by:",
"    // ",
"    //  * Using CSS styling on the various nodes.",
"    //  * The `frameSize` attribute; see bd.widget.dialog.frameSize.",
"    // ",
"    // Explicitly setting the frameSize is not guaranteed to work since this routine may adjust the",
"    // size.",
"    // ",
"    // The desired dialog box position is calculated relative as given by the attribute `posit` to a reference",
"    // rectangle as given by property `positRef`. See bd.widget.dialog.posit and bd.widget.dialog.positRef.",
"    // ",
"    // The positioning algorithm attemps to size and place the dialog as requested. However, if the viewport causes",
"    // the dialog to be clipped, then it will be moved up/down and/or left/right in an attempt to put",
"    // the dialog is a position where it all fits. If the dialog still overflows, then the dialog will be",
"    // resized down to the minimim sizes given by the attribute `frameSizeMin`. Finally, if the dialog is still too",
"    // big for the viewport (really, the viewport is still too small), then the dialog\'s CSS styling dictates",
"    // how to handle the overflow.",
"    // ",
"    // If the viewport is shrunk while the dialog is showing, a check is made to ensure at least the minimum size",
"    // of the dialog is showing; if not, then it is repositioned; if so, the dialog size and position is left unchanged.",
"    // This should prevent a viewport shrinking from hiding an showing dialog; thereby seeming to lock the program.",
"",
"    var viewport, positRef, refRect, mb, t, l, posit, contentFrameMb, delta;",
"",
"    // get the viewport rectangle",
"    viewport= dojo.window.getBox(),",
"    viewport.t= 0;",
"    viewport.l= 0;",
"",
"    // get the reference rectangle",
"    positRef= this.positRef,",
"    refRect= (!positRef ? viewport : (positRef.domNode ? dojo.position(positRef.domNode) : (bd.isDomNode(positRef) ? dojo.position(positRef) : positRef)));",
"    refRect= {",
"      t: isNaN(refRect.y) ? 0 : Number(refRect.y),",
"      l: isNaN(refRect.x) ? 0 : Number(refRect.x),",
"      h: isNaN(refRect.h) ? viewport.h : Number(refRect.h),",
"      w: isNaN(refRect.w) ? viewport.w : Number(refRect.w)",
"    };",
"    this.setFrameSize && this.setFrameSize();",
"    mb= dojo.marginBox(this.domNode);",
"",
"    // place the dialog as requested",
"    posit= this.posit || \"cc-cc\";",
"    t= bd.css.cornerCalculators.getTop(posit, mb, refRect);",
"    l= bd.css.cornerCalculators.getLeft(posit, mb, refRect);    ",
"    // if the dialog overflows, try to move it so it fits...",
"    if (t + mb.h > viewport.h) {",
"      // dialog goes out the bottom; therefore, align with bottom...",
"      t= viewport.h - mb.h;",
"    }",
"    if (l + mb.w > viewport.w) {",
"      // dialog goes out the right; therefore, align with right...",
"      l= viewport.w - mb.w;",
"    }",
"    // if it is positioned above and/or left, correct to top and/or left",
"    t= t<0 ? 0 : t;",
"    l= l<0 ? 0 : l;",
"    (t!=mb.t || l!=mb.l) && dojo.marginBox(this.domNode, {t:t, l:l});",
"",
"    // finally, if it still doesn\'t fit, make it fit iff sizeable",
"    // note: at this point t and/or l will be at 0 if it overflows h and/or w",
"    if (this.sizeable) {",
"      if (mb.h > viewport.h) {",
"        contentFrameMb= dojo.marginBox(this.containerNode);",
"        contentFrameMb.h-= (this.frameSizeMin ? Math.min(mb.h -viewport.h, contentFrameMb.h - this.frameSizeMin.h) : (mb.h -viewport.h));",
"      }",
"      if (mb.w > viewport.w) {",
"        contentFrameMb= contentFramewMb || dojo.marginBox(this.containerNode);",
"        contentFrameMb.w-= (this.frameSizeMin ? Math.min(mb.w -viewport.w, contentFrameMb.w - this.frameSizeMin.w) : (mb.w -viewport.w));",
"      }",
"      contentFrameMb && dojo.marginBox(this.containerNode, contentFrameMb);",
"    }",
"  },",
"",
"  startup: function() {",
"    if (this.started) {",
"      return;",
"    }",
"    bd.dialogStack.push(this);",
"    var ",
"      depth= this.depth= bd.dialogStack.length,",
"      zIndex= 1000 + (depth * 100);",
"    bd.setDialogCurtain(zIndex);",
"    dojo.style(this.domNode, {zIndex: zIndex+1});",
"    dojo.body().appendChild(this.domNode);",
"    this.position();",
"    this.inherited(arguments, [true]);",
"    bd.command.pushAccels([\"next\", \"previous\", \"dialogOk\", \"dialogCancel\"]);",
"    bd.command.pushContext();",
"    bd.command.connect(\"dialogOk\", \"onAccelOk\", this);",
"    bd.command.connect(\"dialogCancel\", \"onAccelCancel\", this);",
"    bd.command.connect(\"next\", bd.navigator.commandHandler);",
"    bd.command.connect(\"previous\", bd.navigator.commandHandler);",
"    this.refocus= dijit._activeStack.slice(0);",
"    this.focus();",
"  },",
"",
"  stop: function() {",
"    if (!this.started) {",
"      return;",
"    }",
"    bd.dialogStack.pop();",
"    var depth= bd.dialogStack.length;",
"    bd.setDialogCurtain(depth==0 ? -1000 : (1000 + ((depth) * 100)));",
"    this.inherited(arguments);",
"    bd.command.popAccels();",
"    bd.command.popContext();",
"    dojo.body().removeChild(this.domNode);",
"    var stack= this.refocus, foundFocusableWidget= false, widget;",
"    while (stack.length) {",
"      widget= bd.object.get(stack.pop());",
"      if (widget && widget.get(\"focusable\")) {",
"        widget.focus();",
"        foundFocusableWidget= true;",
"      }",
"    }",
"    !foundFocusableWidget && dijit._setStack([]);",
"  },",
"",
"  show: function() {",
"    ///",
"    // Show the dialog.",
"    this.startup();",
"  },",
"",
"  hide: function() {",
"    ///",
"    // Hide the dialog.",
"    this.stop();",
"  },",
"",
"  onCloseEnter: function() {",
"    dojo.addClass(this.closeButtonNode, \"bdDialogCloseButtonHover\");",
"  },",
"",
"  onCloseLeave: function() {",
"    dojo.removeClass(this.closeButtonNode, \"bdDialogCloseButtonHover\");",
"  },",
"",
"  setCursor: function(",
"    e //(DOM event object) The object that caused the event.",
"  ) {",
"    var ",
"      posit= dojo.position(this.domNode),",
"      y= e.clientY,",
"      x= e.clientX,",
"      dragZone=",
"        (y < posit.y+15 ? \"T\" : (y > posit.y+posit.h-15 ? \"B\" : \"C\")) +",
"        (x < posit.x+15 ? \"L\" : (x > posit.x+posit.w-15 ? \"R\" : \"C\")),",
"      cursor= \"bdDialogSizeCursor\" + dragZone;",
"    if (this.cursor!==cursor) {",
"      this.cursor && dojo.toggleClass(this.domNode, this.cursor);",
"      this.cursor= cursor;",
"      dojo.toggleClass(this.domNode, this.cursor);",
"    }",
"    return dragZone;",
"  },",
"",
"  onMouseOver: function(",
"    e //(DOM event object) The object that caused the event.",
"  ) {",
"    if (this.sizeable && e.target===this.domNode) {",
"      this.setCursor(e);",
"    }",
"  },",
"",
"  onMouseMove: function(",
"    e //(DOM event object) The object that caused the event.",
"  ) {",
"    if (this.sizeable && e.target===this.domNode) {",
"      this.setCursor(e);",
"    }",
"  },",
"",
"  onMouseOut: function(",
"    e //(DOM event object) The object that caused the event.",
"  ) {",
"    if (this.sizeable && e.target===this.domNode) {",
"      if (this.cursor) {",
"        dojo.toggleClass(this.domNode, this.cursor);",
"        delete this.cursor;",
"      }",
"    }",
"  },",
"",
"  onMouseDown: function(",
"    e //(DOM event object) The object that caused the event.",
"  ){",
"    if (this.sizeable && e.target===this.domNode) {",
"      dojo.stopEvent(e);",
"      var",
"        which= this.setCursor(e),",
"        moveTop= /TL|TC|TR/.test(which),",
"        moveBottom= /BL|BC|BR/.test(which),",
"        moveLeft= /TL|CL|BL/.test(which),",
"        moveRight= /TR|CR|BR/.test(which),",
"        start= e,",
"        mb= dojo.marginBox(this.domNode),",
"        frameMb= dojo.marginBox(this.containerNode),",
"        viewport= dojo.window.getBox(),",
"        me= this,",
"        doMove= function(e) {",
"          var",
"            deltaX= e.clientX - start.clientX,",
"            deltaY= e.clientY - start.clientY,",
"            deltaMb= {t:mb.t, l:mb.l},",
"            deltaFrameMb= {h:frameMb.h, w:frameMb.w};",
"          if (moveTop) {",
"            deltaY= Math.min(Math.max(-mb.t + viewport.t, deltaY), mb.h - me.frameSizeMin.h);",
"            deltaMb.t+= deltaY;",
"            deltaFrameMb.h-= deltaY;          ",
"          } else if (moveBottom) {",
"            deltaY= Math.min(Math.max(-mb.h + me.frameSizeMin.h, deltaY), viewport.h + viewport.t - mb.t - mb.h);",
"            deltaFrameMb.h+= deltaY;",
"          }",
"          if (moveLeft) {",
"            deltaX= Math.min(Math.max(-mb.l + viewport.l, deltaX), mb.w - me.frameSizeMin.w);",
"            deltaMb.l+= deltaX;",
"            deltaFrameMb.w-= deltaX;          ",
"          } else if (moveRight) {",
"            deltaX= Math.min(Math.max(-mb.w + me.frameSizeMin.w, deltaX), viewport.w + viewport.l - mb.l - mb.w);",
"            deltaFrameMb.w+= deltaX;",
"          }",
"          dojo.marginBox(me.domNode, deltaMb);",
"          dojo.marginBox(me.containerNode, deltaFrameMb);",
"        };",
"      bd.mouse.capture(this, {",
"        mousemove: function(e){",
"          doMove(e);",
"        },",
"        mouseup: function(e){",
"          bd.mouse.release();",
"          doMove(e);",
"          me.setCursor(e);",
"          me.layout();",
"        }",
"      });",
"   }",
"  },",
"",
"  endDialog: function(",
"    e ///(DOM event object) The object that caused the event.",
"  ) {",
"    ///",
"    // Stops the event (if any), hides the dialog, and optionally destroys the dialog instance.",
"    e && dojo.stopEvent(e);",
"    this.hide();",
"    !this.persist && this.destroy();",
"  },",
"",
"  onCancel: function(",
"    e ///(DOM event object) The object that caused the event.",
"  ) {",
"    ///",
"    // The close button was pressed (or equivalent). //Default processing ends",
"    // the dialog via the `endDialog` method. This method may be called by client code ",
"    // to explicitly cancel the dialog.",
"    this.endDialog(e);",
"  },",
"",
"  onOk: function(",
"    e ///(DOM event object) The object that caused the event.",
"  ) {",
"    ///",
"    // Nontrivial connection point to indicate the dialog was \"accepted\". //Default processing ends",
"    // the dialog via the `endDialog` method. This method is usually called by client code consequent to",
"    // some user action (typically, pressing an OK button contained within the dialog).",
"    this.endDialog(e);",
"  },",
"",
"  onAccelCancel: function(",
"    e //(bd.command.eventObject) The object that caused the event.",
"  ) {",
"    this.onCancel(e.eventObject);",
"  },",
"",
"  onAccelOk: function(",
"    e //(bd.command.eventObject) The object that caused the event.",
"  ) {",
"    this.onOk(e.eventObject);",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.dialogStack":{
type:
Tvariable,
sdoc:
["The current stack of active dialog box widgets. "],
ldoc:
["The current stack of active dialog box widgets. The dialog box machinery installs a \"curtain\" (implemented\nas a semitransparent div node absolutely positioned over the entire document (height, width, and z-index) *except*\nfor the currently active dialog (if any) which is on top of the curtain. This has the effect of rendering all of the\ndocument DOM tree disabled except for the currently active dialog.\n\nAs dialog boxes are nested and dismissed, the z-index is computed as follows:\n\n* the dialog box at bd.dialogStack[i] has a z-index of ((i+1) * 1000) + 1\n* the curtain has a z-index of one less than the z-index of the active dialog box, or -1000 if no dialog\n  box is active.\n\nThis algorithm gives dialog boxes a wide operating range for their own z-index requirements.\n\nbd.widget.dialog implements this algorithm. If client code defines other dialog box classes (possibly not\nderived from bd.widget.dialog), they should use this algorithm, bd.dialogStack, and the\ndialog curtain to ensure interoperability with the framework. The function bd.setDialogCurtain is available to\nhelp with this task."],
src:
"bd/widget/dialog",
loc: [24,0,43,4],
module:"bd/widget/dialog"}
,"bd.setDialogCurtain":{
type:
Tfunction,
sdoc:
["Sets the Backdraft dialog manager\'s curtain\'s z-index; see bd.dialogStack."],
ldoc:
[],
params:
[["zIndex",[["integer",
["The CSS z-index value to set."]]]]],
src:
"bd/widget/dialog",
loc: [45,0,51,3],
module:"bd/widget/dialog"}
,"bd.widget.dialog":{
type:
Tclass,
sdoc:
["A sizeable, positionable, draggable modal dialog box. "],
ldoc:
["A sizeable, positionable, draggable modal dialog box. In addition to coordinating with the dialog manager\nas described in bd.dialogStack, this class pushes the current accelerators when a dialog instance\nbecomes the active and restores the accelerators when the dialog is hidden. This effectively disables global command accelerator\nmachinery when a dialog is active."],
src:
"bd/widget/dialog",
loc: [53,7,549,2],
supers:
["bd.visual","bd.navigator","bd.mouseable","bd.container"],
module:"bd/widget/dialog"}
,"bd.widget.dialog.cycleNavigation":{
type:
Tvariable,
sdoc:
["Causes navigation to cycle within the dialog. See bd.navigator.cycleNavigation."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [177,2,186,3],
types:
[["boolean, optional, true",
["Truthy if navigation should cycle within the children controlled by this navigator, and conversely."]]]}
,"bd.widget.dialog.persist":{
type:
Tvariable,
sdoc:
["Controls automatic destruction of the dialog box. "],
imember:1,
ldoc:
["Controls automatic destruction of the dialog box. When all side effects of a dialog are completed\nin the onOK/onCancel connection points, `this.persist` can be set to false, thereby eliminating any need for\nclient code to manage the dialog after showing it (i.e., client code doesn\'t even need to keep a reference to\nthe dialog--it will be cleaned up and fully destroyed automatically). On the other hand, if a particular single\ninstance is intended to be shown/hidden frequently, `this.persist` can be set to true and client code\ncan keep a reference to an already-constructed dialog, simplifying and speeding display."],
flags:
[Fattr],
loc: [161,2,175,3],
types:
[["boolean, optional, false",
["Automatically destroy the dialog box upon during `this.endDialog` processing if false, and conversely."]]]}
,"bd.widget.dialog.frameSizeMin":{
type:
Tvariable,
sdoc:
["Controls the minimum size of the dialog box content frame (see bd.widget.dialog.frameSize)."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [137,2,159,3],
types:
[["bd.css.abbriviatedBox with h and w metrics, optional, {h:25, w:50}",
["The minimum dimensions in pixels for the content frame."]]]}
,"bd.widget.dialog.frameSize":{
type:
Tvariable,
sdoc:
["Controls the size of the dialog box content frame. "],
imember:1,
ldoc:
["Controls the size of the dialog box content frame. The content frame is defined as the entire dialog except the title bar\nand frame; this part of the dialog is contained in the `containerNode` property."],
flags:
[Fattr],
loc: [115,2,135,3],
types:
[["CSS style object",
["A CSS style object suitable for dojo.style."]],
["falsy, default",
["The size of the container node is not initialized/set by the class machinery."]]]}
,"bd.widget.dialog.sizeable":{
type:
Tvariable,
sdoc:
["Indicates if the dialog box is sizeable. "],
imember:1,
ldoc:
["Indicates if the dialog box is sizeable. If the dialog box is sizeable, then hovering the mouse on the frame\ncauses the appropriate resizing cursor to appear; pressing the left mouse button and dragging the mouse causes\nmouse capture and the box is resized consequent to the drag."],
flags:
[Fattr],
loc: [102,2,113,3],
types:
[["boolean, optional, true",
["If truthy, the dialog box is sizeable, and conversely."]]]}
,"bd.widget.dialog.posit":{
type:
Tvariable,
sdoc:
["Gives the position with respect to the `positRef` attribute at which to place the dialog."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [91,2,100,3],
types:
[["bd.css.cornerPosit, optional, \"cc-cc\"",
["The position with respect to the `positRef` attribute at which to place the dialog."]]]}
,"bd.widget.dialog.positRef":{
type:
Tvariable,
sdoc:
["Gives the reference box from which to calculate the dialog\'s size and position. "],
imember:1,
ldoc:
["Gives the reference box from which to calculate the dialog\'s size and position. See bd.widget.dialog.position."],
flags:
[Fattr],
loc: [77,2,89,3],
types:
[["object with property domNode",
["The reference box is given by the margin box of the property domNode."]],
["DOM node",
["The reference box is given by the margin box of the DOM node."]],
["bd.css.abbreviatedBox",
["The reference box is the given rectangle in viewport coordinates (pixels)."]],
["falsy, default",
["The reference box is the rectangle given by the entire viewport."]]]}
,"bd.widget.dialog.draggable":{
type:
Tvariable,
sdoc:
["Indicates whether or not the dialog can be moved by dragging the title bar"],
imember:1,
ldoc:
[],
flags:
[Froattr],
loc: [67,2,75,3],
types:
[["boolean, optional, true",
["The dialog can be dragged if truthy, and conversely."]]]}
,"bd.widget.dialog.titleBarNode":{
type:
Tvariable,
sdoc:
["Holds a reference to the DOM node that contains the title bar."],
imember:1,
ldoc:
[],
loc: [198,2,201,5]}
,"bd.widget.dialog.containerNode":{
type:
Tvariable,
sdoc:
["Holds a reference to the DOM node that contains the content frame"],
imember:1,
ldoc:
[],
loc: [203,2,206,5]}
,"bd.widget.dialog.buttonCloseNode":{
type:
Tvariable,
sdoc:
["Holds a reference to the DOM node that contains the close button on the title bar."],
imember:1,
ldoc:
[],
loc: [208,2,211,5]}
,"bd.widget.dialog.position":{
type:
Tfunction,
sdoc:
["Sets the size and position of the dialog box each time show is called."],
imember:1,
ldoc:
["The desired dialog box size is given by the size of the containerNode + the titleNode\'s height.\nThe size of the containerNode may be set by:\n\n * Using CSS styling on the various nodes.\n * The `frameSize` attribute; see bd.widget.dialog.frameSize.\n\nExplicitly setting the frameSize is not guaranteed to work since this routine may adjust the\nsize.\n\nThe desired dialog box position is calculated relative as given by the attribute `posit` to a reference\nrectangle as given by property `positRef`. See bd.widget.dialog.posit and bd.widget.dialog.positRef.\n\nThe positioning algorithm attemps to size and place the dialog as requested. However, if the viewport causes\nthe dialog to be clipped, then it will be moved up/down and/or left/right in an attempt to put\nthe dialog is a position where it all fits. If the dialog still overflows, then the dialog will be\nresized down to the minimim sizes given by the attribute `frameSizeMin`. Finally, if the dialog is still too\nbig for the viewport (really, the viewport is still too small), then the dialog\'s CSS styling dictates\nhow to handle the overflow.\n\nIf the viewport is shrunk while the dialog is showing, a check is made to ensure at least the minimum size\nof the dialog is showing; if not, then it is repositioned; if so, the dialog size and position is left unchanged.\nThis should prevent a viewport shrinking from hiding an showing dialog; thereby seeming to lock the program."],
loc: [263,2,340,3]}
,"bd.widget.dialog.show":{
type:
Tfunction,
sdoc:
["Show the dialog."],
imember:1,
ldoc:
[],
loc: [387,2,391,3]}
,"bd.widget.dialog.hide":{
type:
Tfunction,
sdoc:
["Hide the dialog."],
imember:1,
ldoc:
[],
loc: [393,2,397,3]}
,"bd.widget.dialog.endDialog":{
type:
Tfunction,
sdoc:
["Stops the event (if any), hides the dialog, and optionally destroys the dialog instance."],
imember:1,
ldoc:
[],
params:
[["e",[["DOM event object",
["The object that caused the event."]]]]],
loc: [508,2,516,3]}
,"bd.widget.dialog.onCancel":{
type:
Tfunction,
sdoc:
["The close button was pressed (or equivalent). "],
imember:1,
ldoc:
["The close button was pressed (or equivalent). Default processing ends\nthe dialog via the `endDialog` method. This method may be called by client code\nto explicitly cancel the dialog."],
params:
[["e",[["DOM event object",
["The object that caused the event."]]]]],
loc: [518,2,526,3]}
,"bd.widget.dialog.onOk":{
type:
Tfunction,
sdoc:
["Nontrivial connection point to indicate the dialog was \"accepted\". "],
imember:1,
ldoc:
["Nontrivial connection point to indicate the dialog was \"accepted\". Default processing ends\nthe dialog via the `endDialog` method. This method is usually called by client code consequent to\nsome user action (typically, pressing an OK button contained within the dialog)."],
params:
[["e",[["DOM event object",
["The object that caused the event."]]]]],
loc: [528,2,536,3]}
,"modules.bd/widget/dialog":{
type:
Tmodule,
sdoc:
["Defines the bd.widget.dialog and associated machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["dojo",[]],
["dijit",[]],
["bd",[]]],
src:
"bd/widget/dialog",
loc: [0,0,551,2]}
,"resources.bd/widget/iframe":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/iframe"],
src:
"bd/widget/iframe",
modules:
["bd/widget/iframe"],
code:
["dojo.def(\"bd/widget/iframe\", [",
"  \"bd\",",
"  \"dojo\",",
"  \"bd/visual\",",
"  \"bd/focusable\",",
"  \"bd/mouseable\"",
"], function(bd, dojo) {",
"///",
"// Defines the bd.widget.iframe class.",
"",
"return bd.declare(",
"  ///",
"  // A container that can hold, manage, and layout a single iframe. //Creates a DOM tree that consists of a single div element that contains a single iframe element.",
"  // Ths iframe element is created on demand and the `src` attribute of the iframe may be set/modified after the widget has",
"  // been created. The widget controls the height and width of the contained iframe so that it always fits within the",
"  // content area of the parent div. As usual CSS styling can be used to control the visual appearance of the widget.",
"",
"  //class name",
"  \"bd:widget.iframe\", ",
"",
"  //superclasses",
"  [bd.visual, bd.focusable, bd.mouseable],",
"",
"  //members",
"  bd.attr(",
"    ///",
"    // The DOM `src` attribute for the iframe. //Destroys any existing iframe and creates a new iframe with the `src`",
"    // attribute.",
"    ///",
"    //(string, optional, \"\") Gives the DOM `src` attribute for the iframe; if falsy, then the iframe is not created.",
"",
"    \"src\", ",
"    0, //initial value",
"   ",
"    function(value) { //setter",
"      var oldValue= this.src;",
"      if (oldValue!==value) {",
"        this.src= value;",
"        if (bd.isString(value) && value.length) {",
"          this.createIframe();",
"        }",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  {",
"  initAttrs:",
"    {dir:1, lang:1, \"class\":1, style:1, title:1, tabIndex:1},",
"",
"  cssStatefulBases: ",
"    {dijitReset: 0, bdIFrame:1},",
"",
"  cssStatefulWatch: ",
"    {visible:0, disabled:0},",
"",
"  createIframe: function() {",
"    //destroys the old iframe (if any), creates a new empty iframe.",
"    this.domNode.innerHTML= \"\";",
"    var box= dojo.contentBox(this.domNode);",
"    this.iframeNode= dojo.create(\"iframe\", {style:\"margin:0; border:0; padding:0; overflow:auto;\", src:this.src, width:box.w+\"px\", height:box.h+\"px\"}, this.domNode);",
"  },",
"",
"  layout: function() {",
"    ///",
"    // Sets the iframe (if any) height and width to the size of the content box of this widget.",
"    var box= dojo.contentBox(this.domNode);",
"    this.iframeNode && dojo.attr(this.iframeNode, {width:box.w+\"px\", height:box.h+\"px\"});",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.widget.iframe":{
type:
Tclass,
sdoc:
["A container that can hold, manage, and layout a single iframe. "],
ldoc:
["A container that can hold, manage, and layout a single iframe. Creates a DOM tree that consists of a single div element that contains a single iframe element.\nThs iframe element is created on demand and the `src` attribute of the iframe may be set/modified after the widget has\nbeen created. The widget controls the height and width of the contained iframe so that it always fits within the\ncontent area of the parent div. As usual CSS styling can be used to control the visual appearance of the widget."],
src:
"bd/widget/iframe",
loc: [10,7,69,2],
supers:
["bd.visual","bd.focusable","bd.mouseable"],
module:"bd/widget/iframe"}
,"bd.widget.iframe.src":{
type:
Tvariable,
sdoc:
["The DOM `src` attribute for the iframe. "],
imember:1,
ldoc:
["The DOM `src` attribute for the iframe. Destroys any existing iframe and creates a new iframe with the `src`\nattribute."],
flags:
[Fattr],
loc: [24,2,44,3],
types:
[["string, optional, \"\"",
["Gives the DOM `src` attribute for the iframe; if falsy, then the iframe is not created."]]]}
,"bd.widget.iframe.layout":{
type:
Tfunction,
sdoc:
["Sets the iframe (if any) height and width to the size of the content box of this widget."],
imember:1,
ldoc:
[],
loc: [63,2,68,3]}
,"modules.bd/widget/iframe":{
type:
Tmodule,
sdoc:
["Defines the bd.widget.iframe class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/widget/iframe",
loc: [0,0,71,2]}
,"resources.bd/widget/labeled":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/labeled"],
src:
"bd/widget/labeled",
modules:
["bd/widget/labeled"],
code:
["dojo.def(\"bd/widget/labeled\", [",
"  \"bd\",",
"  \"dojo\",",
"  \"dijit\",",
"  \"bd/css\",",
"  \"bd/visual\",",
"  \"bd/focusable\",",
"  \"bd/mouseable\",",
"  \"bd/container\"",
"], function(bd, dojo, dijit) {",
"///",
"// Defines the bd.widget.labeled class.",
"",
"return bd.declare(",
"  ///",
"  // A container that contains and manages a single widget decorated by static text. //The class includes",
"  // features to conventiently position and style the label and the contained widget. ",
"  // ",
"  // tabIndex, focusable and disabled attributes are delegated to the contained widget. The descriptor",
"  // values for tabIndex and disabled (or default values, if no descriptor values are given) are passed",
"  // on to the contained widget when it is constructed.",
"  //note",
"  // After the contained widget is constructed, the bd.widget.labeled instance will contain tabIndex and disabled",
"  // properties, but these properties are ignored by the getters/setters.",
"  // ",
"  // click and double-click events",
"  // are delgated to the contained widget by default, but this behavior is controlled by the reflect attribute.",
"  // This can be useful for checkboxes and radio buttons where clicking on the label",
"  // is processed equivalently to clicking on the box/button.",
"  ///",
"  // The descriptor must contain the property \"child\" (a bd.descriptor) to describe the single child; behavior",
"  // is undefined otherwise.",
" ",
"  //class name",
"  \"bd:widget.labeled\",",
"",
"  //superclasses",
"  [bd.visual, bd.focusable, bd.mouseable, bd.container],",
"",
"  //members",
"  bd.attr(",
"    ///",
"    // The text of the label.",
"    ///",
"    //(string, optional, \"\") The text of the label.",
"",
"    \"label\",",
"  ",
"    \"\", //initial value",
"",
"    function(value) {",
"      var oldValue= this.label;",
"      if (value!==oldValue) {",
"        this.label= value;",
"        if (this.domNode) {",
"          this.domNode.firstChild.innerHTML= newValue;",
"          this.layout();",
"        }",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // The position of the label with respect to the box given by the attribute `labelRefBox`.",
"    ///",
"    //(bd.css.cornerPosit, optional, \"tl-tl\") The position of the label with respect to the box given by the attribute `labelRefBox`.",
"",
"    \"labelPosit\",",
"",
"    \"tl-tl\", //initial value",
"",
"    function(value) { //setter",
"      var oldValue= this.posit;",
"      if (value!==oldValue) {",
"        this.posit= value;",
"        this.layout();",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // The reference box to use when positioning the label.",
"    ///",
"    //(bd.css.abbreviatedBox) The reference box to use when positioning the label.",
"    //(falsy, default) Use the margin box for `this.domNode` for the reference box to use when positioning the label.",
"",
"    \"labelRefBox\",",
"",
"    0, //initial value",
"",
"    function(value) { //setter",
"      var oldValue= this.labelRefBox;",
"      if (value!==oldValue) {",
"        this.labelRefBox= value;",
"        this.layout();",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // The value of the DOM class attribute for the label DOM node. //The label",
"    // node will unconditionally contain the class \"bdLabel\".",
"    ///",
"    //(string, optional, \"\") The value of the DOM class attribute for the label DOM node.",
"",
"    \"labelClass\",",
"    0, //initial value",
"",
"    function(value) { //setter",
"      var oldValue= this.labelClass;",
"      if (oldValue!==value) {",
"        this.labelClass= value;",
"        if (this.domNode) {",
"          var node= this.domNode.firstChild;",
"          bd.forEach(oldValue.split(\" \"), function(className) {",
"            className && dojo.removeClass(node, className);",
"          });",
"          bd.forEach(newValue.split(\" \"), function(className) {",
"            className && dojo.addClass(node, className);",
"          });",
"          this.layout();",
"        }",
"      }",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // The position of the child with respect to the box given by the attribute `childRefBox`.",
"    ///",
"    //(bd.css.cornerPosit, optional, \"tl-tl\") The position of the child with respect to the box given by the attribute `childRefBox`.",
"",
"    \"childPosit\",",
"",
"    \"cc-cc\", //initial value",
"",
"    function(value) { //setter",
"      var oldValue= this.childPosit;",
"      if (value!==oldValue) {",
"        this.childPosit= value;",
"        this.layout();",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // The reference box to use when positioning the child.",
"    ///",
"    //(bd.css.abbreviatedBox) The reference box to use when positioning the child.",
"    //(falsy, default) Use the margin box for `this.domNode` for the reference box to use when positioning the child.",
"",
"    \"childRefBox\",",
"",
"    0, //initial value",
"",
"    function(value) { //setter",
"      var oldValue= this.childRefBox;",
"      if (value!==oldValue) {",
"        this.childRefBox= value;",
"        this.layout();",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Controls whether or not click and double-click mouse events are reflected to the contained widget.",
"    ///",
"    //(boolean, optional, true) If true, all click and double-click events that occur on any part of the",
"    // subtree defined by this class, *except the subtree defined by the contained widget*, are reflected to",
"    // the contained widget, and conversely.",
"    //",
" ",
"    \"reflect\",",
"",
"    true //initial value",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Reflects the disabled attribute to/from the contained child widget. //When the contained widget is created,",
"    // the disabled attribute is initialized as given by the bd.widget.labeled descriptor or the default.",
"    ///",
"    //(boolean, optional, false) Reflects the disabled attribute to/from the contained widget.",
"    \"disabled\",",
"",
"    false, //default value",
"",
"    function(value) { //setter",
"      var child= this.children[0];",
"      if (child) {",
"        return child.set(\"disabled\", value);",
"      } else {",
"        return this.inherited(arguments);",
"      }",
"    },",
"",
"    function() { //getter",
"      var child= this.children[0];",
"      if (child) {",
"        return child.get(\"disabled\");",
"      } else {",
"        return this.inherited(arguments);",
"      }",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Reflects the tabIndex attribute to/from the contained child widget. //When the contained widget is created,",
"    // the tabIndex attribute is initialized as given by the bd.widget.labeled descriptor or default.",
"    ///",
"    //(boolean, optional, -1) Reflects the tabIndex attribute to/from the contained widget.",
"",
"    \"tabIndex\",",
"",
"    -1, //default value",
"",
"    function(value) { //setter",
"      var child= this.children[0];",
"      if (child) {",
"        return child.set(\"tabIndex\", value);",
"      } else {",
"        return this.inherited(arguments);",
"      }",
"    },",
"",
"    function() { //getter",
"      var child= this.children[0];",
"      return (child && child.get(\"tabIndex\")) || this.tabIndex;",
"    }",
"  ),",
"",
"  bd.constAttr(",
"    ///",
"    // Reflects the focusable state of the child widget.",
"    ///",
"    //(boolean) false is the contained child (if any) has no use for the focus; true otherwise.",
"    \"focusable\",",
"",
"     bd.noValue, //always calculated",
"",
"     function() { //getter",
"       var child= this.children[0];",
"       return child && this.get(\"visible\") && child.get(\"focusable\");",
"     }",
"  ),",
"",
"  bd.makeDeferredConnects(",
"    ///",
"    // Declares connection points.",
"    {",
"      onClick:[\"click\", \"domNode\"], ",
"      onDblClick:[\"dblclick\", \"domNode\"]",
"    },",
"    bd.visual, bd.focusable, bd.mouseable, bd.container",
"  ),",
"",
"  {",
"  initAttrs:",
"    {dir:1, lang:1, \"class\":1, style:1, title:1},",
"",
"  cssStatefulBases: ",
"    {dijitReset: 0, bdLabeled:1},",
"",
"  cssStatefulWatch: ",
"    {visible:0, disabled:0, focused:0, hover:0},",
"",
"  getCreateDomAttributes: function(",
"     attributes",
"   ) {",
"     attributes= this.inherited(arguments);",
"     attributes.innerHTML= \"<div class=\\\"bdLabel\" + (this.labelClass ? (\" \" + this.labelClass) : \"\") + \"\\\">\" + this.label + \"</div>\";",
"     return attributes;",
"   },",
"",
"  loadChildren: function(",
"    onCreates",
"  ) {",
"    ///",
"    // Loads the child given by the descriptor property `child`.",
"    var kwargs= bd.mix({}, this.kwargs, {parent:this, descriptor:this.descriptor.child});",
"    kwargs.descriptor.disabled= this.disabled;",
"    kwargs.descriptor.tabIndex= this.tabIndex;",
"    return this.descriptor.child && bd.createWidget(kwargs, 0, onCreates);",
"  },",
"",
"  addChild: function(",
"    child",
"  ) {",
"    this.inherited(arguments);",
"    //give an initial ping to cssStatefulWatch for the disabled attribute",
"    var value= !child.get(\"disabled\");",
"    this.adviseWatchers(\"disabled\", value, !value);",
"  },",
"",
"  childGet: function() {",
"    return this.children[0];",
"  },",
"",
"  onClick: function(",
"    e ///(DOM event object) The event object consequent to the DOM event",
"  ) {",
"    ///",
"    // Reflects click events to the container or label to the contained widget iff the instance is not disabled, is visible, and contains",
"    // the onClick connection point.",
"    if (e.target===this.domNode || e.target===this.domNode.firstChild) {",
"      var child= this.children[0];",
"      this.reflect && child && !child.get(\"disabled\") && child.get(\"visible\") && child.onClick && child.onClick(e); ",
"    }",
"  },",
"",
"  onDblClick: function(",
"    e ///(DOM event object) The event object consequent to the DOM event",
"  ) {",
"    ///",
"    // Reflects double click events to the container or label to the contained widget iff the instance is not disabled, is visible, and contains",
"    // the onDblClick connection point.",
"    if (e.target===this.domNode || e.target===this.domNode.firstChild) {",
"      var child= this.children[0];",
"      this.reflect && child && !child.get(\"disabled\") && child.get(\"visible\") && child.onDblClick && child.onDblClick(e); ",
"    }",
"  },",
"",
"  focus: function() {",
"    ///",
"    // Sets the focus to the contained widget iff `this.get(\"focusable\")` returns true.",
"    //warn",
"    // In general, focus is set asynchronously. This ensures focus will be set correctly under all circumstances",
"    // (e.g., from a blur event handler); however, the focus will not have moved before this",
"    // function returns.",
"    if (this.focusableGet()) {",
"      dojo.window.scrollIntoView(this.domNode);",
"      this.children[0].focus();",
"    }",
"  },",
"",
"  onFocus:function(by) {",
"    ///",
"    // Connection point for receiving the focus. //Nontrivial handler that simple passes focus to the contained widget.",
"    if (this.focusableGet()) {",
"      //if getting the focus by clicking on the container but not the contained widget, then delegate to the contained widget...",
"      bd.back(dijit._activeStack)===this.id && this.children[0].focus();",
"    } else {",
"      //should never get here; ping the parent in hopes that it will take our focus away",
"      this.parent.focus();",
"    }",
"  },",
"",
"  getChildRefBox:function(",
"    totalBox,  ///(bd.css.abbreviatedBox) The margin box of this widget instance.",
"    labelBox,  ///(bd.css.abbreviatedBox) The margin box of the label.",
"    labelPosit,///(bd.css.cornerPosit) The `labelPosit` attribute.",
"    childPosit ///(bd.css.cornerPosit) The `childPosit` attribute.",
"  ) {",
"    ///",
"    // Returns the child reference box. //By default, this is defined as `this.childRefBox || totalBox`.",
"    // The sole purpose of this method is to provide a convenient point for subclasses to override this default.",
"    return this.childRefBox || totalBox;",
"  },",
"",
"  layout:function() {",
"    ///",
"    // Positions the label and the contained child; returns the margin box of this widget.",
"    if (!this.started) {",
"      return 0;",
"    }",
"    var",
"      labelBox, childBox, childRefBox,",
"      domNode= this.domNode,",
"      mb= bd.mix(dojo.marginBox(domNode), {t:0, l:0}),",
"      label= this.label.length && this.label,",
"      labelNode= label && this.domNode.firstChild,",
"      labelPosit= label && this.labelPosit.toLowerCase(),",
"      labelRefBox= label && (this.labelRefBox || mb),",
"      child= this.children[0],",
"      childNode= child && child.domNode,",
"      childPosit= childNode && this.childPosit.toLowerCase();",
"    if (!/(t|c|b)(l|c|r)\\-(t|c|b)(l|c|r)/.test(labelPosit)) {",
"      labelPosit= 0;",
"    }",
"    if (!/(t|c|b)(l|c|r)\\-(t|c|b)(l|c|r)/.test(childPosit)) {",
"      childPosit= 0;",
"    }",
"    if (label && labelPosit) {",
"      dojo.style(labelNode, {position:\"absolute\"});",
"      labelBox= dojo.marginBox(labelNode);",
"      labelBox.t= bd.css.cornerCalculators.getTop(labelPosit, labelBox, mb);",
"      labelBox.l= bd.css.cornerCalculators.getLeft(labelPosit, labelBox, mb);",
"      dojo.marginBox(labelNode, labelBox);",
"    }",
"    if (childNode && childPosit) {",
"      dojo.style(childNode, {position:\"absolute\"});",
"      childBox= (child.layout && child.layout()) || dojo.marginBox(childNode);",
"      childRefBox= this.getChildRefBox(mb, labelBox, labelPosit, childPosit);",
"      childBox.t= bd.css.cornerCalculators.getTop(childPosit, childBox, childRefBox);",
"      childBox.l= bd.css.cornerCalculators.getLeft(childPosit, childBox, childRefBox);",
"      dojo.marginBox(childNode, childBox);      ",
"    }",
"    return mb;",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.widget.labeled":{
type:
Tclass,
sdoc:
["A container that contains and manages a single widget decorated by static text. "],
ldoc:
["A container that contains and manages a single widget decorated by static text. The class includes\nfeatures to conventiently position and style the label and the contained widget.\n\ntabIndex, focusable and disabled attributes are delegated to the contained widget. The descriptor\nvalues for tabIndex and disabled (or default values, if no descriptor values are given) are passed\non to the contained widget when it is constructed.",
[NOTE,"After the contained widget is constructed, the bd.widget.labeled instance will contain tabIndex and disabled\nproperties, but these properties are ignored by the getters/setters.\n\nclick and double-click events\nare delgated to the contained widget by default, but this behavior is controlled by the reflect attribute.\nThis can be useful for checkboxes and radio buttons where clicking on the label\nis processed equivalently to clicking on the box/button."],
"The descriptor must contain the property \"child\" (a bd.descriptor) to describe the single child; behavior\nis undefined otherwise."],
src:
"bd/widget/labeled",
loc: [13,7,410,2],
supers:
["bd.visual","bd.focusable","bd.mouseable","bd.container"],
module:"bd/widget/labeled"}
,"bd.widget.labeled.deferredConnects":{
type:
Tvariable,
sdoc:
["Declares connection points."],
imember:1,
ldoc:
[],
loc: [257,2,265,3]}
,"bd.widget.labeled.focusable":{
type:
Tvariable,
sdoc:
["Reflects the focusable state of the child widget."],
imember:1,
ldoc:
[],
flags:
[Froattr],
loc: [242,2,255,3],
types:
[["boolean",
["false is the contained child (if any) has no use for the focus; true otherwise."]]]}
,"bd.widget.labeled.tabIndex":{
type:
Tvariable,
sdoc:
["Reflects the tabIndex attribute to/from the contained child widget. "],
imember:1,
ldoc:
["Reflects the tabIndex attribute to/from the contained child widget. When the contained widget is created,\nthe tabIndex attribute is initialized as given by the bd.widget.labeled descriptor or default."],
flags:
[Fattr],
loc: [216,2,240,3],
types:
[["boolean, optional, -1",
["Reflects the tabIndex attribute to/from the contained widget."]]]}
,"bd.widget.labeled.disabled":{
type:
Tvariable,
sdoc:
["Reflects the disabled attribute to/from the contained child widget. "],
imember:1,
ldoc:
["Reflects the disabled attribute to/from the contained child widget. When the contained widget is created,\nthe disabled attribute is initialized as given by the bd.widget.labeled descriptor or the default."],
flags:
[Fattr],
loc: [187,2,214,3],
types:
[["boolean, optional, false",
["Reflects the disabled attribute to/from the contained widget."]]]}
,"bd.widget.labeled.reflect":{
type:
Tvariable,
sdoc:
["Controls whether or not click and double-click mouse events are reflected to the contained widget."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [173,2,185,3],
types:
[["boolean, optional, true",
["If true, all click and double-click events that occur on any part of the\n subtree defined by this class, *except the subtree defined by the contained widget*, are reflected to\n the contained widget, and conversely."]]]}
,"bd.widget.labeled.childRefBox":{
type:
Tvariable,
sdoc:
["The reference box to use when positioning the child."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [152,2,171,3],
types:
[["bd.css.abbreviatedBox",
["The reference box to use when positioning the child."]],
["falsy, default",
["Use the margin box for `this.domNode` for the reference box to use when positioning the child."]]]}
,"bd.widget.labeled.childPosit":{
type:
Tvariable,
sdoc:
["The position of the child with respect to the box given by the attribute `childRefBox`."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [132,2,150,3],
types:
[["bd.css.cornerPosit, optional, \"tl-tl\"",
["The position of the child with respect to the box given by the attribute `childRefBox`."]]]}
,"bd.widget.labeled.labelClass":{
type:
Tvariable,
sdoc:
["The value of the DOM class attribute for the label DOM node. "],
imember:1,
ldoc:
["The value of the DOM class attribute for the label DOM node. The label\nnode will unconditionally contain the class \"bdLabel\"."],
flags:
[Fattr],
loc: [104,2,130,3],
types:
[["string, optional, \"\"",
["The value of the DOM class attribute for the label DOM node."]]]}
,"bd.widget.labeled.labelRefBox":{
type:
Tvariable,
sdoc:
["The reference box to use when positioning the label."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [83,2,102,3],
types:
[["bd.css.abbreviatedBox",
["The reference box to use when positioning the label."]],
["falsy, default",
["Use the margin box for `this.domNode` for the reference box to use when positioning the label."]]]}
,"bd.widget.labeled.labelPosit":{
type:
Tvariable,
sdoc:
["The position of the label with respect to the box given by the attribute `labelRefBox`."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [63,2,81,3],
types:
[["bd.css.cornerPosit, optional, \"tl-tl\"",
["The position of the label with respect to the box given by the attribute `labelRefBox`."]]]}
,"bd.widget.labeled.label":{
type:
Tvariable,
sdoc:
["The text of the label."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [40,2,61,3],
types:
[["string, optional, \"\"",
["The text of the label."]]]}
,"bd.widget.labeled.loadChildren":{
type:
Tfunction,
sdoc:
["Loads the child given by the descriptor property `child`."],
imember:1,
ldoc:
[],
params:
[["onCreates",[]]],
loc: [285,2,294,3]}
,"bd.widget.labeled.onClick":{
type:
Tfunction,
sdoc:
["Reflects click events to the container or label to the contained widget iff the instance is not disabled, is visible, and contains\nthe onClick connection point."],
imember:1,
ldoc:
[],
params:
[["e",[["DOM event object",
["The event object consequent to the DOM event"]]]]],
loc: [309,2,319,3]}
,"bd.widget.labeled.onDblClick":{
type:
Tfunction,
sdoc:
["Reflects double click events to the container or label to the contained widget iff the instance is not disabled, is visible, and contains\nthe onDblClick connection point."],
imember:1,
ldoc:
[],
params:
[["e",[["DOM event object",
["The event object consequent to the DOM event"]]]]],
loc: [321,2,331,3]}
,"bd.widget.labeled.focus":{
type:
Tfunction,
sdoc:
["Sets the focus to the contained widget iff `this.get(\"focusable\")` returns true."],
imember:1,
ldoc:
[[WARN,"In general, focus is set asynchronously. This ensures focus will be set correctly under all circumstances\n(e.g., from a blur event handler); however, the focus will not have moved before this\nfunction returns."]],
loc: [333,2,344,3]}
,"bd.widget.labeled.onFocus":{
type:
Tfunction,
sdoc:
["Connection point for receiving the focus. "],
imember:1,
ldoc:
["Connection point for receiving the focus. Nontrivial handler that simple passes focus to the contained widget."],
params:
[["by",[]]],
loc: [346,2,356,3]}
,"bd.widget.labeled.getChildRefBox":{
type:
Tfunction,
sdoc:
["Returns the child reference box. "],
imember:1,
ldoc:
["Returns the child reference box. By default, this is defined as `this.childRefBox || totalBox`.\nThe sole purpose of this method is to provide a convenient point for subclasses to override this default."],
params:
[["totalBox",[["bd.css.abbreviatedBox",
["The margin box of this widget instance."]]]],
["labelBox",[["bd.css.abbreviatedBox",
["The margin box of the label."]]]],
["labelPosit",[["bd.css.cornerPosit",
["The `labelPosit` attribute."]]]],
["childPosit",[["bd.css.cornerPosit",
["The `childPosit` attribute."]]]]],
loc: [358,2,368,3]}
,"bd.widget.labeled.layout":{
type:
Tfunction,
sdoc:
["Positions the label and the contained child; returns the margin box of this widget."],
imember:1,
ldoc:
[],
loc: [370,2,409,3]}
,"modules.bd/widget/labeled":{
type:
Tmodule,
sdoc:
["Defines the bd.widget.labeled class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]],
["dijit",[]]],
src:
"bd/widget/labeled",
loc: [0,0,412,2]}
,"resources.bd/widget/menu":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/menu"],
src:
"bd/widget/menu",
modules:
["bd/widget/menu"],
code:
["dojo.def(\"bd/widget/menu\", [",
"  \"bd\", \"dojo\", \"dijit\",",
"  \"bd/command/item\",",
"  \"bd/command/dispatch\",",
"  \"bd/command/accelerators\",",
"  \"bd/stateful\",",
"  \"bd/containable\",",
"  \"bd/dijit/compat\",",
"  \"dijit/CheckedMenuItem\",",
"  \"dijit/Menu\",",
"  \"dijit/MenuBar\",",
"  \"dijit/MenuBarItem\",",
"  \"dijit/MenuSeparator\",",
"  \"dijit/PopupMenuBarItem\",",
"  \"dijit/PopupMenuItem\"",
"], function(bd, dojo, dijit) {",
"///",
"// Defines the Backdraft extensions to the dojo menu machinery.",
"",
"",
"var",
"populateMenu= function(",
"  rootMenu,",
"  menu,",
"  itemType,",
"  submenuItemType,",
"  separatorType",
") {",
"  var group= false;",
"  dojo.forEach(bd.command.itemIdsInOrder(menu.contents), function(item) {",
"    var commandItem= bd.command.itemCache.get(item);",
"    if (group===false) {",
"      group= commandItem.groupId;",
"    }",
"    if (commandItem.groupId!=group && separatorType) {",
"      menu.addChild(new separatorType());",
"      group= commandItem.groupId;",
"    }",
"    if (commandItem.role==bd.command.roles.command) {",
"      menu.addChild(new itemType(rootMenu, commandItem));",
"    } else if (commandItem.role==bd.command.roles.menu) {",
"      var",
"  popupMenu= new bd.widget.popupMenu(rootMenu, menu, item, menu.contents[item]),",
"  popupItem= new submenuItemType(item, popupMenu);",
"      menu.addChild(popupItem);",
"    }",
"  });",
"},",
"",
"resolveCommandItem= function(",
"  item // either a command item identfier or a command item",
") {",
"  if (dojo.isString(item)) {",
"    return bd.command.itemCache.get(item);",
"  } else {",
"    return item;",
"  }",
"},",
"",
"makePostscriptParams= function(",
"  commandItem,",
"  popup",
") {",
"  commandItem= resolveCommandItem(commandItem);",
"  var result= {",
"    label:commandItem.htmlText,",
"    iconClass:commandItem.getIcon(),",
"    disabled:commandItem.disabled,",
"    mnemonic:commandItem.mnemonic};",
"  if (commandItem.accelText && commandItem.accelText.length) {",
"    result.accelKey= commandItem.accelText;",
"  }",
"  if (popup) {",
"    result.popup= popup;",
"  }",
"  return [result];",
"};",
"",
"bd.declare(",
"  ///",
"  // Wrapper around dijit.MenuItem that allows construction based on a bd.command.item and ",
"  // causes item selection to be sent to the root menu.",
"",
"  //class name",
"  \"bd:widget.menuItem\", ",
"",
"  //superclasses",
"  [dijit.MenuItem], ",
"",
"  //members",
"  {",
"  constructor: function(",
"    rootMenu,   ///(bd.widget.toplevelMenu) Gives the target menu to which to send item selection notifications.",
"    commandItem ///(bd.command.item) Gives all menu item properties (text, accelerator, etc.) required to create the item.",
"  ) {",
"    ///",
"    // Creates a new instance.",
"  },",
"",
"  postscript: function(",
"    rootMenu,   //(bd.widget.toplevelMenu) Gives the target menu to which to send item selection notifications.",
"    commandItem //(bd.command.item) Gives all menu item properties (text, accelerator, etc.) required to create the item.",
"  ) {",
"    this.rootMenu= rootMenu;",
"    this.commandId= dojo.isString(commandItem) ? commandItem : commandItem.id;",
"    this.inherited(arguments, makePostscriptParams(commandItem));",
"  },",
"",
"  onClick: function() {",
"    this.inherited(arguments);",
"    this.rootMenu.onBafExec(this.commandId);",
"  }",
"});",
"",
"bd.declare(",
"  ///",
"  // Wrapper around dijit.MenuBarItem that allows construction based on a bd.command.item and ",
"  // causes item selection to be sent to the root menu.",
"  ",
"  //class name",
"  \"bd:widget.menubarItem\", ",
"  ",
"  //superclasses",
"  [dijit.MenuBarItem], ",
"  ",
"  //members",
"  {",
"  constructor: function(",
"    rootMenu,   ///(bd.widget.toplevelMenu) Gives the target menu to which to send item selection notifications.",
"    commandItem ///(bd.command.item) Gives all menu item properties (text, accelerator, etc.) required to create the item.",
"  ) {",
"    ///",
"    // Creates a new instance.",
"  },",
"",
"  postscript: function(",
"    rootMenu,   //(bd.widget.toplevelMenu) Gives the target menu to which to send item selection notifications.",
"    commandItem //(bd.command.item) Gives all menu item properties (text, accelerator, etc.) required to create the item.",
"  ) {",
"    this.rootMenu= rootMenu;",
"    this.commandId= dojo.isString(commandItem) ? commandItem : commandItem.id;",
"    this.inherited(arguments, makePostscriptParams(commandItem));",
"  },",
"",
"  onClick: function() {",
"    this.inherited(arguments);",
"    this.rootMenu.onBafExec(this.commandId);",
"  }",
"});",
"",
"bd.declare(",
"  ///",
"  // Wrapper around dijit.PopupMenuItem that allows construction based on a bd.command.item and ",
"  // causes the root menu to be propagated to submenu items.",
"  ",
"  //class name",
"  \"bd:widget.menuPopupItem\", ",
"",
"  //superclasses",
"  [dijit.PopupMenuItem], ",
"",
"  //members",
"  {",
"  constructor: function(",
"    commandItem, ///(bd.command.item) Gives all menu item properties (text, accelerator, etc.) required to create the item.",
"    popupMenu    ///(bd.widget.popupMenu) The containing menu.",
"  ) {",
"    ///",
"    // Creates a new instance.",
"  },",
"",
"  postscript: function(",
"    commandItem, //(bd.command.item) Gives all menu item properties (text, accelerator, etc.) required to create the item.",
"    popupMenu    //(bd.widget.popupMenu) The containing menu.",
"  ) {",
"    this.inherited(arguments, makePostscriptParams(commandItem, popupMenu));",
"  }",
"});",
"",
"bd.declare(",
"  ///",
"  // Wrapper around dijit.PopupMenuBarItem that allows construction based on a bd.command.item and ",
"  // causes the root menu to be propagated to submenu items.",
"",
"  //class name",
"  \"bd:widget.menubarPopupItem\", ",
"",
"  //superclasses",
"  [dijit.PopupMenuBarItem], ",
"  ",
"  //members",
"  {",
"  constructor: function(",
"    commandItem, ///(bd.command.item) Gives all menu item properties (text, accelerator, etc.) required to create the item.",
"    popupMenu    ///(bd.widget.popupMenu) The containing menu.",
"  ) {",
"    ///",
"    // Creates a new instance.",
"  },",
"",
"  postscript: function(",
"    commandItem, //(bd.command.item) Gives all menu item properties (text, accelerator, etc.) required to create the item.",
"    popupMenu    //(bd.widget.popupMenu) The containing menu.",
"  ) {",
"    this.inherited(arguments, makePostscriptParams(commandItem, popupMenu));",
"  }",
"});",
"",
"bd.declare(",
"  ///",
"  // A wrapper around dijit.Menu that adds the ability to dynamically define the ",
"  // contents of the menu when it is opened. //The subclass also includes machinery",
"  // to accept a non-standard constructor signature that provides the following:",
"  // ",
"  // * the root menu: required for bd.widget.toplevelMenu",
"  // * the parent menu: required for dijit.Menu,",
"  // * the menu identifier: required to retrieve bd.command.item properties for this menu",
"  // * the contents: a bd.command.menuTree that (describes the contents of the menu.",
"  //",
"  // See bd.widget.popupMenu.constructor.",
"",
"  //class name",
"  \"bd:widget.popupMenu\", ",
"  ",
"  //superclasses",
"  [dijit.Menu], ",
"",
"  //members",
"  bd.attr(",
"    ///",
"    // A bd.command.menuTree that gives the contents of the menu. //A bd.command.item must exist ",
"    // in the bd.command.cache for each bd.command.id mentioned in the tree.",
"    ///",
"    // (bd.command.menuTree, optional, {}) Gives the contents of the menu.",
"   ",
"    \"contents\",",
"",
"    {}",
"  ),",
"",
"  {",
"  constructor: function(",
"    rootMenu, ///(bd.widget.toplevelMenu) The top-most menu in the menu hierarchy of which this menu is a part.",
"    parent,   ///(dijit.Menu or null) The parent menu, if any.",
"    menuId,   ///(bd.command.id) The bd.command.id of this menu.",
"    contents  ///(bd.command.menuTree) The contents of this menu.",
"  ) {",
"    ///",
"    // Creates a new instance.",
"  },",
"",
"  popupDelay: 0,",
"",
"  postscript: function(",
"    rootMenu, //(bd.widget.toplevelMenu) The top-most menu in the menu hierarchy of which this menu is a part.",
"    parent,   //(dijit.Menu or null) The parent menu, if any.",
"    menuId,   //(bd.command.id) The bd.command.id of this menu.",
"    contents  //(bd.command.menuTree) The contents of this menu.",
"  ) {",
"    //remember initialization parameters and create the dijit menu",
"    dojo.mix(this, {rootMenu:rootMenu, menuId:menuId, contents:contents});",
"    this.inherited(arguments, [{parentMenu:parent}]);",
"  },",
"",
"  onOpen: function() {",
"    ///",
"    // Nontrivial connection point that\'s called when this menu is opened. //Publishes the topic \"bdOpenMenu\"",
"    // with the argument `this` which allows subscribers to set or modify the contents of the menu. Then",
"    // populates the menu as given by the `contents` attribute.",
"    dojo.publish(\"bdOpenMenu\", [this]);",
"    populateMenu(this.rootMenu, this, bd.widget.menuItem, bd.widget.menuPopupItem, dijit.MenuSeparator);",
"  },",
"",
"  onBafExec: function(",
"    commandId",
"  ) {",
"    bd.command.scheduleCommand(commandId);",
"  },",
"",
"  onClose: function() {",
"    this.inherited(arguments);",
"    this.destroyDescendants();",
"  }",
"});",
"",
"",
"bd.declare(",
"  ///",
"  // A mixin class that adds minor features to dijit-derived menus. //The following features are included:",
"  // ",
"  // * The ability restore the focus to the item that had the focus before a menu was navigated.",
"  // * The ability to dispatch a menu command asynchronously through the Backdraft command dispatcher (bd.command.scheduleCommand).",
"  // * The ability to cancel menu navigation by pressing the escape key.",
"  // * The ability to automatically suspend and resume Backdraft accelerators during menu navigation.",
"  ",
"  //class name",
"  \"bd:widget.toplevelMenu\", ",
"",
"  //superclasses",
"  [],",
"",
"  //members",
"  {",
"  focus: function() {",
"    ///",
"    // Remembers the current focus and sets the focus to this menu.",
"    this.restore= {",
"      focusNode: dijit.getFocus(this),",
"      stack: dijit._activeStack.slice(0)",
"    };",
"    (this.focusNode || this.domNode).focus();",
"  },",
"",
"  onBafExec: function(",
"    commandId //(bd.command.id) The command id to execute.",
"  ) {",
"    // Schedules commandId for asynchronous execution via bd.command.scheduleCommand and restores the previously saved focus (if required).",
"    bd.command.scheduleCommand(commandId);",
"    this._restore();",
"  },",
"",
"  _onFocus: function() {",
"    ///",
"    // Suspends accelerators and remembers the item that had the focus previous to this menu. //This",
"    // method is called automatically by the dijit focus manager.",
"    // `private",
"    bd.command.suspendAccels();",
"    if (!this.restore) {",
"      // here if activated by a click on a visible item",
"      this.restore= {",
"        focusNode: dijit.getFocus(this),",
"        stack: dijit._prevStack",
"      };",
"    }",
"    this.inherited(arguments);",
"  },",
"",
"  _onBlur: function() {",
"    // Resumes the accelerators and restores the previously saved focus (if required). //This",
"    // method is called automatically by the dijit focus manager.",
"    // `private",
"    this.inherited(arguments);",
"    bd.command.resumeAccels();",
"    this._restore();",
"  },",
"",
"  _onKeyPress: function(",
"    e ///(DOM event object) DOM event object consequent to keypress event.",
"  ){",
"    ///",
"    // Detects pressing the escape key, and, if detected, cancels menu navigation. //This method is called",
"    // automatically by th dijit menu DOM event handler wiring.",
"    // `private",
"    if (e.charOrCode==dojo.keys.ESCAPE) {",
"      this._restore();",
"    } else {",
"      this.inherited(arguments);",
"    }",
"  },",
"",
"  _restore: function() {",
"    ///",
"    // Sets the focus to the saved focus (if any).",
"    if (this.restore) {",
"      var temp= this.restore;",
"      this.restore= null;",
"      if (temp.focusNode) {",
"        dijit.focus(temp.focusNode);",
"      }",
"      if (temp.stack) {",
"        dijit._setStack(temp.stack);",
"      }",
"    }",
"    this.restore= null;",
"  }",
"",
"});",
"",
"bd.declare(",
"  ///",
"  // A wrapper around dijit.Menu includes a Backdraft-compatible constructor and population",
"  // leveraging the Backdraft command framework.",
"  /// ",
"  // The class includes necessary machinery to subclass dijit.Menubar while accepting a bd.createWidget.kwargs",
"  // argument during construction. After construction, the menu is populated as given by the `contents` attribute. All  attributes (text,",
"  // accelerator, icon, etc.) of individual menu items are taken from the bd.command.cache.",
"",
"  //class name",
"  \"bd:widget.verticalMenubar\", ",
"",
"  //superclasses",
"  [dijit.Menu, bd.containable, bd.widget.toplevelMenu], ",
"",
"  //members",
"  bd.attr(",
"    ///",
"    // A bd.command.menuTree that gives the contents of the menu. //A bd.command.item must exist ",
"    // in the bd.command.cache for each bd.command.id mentioned in the tree.",
"    ///",
"    // (bd.command.menuTree, optional, {}) Gives the contents of the menu.",
"   ",
"    \"contents\",",
"",
"    {}",
"  ),",
"",
"  {",
"  constructor: function(",
"    kwargs ///(bd.createWidget.kwargs) Describes how to create an instance.",
"  ) {",
"    ///",
"    // Creates a new instance.",
"  },",
"",
"  preamble: function(",
"    kwargs //(bd.createWidget.kwargs) Describes how to create an instance.",
"  ) {",
"    this.kwargs= kwargs || {};",
"    bd.mix(this, this.kwargs);",
"    bd.mix(this, this.kwargs.descriptor || {});",
"    return [kwargs.descriptor];",
"  },",
"",
"  postscript: function(",
"    kwargs //(bd.createWidget.kwargs) Describes how to create an instance.",
"  ) {",
"    this.create(kwargs.descriptor);",
"    this.parent= kwargs.parent;",
"  },",
"",
"  postCreate: function(){",
"    populateMenu(this, this, bd.widget.menuItem, bd.widget.menuPopupItem, dijit.MenuSeparator);",
"    this.inherited(arguments);",
"  }",
"});",
"",
"bd.declare(",
"  ///",
"  // A wrapper around dijit.MenuBar includes a Backdraft-compatible constructor and population",
"  // leveraging the Backdraft command framework.",
"  /// ",
"  // The class includes necessary machinery to subclass dijit.Menubar while accepting a bd.createWidget.kwargs",
"  // argument during construction. After construction, the menu is populated as given by the `contents` attribute. All  attributes (text,",
"  // accelerator, icon, etc.) of individual menu items are taken from the bd.command.cache.",
"  ",
"  //class name",
"  \"bd:widget.menubar\", ",
"",
"  //superclasses",
"  [dijit.MenuBar, bd.containable, bd.widget.toplevelMenu], ",
"",
"  //members",
"  bd.attr(",
"    ///",
"    // A bd.command.menuTree that gives the contents of the menu. //A bd.command.item must exist ",
"    // in the bd.command.cache for each bd.command.id mentioned in the tree.",
"    ///",
"    // (bd.command.menuTree, optional, {}) Gives the contents of the menu.",
"   ",
"    \"contents\",",
"",
"    {}",
"  ),",
"",
"  {",
"  constructor: function(",
"    kwargs ///(bd.createWidget.kwargs) Describes how to create an instance.",
"  ) {",
"    ///",
"    // Creates a new instance.",
"  },",
"",
"  preamble: function(",
"    kwargs //(bd.createWidget.kwargs) Describes how to create an instance.",
"  ) {",
"    this.kwargs= kwargs || {};",
"    bd.mix(this, this.kwargs);",
"    bd.mix(this, this.kwargs.descriptor || {});",
"    return [kwargs.descriptor];",
"  },",
"",
"  postscript: function(",
"    kwargs //(bd.createWidget.kwargs) Describes how to create an instance.",
"  ) {",
"    this.create(kwargs.descriptor);",
"    this.parent= kwargs.parent;",
"  },",
"",
"  postCreate: function() {",
"    populateMenu(this, this, bd.widget.menubarItem, bd.widget.menubarPopupItem, null);",
"    this.inherited(arguments);",
"    this.insertAccels && bd.command.insertMenuAccels(this.contents);",
"  }",
"});",
"",
"//TODO: construct a widget.MenuSeparator for menubar",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.widget.menuItem":{
type:
Tclass,
sdoc:
["Wrapper around dijit.MenuItem that allows construction based on a bd.command.item and\ncauses item selection to be sent to the root menu."],
ldoc:
[],
src:
"bd/widget/menu",
loc: [78,0,112,2],
supers:
["dijit.MenuItem"],
module:"bd/widget/menu"}
,"bd.widget.menuItem.constructor":{
type:
Tfunction,
sdoc:
["Creates a new instance."],
imember:1,
ldoc:
[],
params:
[["rootMenu",[["bd.widget.toplevelMenu",
["Gives the target menu to which to send item selection notifications."]]]],
["commandItem",[["bd.command.item",
["Gives all menu item properties (text, accelerator, etc.) required to create the item."]]]]],
loc: [91,2,97,3]}
,"bd.widget.menubarItem":{
type:
Tclass,
sdoc:
["Wrapper around dijit.MenuBarItem that allows construction based on a bd.command.item and\ncauses item selection to be sent to the root menu."],
ldoc:
[],
src:
"bd/widget/menu",
loc: [114,0,148,2],
supers:
["dijit.MenuBarItem"],
module:"bd/widget/menu"}
,"bd.widget.menubarItem.constructor":{
type:
Tfunction,
sdoc:
["Creates a new instance."],
imember:1,
ldoc:
[],
params:
[["rootMenu",[["bd.widget.toplevelMenu",
["Gives the target menu to which to send item selection notifications."]]]],
["commandItem",[["bd.command.item",
["Gives all menu item properties (text, accelerator, etc.) required to create the item."]]]]],
loc: [127,2,133,3]}
,"bd.widget.menuPopupItem":{
type:
Tclass,
sdoc:
["Wrapper around dijit.PopupMenuItem that allows construction based on a bd.command.item and\ncauses the root menu to be propagated to submenu items."],
ldoc:
[],
src:
"bd/widget/menu",
loc: [150,0,177,2],
supers:
["dijit.PopupMenuItem"],
module:"bd/widget/menu"}
,"bd.widget.menuPopupItem.constructor":{
type:
Tfunction,
sdoc:
["Creates a new instance."],
imember:1,
ldoc:
[],
params:
[["commandItem",[["bd.command.item",
["Gives all menu item properties (text, accelerator, etc.) required to create the item."]]]],
["popupMenu",[["bd.widget.popupMenu",
["The containing menu."]]]]],
loc: [163,2,169,3]}
,"bd.widget.menubarPopupItem":{
type:
Tclass,
sdoc:
["Wrapper around dijit.PopupMenuBarItem that allows construction based on a bd.command.item and\ncauses the root menu to be propagated to submenu items."],
ldoc:
[],
src:
"bd/widget/menu",
loc: [179,0,206,2],
supers:
["dijit.PopupMenuBarItem"],
module:"bd/widget/menu"}
,"bd.widget.menubarPopupItem.constructor":{
type:
Tfunction,
sdoc:
["Creates a new instance."],
imember:1,
ldoc:
[],
params:
[["commandItem",[["bd.command.item",
["Gives all menu item properties (text, accelerator, etc.) required to create the item."]]]],
["popupMenu",[["bd.widget.popupMenu",
["The containing menu."]]]]],
loc: [192,2,198,3]}
,"bd.widget.popupMenu":{
type:
Tclass,
sdoc:
["A wrapper around dijit.Menu that adds the ability to dynamically define the\ncontents of the menu when it is opened. "],
ldoc:
["A wrapper around dijit.Menu that adds the ability to dynamically define the\ncontents of the menu when it is opened. The subclass also includes machinery\nto accept a non-standard constructor signature that provides the following:\n\n* the root menu: required for bd.widget.toplevelMenu\n* the parent menu: required for dijit.Menu,\n* the menu identifier: required to retrieve bd.command.item properties for this menu\n* the contents: a bd.command.menuTree that (describes the contents of the menu.\n\nSee bd.widget.popupMenu.constructor."],
src:
"bd/widget/menu",
loc: [208,0,283,2],
supers:
["dijit.Menu"],
module:"bd/widget/menu"}
,"bd.widget.popupMenu.contents":{
type:
Tvariable,
sdoc:
["A bd.command.menuTree that gives the contents of the menu. "],
imember:1,
ldoc:
["A bd.command.menuTree that gives the contents of the menu. A bd.command.item must exist\nin the bd.command.cache for each bd.command.id mentioned in the tree.",
"(bd.command.menuTree, optional, {}) Gives the contents of the menu."],
flags:
[Fattr],
loc: [228,2,238,3]}
,"bd.widget.popupMenu.constructor":{
type:
Tfunction,
sdoc:
["Creates a new instance."],
imember:1,
ldoc:
[],
params:
[["rootMenu",[["bd.widget.toplevelMenu",
["The top-most menu in the menu hierarchy of which this menu is a part."]]]],
["parent",[["dijit.Menu or null",
["The parent menu, if any."]]]],
["menuId",[["bd.command.id",
["The bd.command.id of this menu."]]]],
["contents",[["bd.command.menuTree",
["The contents of this menu."]]]]],
loc: [241,2,249,3]}
,"bd.widget.popupMenu.onOpen":{
type:
Tfunction,
sdoc:
["Nontrivial connection point that\'s called when this menu is opened. "],
imember:1,
ldoc:
["Nontrivial connection point that\'s called when this menu is opened. Publishes the topic \"bdOpenMenu\"\nwith the argument `this` which allows subscribers to set or modify the contents of the menu. Then\npopulates the menu as given by the `contents` attribute."],
loc: [264,2,271,3]}
,"bd.widget.toplevelMenu":{
type:
Tclass,
sdoc:
["A mixin class that adds minor features to dijit-derived menus. "],
ldoc:
["A mixin class that adds minor features to dijit-derived menus. The following features are included:\n\n* The ability restore the focus to the item that had the focus before a menu was navigated.\n* The ability to dispatch a menu command asynchronously through the Backdraft command dispatcher (bd.command.scheduleCommand).\n* The ability to cancel menu navigation by pressing the escape key.\n* The ability to automatically suspend and resume Backdraft accelerators during menu navigation."],
src:
"bd/widget/menu",
loc: [286,0,376,2],
module:"bd/widget/menu"}
,"bd.widget.toplevelMenu.focus":{
type:
Tfunction,
sdoc:
["Remembers the current focus and sets the focus to this menu."],
imember:1,
ldoc:
[],
loc: [303,2,311,3]}
,"bd.widget.toplevelMenu._onFocus":{
type:
Tfunction,
sdoc:
["Suspends accelerators and remembers the item that had the focus previous to this menu. "],
imember:1,
ldoc:
["Suspends accelerators and remembers the item that had the focus previous to this menu. This\nmethod is called automatically by the dijit focus manager."],
flags:
[Fprivate],
loc: [321,2,335,3]}
,"bd.widget.toplevelMenu._onKeyPress":{
type:
Tfunction,
sdoc:
["Detects pressing the escape key, and, if detected, cancels menu navigation. "],
imember:1,
ldoc:
["Detects pressing the escape key, and, if detected, cancels menu navigation. This method is called\nautomatically by th dijit menu DOM event handler wiring."],
flags:
[Fprivate],
params:
[["e",[["DOM event object",
["DOM event object consequent to keypress event."]]]]],
loc: [346,2,358,3]}
,"bd.widget.toplevelMenu._restore":{
type:
Tfunction,
sdoc:
["Sets the focus to the saved focus (if any)."],
imember:1,
ldoc:
[],
loc: [360,2,374,3]}
,"bd.widget.verticalMenubar":{
type:
Tclass,
sdoc:
["A wrapper around dijit.Menu includes a Backdraft-compatible constructor and population\nleveraging the Backdraft command framework."],
ldoc:
["The class includes necessary machinery to subclass dijit.Menubar while accepting a bd.createWidget.kwargs\nargument during construction. After construction, the menu is populated as given by the `contents` attribute. All  attributes (text,\naccelerator, icon, etc.) of individual menu items are taken from the bd.command.cache."],
src:
"bd/widget/menu",
loc: [378,0,434,2],
supers:
["dijit.Menu","bd.containable","bd.widget.toplevelMenu"],
module:"bd/widget/menu"}
,"bd.widget.verticalMenubar.contents":{
type:
Tvariable,
sdoc:
["A bd.command.menuTree that gives the contents of the menu. "],
imember:1,
ldoc:
["A bd.command.menuTree that gives the contents of the menu. A bd.command.item must exist\nin the bd.command.cache for each bd.command.id mentioned in the tree.",
"(bd.command.menuTree, optional, {}) Gives the contents of the menu."],
flags:
[Fattr],
loc: [394,2,404,3]}
,"bd.widget.verticalMenubar.constructor":{
type:
Tfunction,
sdoc:
["Creates a new instance."],
imember:1,
ldoc:
[],
params:
[["kwargs",[["bd.createWidget.kwargs",
["Describes how to create an instance."]]]]],
loc: [407,2,412,3]}
,"bd.widget.menubar":{
type:
Tclass,
sdoc:
["A wrapper around dijit.MenuBar includes a Backdraft-compatible constructor and population\nleveraging the Backdraft command framework."],
ldoc:
["The class includes necessary machinery to subclass dijit.Menubar while accepting a bd.createWidget.kwargs\nargument during construction. After construction, the menu is populated as given by the `contents` attribute. All  attributes (text,\naccelerator, icon, etc.) of individual menu items are taken from the bd.command.cache."],
src:
"bd/widget/menu",
loc: [436,0,493,2],
supers:
["dijit.MenuBar","bd.containable","bd.widget.toplevelMenu"],
module:"bd/widget/menu"}
,"bd.widget.menubar.contents":{
type:
Tvariable,
sdoc:
["A bd.command.menuTree that gives the contents of the menu. "],
imember:1,
ldoc:
["A bd.command.menuTree that gives the contents of the menu. A bd.command.item must exist\nin the bd.command.cache for each bd.command.id mentioned in the tree.",
"(bd.command.menuTree, optional, {}) Gives the contents of the menu."],
flags:
[Fattr],
loc: [452,2,462,3]}
,"bd.widget.menubar.constructor":{
type:
Tfunction,
sdoc:
["Creates a new instance."],
imember:1,
ldoc:
[],
params:
[["kwargs",[["bd.createWidget.kwargs",
["Describes how to create an instance."]]]]],
loc: [465,2,470,3]}
,"modules.bd/widget/menu":{
type:
Tmodule,
sdoc:
["Defines the Backdraft extensions to the dojo menu machinery."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]],
["dijit",[]]],
src:
"bd/widget/menu",
loc: [0,0,497,2]}
,"resources.bd/widget/messageBox":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/messageBox"],
src:
"bd/widget/messageBox",
modules:
["bd/widget/messageBox"],
code:
["dojo.def(\"bd/widget/messageBox\", [",
"  \"bd\",",
"  \"bd/widget/dialog\",",
"  \"bd/widget/staticText\",",
"  \"bd/dijit/button\"",
"], function(bd) {",
"///",
"// Defines the message box function.",
"",
"return bd.widget.messageBox= function(",
"  title,    ///(string) The title of the message box.",
"  message,  ///(string) The message to display in the message box.",
"  buttons,  ///(array of string, optional, [\"OK\"]) A set of bottons to display under the message.",
"  callback, ///(function(string)) The function to call when the dialog is dismissed by pressing one of the buttons.",
"  context,  ///(object, optional) Context in which to apply callback.",
"  vargs     ///(variableArgs, optional) Zero or more arguments for application of callback.",
") {",
"  ///",
"  // Displays a message box in the center of the viewport. //When one of the buttons is pressed, the callback is",
"  // applied to the text of the button; if the close button is pressed on the dialog, callback is applied to \"\".",
"  callback= callback && bd.hitchCallback(arguments, 3);",
"  var theDialog;",
"  bd.createWidget({descriptor:{",
"    className:\"bd:widget.dialog\",",
"    title:title,",
"    frameSize: {height:\"5em\", width:\"30em\"},",
"    sizeable: false,",
"    setFrameSize: function() {",
"      var h= 0, w= 0, buttonWidth= 0;",
"      // calculate the required height x width; find the biggest button",
"      bd.forEach(this.children, function(child, i) {",
"        var box= dojo.marginBox(child.domNode);",
"        if (box) {",
"          h= Math.max(h, box.t + box.h);",
"          w= Math.max(w, box.l + box.w);",
"          if (i) {",
"            dojo.contentBox(child.domNode.firstChild.firstChild);",
"            buttonWidth= Math.max(buttonWidth, box.w);",
"          }",
"        }",
"      });",
"      // set the dialog exactly big enough to contain the contents",
"      dojo.marginBox(this.containerNode, {h:h, w:w});",
"      // make all the buttons the same size...they look better this way.",
"      // note: we can\'t make them the same height because the dojo buttons",
"      // don\'t support this.",
"      // TODO: make a more-flexible button widget",
"      bd.forEach(this.children, function(child, i) {",
"        i && dojo.contentBox(child.domNode.firstChild.firstChild, {w:buttonWidth});",
"      });",
"    },",
"    onCancel: function(e) {",
"      this.endDialog(e);",
"      callback && callback(\"\");",
"    },",
"    children: [{",
"      className:\"bd:widget.staticText\",",
"      value:message,",
"      \"class\":\"bdMessageBoxText\"",
"    }].concat(bd.map(buttons || [\"OK\"], function(buttonText) {",
"      return {",
"        className:\'bd:dijit.button\',",
"        label:buttonText,",
"        \"class\":\"bdMessageBoxButton\",",
"        onClick:function() {",
"          this.parent.endDialog();",
"          callback && callback(buttonText);",
"        }",
"      };",
"    }))",
"  }}, function(dialog){ ",
"    theDialog= dialog;",
"    dialog.show();",
"    return theDialog;",
"  });",
"};",
"",
"});",
"// Copyright (c) 2006-2010, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.widget.messageBox":{
type:
Tfunction,
sdoc:
["Displays a message box in the center of the viewport. "],
ldoc:
["Displays a message box in the center of the viewport. When one of the buttons is pressed, the callback is\napplied to the text of the button; if the close button is pressed on the dialog, callback is applied to \"\"."],
params:
[["title",[["string",
["The title of the message box."]]]],
["message",[["string",
["The message to display in the message box."]]]],
["buttons",[["array of string, optional, [\"OK\"]",
["A set of bottons to display under the message."]]]],
["callback",[["function(string)",
["The function to call when the dialog is dismissed by pressing one of the buttons."]]]],
["context",[["object, optional",
["Context in which to apply callback."]]]],
["vargs",[["variableArgs, optional",
["Zero or more arguments for application of callback."]]]]],
src:
"bd/widget/messageBox",
loc: [9,7,75,1],
module:"bd/widget/messageBox"}
,"modules.bd/widget/messageBox":{
type:
Tmodule,
sdoc:
["Defines the message box function."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/widget/messageBox",
loc: [0,0,77,2]}
,"resources.bd/widget/pane":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/pane"],
src:
"bd/widget/pane",
modules:
["bd/widget/pane"],
code:
["dojo.def(\"bd/widget/pane\", [",
"  \"bd\",",
"  \"bd/visual\",",
"  \"bd/container\",",
"  \"bd/navigator\"",
"], function(bd) {",
"///",
"// Defines the bd.widget.pane class.",
"",
"return bd.declare(",
"  ///",
"  // A container that can hold and manage a set of children widgets. //The container is realized by. a DOM `form` element with",
"  // its `action` attribute set to `javascript:void(0)`.",
"",
"  //class name",
"  \"bd:widget.pane\",",
"",
"  //superclasses",
"  [bd.visual, bd.container, bd.navigator],",
"",
"  //members",
"  {",
"  initAttrs:",
"    {dir:1, lang:1, \"class\":1, style:1, title:1, tabIndex:1},",
"",
"  cssStatefulBases: ",
"    {dijitReset: 0, bdPane:1},",
"",
"  cssStatefulWatch: ",
"    {visible:0, disabled:0, readOnly:0, focused:0, hover:0},",
"",
"  tabIndex: ",
"    undefined,",
"",
"  createDom: function() {",
"    this.domNode= this.containerNode= dojo.create(\'form\', this.getCreateDomAttributes({id: this.id, widgetId: this.id, action:\"javascript:void(0)\"}));",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.widget.pane":{
type:
Tclass,
sdoc:
["A container that can hold and manage a set of children widgets. "],
ldoc:
["A container that can hold and manage a set of children widgets. The container is realized by. a DOM `form` element with\nits `action` attribute set to `javascript:void(0)`."],
src:
"bd/widget/pane",
loc: [9,7,37,2],
supers:
["bd.visual","bd.container","bd.navigator"],
module:"bd/widget/pane"}
,"modules.bd/widget/pane":{
type:
Tmodule,
sdoc:
["Defines the bd.widget.pane class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]]],
src:
"bd/widget/pane",
loc: [0,0,39,2]}
,"resources.bd/widget/radioGroup":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/radioGroup"],
src:
"bd/widget/radioGroup",
modules:
["bd/widget/radioGroup"],
code:
["dojo.def(\"bd/widget/radioGroup\", [",
"  \"bd\",",
"  \"dijit\",",
"  \"bd/css\",",
"  \"bd/visual\",",
"  \"bd/focusable\",",
"  \"bd/mouseable\",",
"  \"bd/container\"",
"], function(bd, dijit) {",
"///",
"// Defines the bd.widget.radioGroup class.",
"",
"bd.widget.radioButtonStyles= ",
"  ///namespace",
"  // Contains a set of descriptors that describe radio buttons that can be used with bd.widget.radioGroup",
"  bd.widget.radioButtonStyles || {};",
"",
"bd.widget.radioButtonStyles.standard=",
"  ///",
"  // A radio button that looks like a dot in a circle.",
"  {",
"    className:\"bd:widget.checkBox\",",
"    cssStatefulBases: {dijitReset: 0, bdRadioChoice:1},",
"    checkBox: {",
"      cssStatefulBases:{bdRadioButton:0},",
"      value:false,",
"      sequence: [[false, \"\", \"unpushed\"], [true, \"\", \"pushed\"]],",
"      onClick: function() {",
"        this.set(\"value\", true);",
"        this.domNode.focus();",
"      }",
"    }",
"  };",
"",
"return bd.declare(",
"  ///",
"  // An optionally-labeled container that can hold, manage, and layout a set of radio buttons.",
"",
"  //class name",
"  \"bd:widget.radioGroup\",",
"",
"  //superclasses",
"  [bd.visual, bd.focusable, bd.mouseable, bd.container],",
"",
"  //members",
"  bd.attr(",
"    ///",
"    // The text of the label.",
"    ///",
"    //(string, optional, \"\") The text of the label.",
"",
"    \"label\",",
"  ",
"    \"\", //initial value",
"",
"    function(value) {",
"      var oldValue= this.label;",
"      if (value!==oldValue) {",
"        this.label= value;",
"        if (this.domNode) {",
"          this.domNode.firstChild.innerHTML= newValue;",
"          this.layout();",
"        }",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // The position of the label with respect to the box given by the attribute `labelRefBox`.",
"    ///",
"    //(bd.css.cornerPosit, optional, \"tl-tl\") The position of the label with respect to the box given by the attribute `labelRefBox`.",
"",
"    \"labelPosit\",",
"",
"    \"tl-tl\", //initial value",
"",
"    function(value) { //setter",
"      var oldValue= this.posit;",
"      if (value!==oldValue) {",
"        this.posit= value;",
"        this.layout();",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // The reference box to use when positioning the label.",
"    ///",
"    //(bd.css.abbreviatedBox) The reference box to use when positioning the label.",
"    //(falsy, default) Use the margin box for `this.domNode` for the reference box to use when positioning the label.",
"",
"    \"labelRefBox\",",
"",
"    0, //initial value",
"",
"    function(value) { //setter",
"      var oldValue= this.labelRefBox;",
"      if (value!==oldValue) {",
"        this.labelRefBox= value;",
"        this.layout();",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // The value of the DOM class attribute for the label DOM node. //The label",
"    // node will unconditionally contain the class \"bdLabel\".",
"    ///",
"    //(string, optional, \"\") The value of the DOM class attribute for the label DOM node.",
"",
"    \"labelClass\",",
"    0, //initial value",
"",
"    function(value) { //setter",
"      var oldValue= this.labelClass;",
"      if (oldValue!==value) {",
"        this.labelClass= value;",
"        if (this.domNode) {",
"          var node= this.domNode.firstChild;",
"          bd.forEach(oldValue.split(\" \"), function(className) {",
"            className && dojo.removeClass(node, className);",
"          });",
"          bd.forEach(newValue.split(\" \"), function(className) {",
"            className && dojo.addClass(node, className);",
"          });",
"          this.layout();",
"        }",
"      }",
"    }",
"  ),",
"",
"  bd.attr( ",
"    ///",
"    // An ordered set of (label, value) that gives the label and value for each button.",
"    ///",
"    //(array of [string, any]) Gives the ordered set of (value, label) for each radio button.",
"    ",
"    \"buttons\",",
"",
"    []",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Gives the the descriptor to use to create individual radio buttons.",
"    ///",
"    //(bd.descriptor, optional, bd.widget.radioGroup.type1) Gives the the descriptor to use to create individual radio buttons.",
"    ",
"    \"bStyle\",",
"",
"    bd.widget.radioButtonStyles.standard //default value",
"  ),",
"",
"  bd.attr(",
"    ///",
"    //(boolean) true if the widget is disabled; false otherwise.",
"    ///",
"    // Overrides the bd.focusabe.disabled setter to provide for causes all contained radio buttons to be disabled.    ",
"    \"disabled\",",
"",
"    false, //default value",
"",
"    function(value) { //setter",
"      var oldValue= this.inherited(arguments);",
"      if (value && !this.disabledCurtain) {",
"        this.disabledCurtain= dojo.create(\"div\", {\"class\":\"bdDisabledCurtain\"}, this.domNode, \"first\");",
"      } else if (this.disabledCurtain) {",
"        dojo.destroy(this.disabledCurtain);",
"        delete this.disabledCurtain;",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.constAttr(",
"    ///",
"    //(boolean) true if this widget can receive the focus; false otherwise. ",
"    ///",
"    // Indicates whether or not this object can recieve the focus.",
"    ///",
"    // The default calculation requires the object must be visible, not disabled, and have a tabIndex value defined",
"    // in order to receive the focus.",
"",
"//TODO: ensure that all inherited function use the same short descriptions (and long descriptions if applicable)",
"//      maybe say \"use the inherited text, plus some notes\" via the doc generator.",
"",
"    \"focusable\", ",
"",
"    bd.noValue, // The value is always calculated, never stored.",
"",
"    function() { //getter",
"      if (this.inherited(arguments)) {",
"        for (var children= this.children, i= 0, end= children.length; i<end; i++) {",
"          if (children[i].get(\"focusable\")) {",
"            return true;",
"          }",
"        }",
"      }",
"      return false;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Holds current value of the widget as given by the pressed radio button.",
"    ///",
"    //(any) The value of the pressed radio button.",
"    //(undefined) No radio button is pressed.",
"",
"    \"value\",",
"",
"    undefined, //default value",
"",
"    function( //setter",
"      value",
"    ) {",
"      this.ignoreStateDelta= true;",
"      var oldValue= this.value;",
"      this.value= value;",
"      for (var child, children= this.children, i= 0, end= children.length; i<end; i++) {",
"        children[i].set(\"value\", this.buttons[i][0]===value);",
"      }",
"      delete this.ignoreStateDelta;",
"      return oldValue;",
"    }",
"  ),",
"",
"",
"  bd.attr(",
"    ///",
"    // Specifies how to position the radio buttons. //The first character says where to position the",
"    // radio buttons relative to the label:",
"    // ",
"    // * \"t\" causes the buttons to be placed above the label.",
"    // * \"b\" causes the buttons to be placed below the label.",
"    // * \"l\" causes the buttons to be placed to the left of the label.",
"    // * \"r\" causes the buttons to be placed to the right of the label.",
"    ///",
"    //(/(t|b|l|r)\\-(column|row)/, optional, \"b-column\") Specifies how to position the radio buttons.",
"    //(otherwise) Do not position the radio buttons.",
"",
"    \"format\",",
"",
"    \"b-column\" //default value",
"  ),",
"",
"  bd.makeDeferredConnects(",
"    ///",
"    // Declares connection points.",
"    0, bd.visual, bd.focusable, bd.mouseable, bd.container",
"  ),",
"",
"  {",
"  initAttrs:",
"    {dir:1, lang:1, \"class\":1, style:1, title:1, tabIndex:1},",
"",
"  cssStatefulBases: ",
"    {dijitReset: 0, bdRadioGroup:1},",
"",
"  cssStatefulWatch: ",
"    {visible:0, disabled:0, focused:0, hover:0},",
"",
"  precreateDom: function() {",
"    this.inherited(arguments);",
"    this.arrangement= this.arrangement || \"column\";",
"    if (bd.isString(this.bStyle)) {",
"      this.bStyle= bd.get(this.bStyle);",
"    }",
"    this.bStyle= this.bStyle || bd.widget.radioGroup.type1;",
"  },",
"",
"  getCreateDomAttributes: function(",
"     attributes",
"  ) {",
"    attributes= this.inherited(arguments);",
"    attributes.innerHTML= \"<div class=\\\"bdLabel\" + (this.labelClass ? (\" \" + this.labelClass) : \"\") + \"\\\">\" + this.label + \"</div>\";",
"    return attributes;",
"  },",
"",
"  loadChildren: function(",
"    onCreates",
"  ) {",
"    ///",
"    // Creates all radio buttons mentioned in the `buttons` attibute.",
"    var ",
"      me= this,",
"      deferred= 0,",
"      createChild= function(childDescriptor, i) {",
"         return bd.createWidget(",
"          {parent:me, descriptor:childDescriptor},",
"           function(child) {",
"             me.children[i]= child;",
"           },",
"           onCreates",
"         );",
"      };",
"    bd.forEach(me.buttons, function(buttonInfo, i) {",
"      var result= createChild(bd.mix({}, me.bStyle, {label: buttonInfo[1], value:false}), i);",
"      if (result instanceof bd.Deferred) {",
"        if (deferred) {",
"          //JavaScript\'s lack of proper lexical scoping causes this ugliness...",
"          deferred.addCallback((function(result){ return function() { return result; };})(result));",
"        } else {",
"          deferred= result;",
"        }",
"      }",
"    });",
"    var finish= function() {",
"      for (var child, value= me.value, children= me.children, i= 0; i<children.length; i++) {",
"        child= children[i];",
"        child.set(\"value\", me.buttons[i][0]===value);",
"        child.watch(\"value\", \"stateDelta\", me, i);",
"      }",
"    };",
"    if (deferred) {",
"      deferred.addCallback(finish);",
"    } else {",
"      finish();",
"    }",
"    return deferred;",
"  },",
"",
"  addChild: function(",
"    child",
"  ) {",
"    dojo.place(child.domNode, this.domNode);",
"    this.started && bd.startupChild(child);",
"  },",
"",
"  _focus: function() {",
"    dojo.window.scrollIntoView(this.domNode);",
"    for (var children= this.children, i= 0, end= children.length; i<end; i++) {",
"      if (children[i].get(\"focusable\")) {",
"        children[i].focus();",
"        return;",
"      }",
"    }",
"  },",
"",
"  onFocus: function(by) {",
"    ///",
"    // Connection point for receiving the focus. //Nontrivial handler that simple passes focus to the first focusable radio button.",
"    if (this.focusableGet()) {",
"      //if getting the focus by clicking on the container but not the contained widget, then delegate to the contained widget...",
"      bd.back(dijit._activeStack)===this.id && this._focus();",
"    } else {",
"      //should never get here; ping the parent in hopes that it will take our focus away",
"      this.parent.focus();",
"    }",
"  },",
"",
"  focus: function() {",
"    ///",
"    // Sets the focus to the first focusable radio button iff `this.get(\"focusable\")` returns true.",
"    //warn",
"    // In general, focus is set asynchronously. This ensures focus will be set correctly under all circumstances",
"    // (e.g., from a blur event handler); however, the focus will not have moved before this",
"    // function returns.",
"    if (this.focusableGet()) {",
"      this._focus();",
"    } else {",
"      //should never get here; ping the parent in hopes that it will take our focus away",
"      this.parent.focus();",
"    }",
"  },",
"",
"  onKeyPress: function(e) {",
"    ///",
"    // Connection point for keypress event. //Nontrivial connection point that cycles the focus among the ",
"    // focusable radio buttons if the arrow keys are pressed.",
"    if (this.disabled || !this.focused) {",
"      return;",
"    }",
"    for (var children= this.children, i= 0, end= children.length; i<end && !children[i].get(\"focused\"); i++);",
"    var ",
"      inc= function() {",
"        i= (i==end-1 ? 0 : i+1);",
"      },",
"      dec= function() {",
"        i= (i==0 ? end-1 : i-1);",
"      },",
"      next= inc,",
"      current= i;",
"    switch (e.keyCode) {",
"      case dojo.keys.UP_ARROW:",
"      case dojo.keys.LEFT_ARROW:",
"        next= dec;",
"        //fall through...",
"      ",
"      case dojo.keys.DOWN_ARROW:",
"      case dojo.keys.RIGHT_ARROW:",
"        if (i==end) {",
"          //nothing was current; cause the algorithm to start looking at the first button",
"          //and look for the next button, independent of what arrow key was actually pressed",
"          i= current= end - 1;",
"          next= inc;",
"        }",
"        next();",
"        while (!children[i].get(\"focusable\") && i!==current) next();",
"        children[i].focus();",
"        dojo.stopEvent(e);",
"        break;",
"    }",
"  },",
"",
"  stateDelta: function(",
"    index,",
"    value",
"  ) {",
"    //catches and processes changes in the `value` attribute of any contained button",
"    if (this.ignoreStateDelta) {",
"      return;",
"    }",
"    this.set(\"value\", value ? this.buttons[index][0] : undefined);",
"  },",
"",
"  layout: function(height, width) {",
"    ///",
"    // Positions all contained buttons and the label iff a valid `format` attribute exists. //The label ",
"    // is positioned and the available content box of the top DOM node is clipped to remove the area occupied",
"    // by the label as given by the `format` attribute. The radio buttons are then arranged in a single column (if the `arrangement` ",
"    // attribute is \"column\"), a single row otherwise.",
"",
"    if (!this.started) {",
"      return 0;",
"    }",
"    var ",
"      quadrant, arrangment,",
"      domNode= this.domNode,",
"      mb= bd.mix(dojo.contentBox(domNode), {t:0, l:0}),",
"      match= this.format.toLowerCase().match(/(t|b|l|r)\\-(column|row)/);",
"    if (match) {",
"      quadrant= match[1];",
"      arrangment= match[2];",
"    } else {",
"      return mb;",
"    }",
"",
"    var",
"      buttonBox, available, childCount, chunk, remainder, labelBox,",
"      label= this.label.length && this.label,",
"      labelNode= label && this.domNode.firstChild,",
"      labelPosit= label && this.labelPosit.toLowerCase();",
"    if (!/(t|c|b)(l|c|r)\\-(t|c|b)(l|c|r)/.test(labelPosit)) {",
"      labelPosit= 0;",
"    }",
"    if (label && labelPosit) {",
"      dojo.style(labelNode, {position:\"absolute\"});",
"      labelBox= dojo.marginBox(labelNode);",
"      labelBox.t= bd.css.cornerCalculators.getTop(labelPosit, labelBox, mb);",
"      labelBox.l= bd.css.cornerCalculators.getLeft(labelPosit, labelBox, mb);",
"      dojo.marginBox(labelNode, labelBox);",
"    }",
"    buttonBox= {t: mb.t, l:mb.l, h:mb.h, w:mb.w};",
"    if (labelBox) switch (quadrant) {",
"      case \"t\": buttonBox.h= labelBox.t; break;",
"      case \"b\": buttonBox.t= labelBox.t + labelBox.h; buttonBox.h= buttonBox.h - buttonBox.t; break;",
"      case \"l\": buttonBox.w= labelBox.l; break;",
"      case \"r\": buttonBox.l= labelBox.l + labelBox.w; buttonBox.w= buttonBox.w - buttonBox.l; break;",
"    }",
"    childCount= this.children.length;",
"    available= (arrangment==\"column\" ? buttonBox.h : buttonBox.w) - childCount;",
"    chunk= Math.floor(available / childCount);",
"    remainder= available % childCount;",
"    remainder && chunk++;",
"    if (arrangment==\"column\") {",
"      buttonBox.h= chunk;",
"    } else {",
"      buttonBox.w= chunk;",
"    }",
"    bd.forEach(this.children, function(child) {",
"      dojo.marginBox(child.domNode, buttonBox);",
"      child.layout(buttonBox.h, buttonBox.w);",
"      if (arrangment==\"column\") {",
"        buttonBox.t+= chunk + 1;",
"      } else {",
"        buttonBox.l+= chunk + 1;",
"      }",
"      if (remainder==1) {",
"        //just used up the last extra pixel",
"        chunk--;",
"        if (arrangment==\"column\") {",
"          buttonBox.h--;",
"        } else {",
"          buttonBox.l--;",
"        }",
"      }",
"      remainder--;",
"    });",
"    return mb;",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.widget.radioButtonStyles":{
type:
Tnamespace,
sdoc:
["Contains a set of descriptors that describe radio buttons that can be used with bd.widget.radioGroup"],
ldoc:
[],
src:
"bd/widget/radioGroup",
loc: [12,0,15,35],
module:"bd/widget/radioGroup"}
,"bd.widget.radioButtonStyles.standard":{
type:
Tvariable,
sdoc:
["A radio button that looks like a dot in a circle."],
ldoc:
[],
src:
"bd/widget/radioGroup",
loc: [17,0,32,3],
module:"bd/widget/radioGroup"}
,"bd.widget.radioGroup":{
type:
Tclass,
sdoc:
["An optionally-labeled container that can hold, manage, and layout a set of radio buttons."],
ldoc:
[],
src:
"bd/widget/radioGroup",
loc: [34,7,497,2],
supers:
["bd.visual","bd.focusable","bd.mouseable","bd.container"],
module:"bd/widget/radioGroup"}
,"bd.widget.radioGroup.deferredConnects":{
type:
Tvariable,
sdoc:
["Declares connection points."],
imember:1,
ldoc:
[],
loc: [252,2,256,3]}
,"bd.widget.radioGroup.format":{
type:
Tvariable,
sdoc:
["Specifies how to position the radio buttons. "],
imember:1,
ldoc:
["Specifies how to position the radio buttons. The first character says where to position the\nradio buttons relative to the label:\n\n* \"t\" causes the buttons to be placed above the label.\n* \"b\" causes the buttons to be placed below the label.\n* \"l\" causes the buttons to be placed to the left of the label.\n* \"r\" causes the buttons to be placed to the right of the label."],
flags:
[Fattr],
loc: [234,2,250,3],
types:
[["/(t|b|l|r)\\-(column|row)/, optional, \"b-column\"",
["Specifies how to position the radio buttons."]],
["otherwise",
["Do not position the radio buttons."]]]}
,"bd.widget.radioGroup.value":{
type:
Tvariable,
sdoc:
["Holds current value of the widget as given by the pressed radio button."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [208,2,231,3],
types:
[["any",
["The value of the pressed radio button."]],
["undefined",
["No radio button is pressed."]]]}
,"bd.widget.radioGroup.focusable":{
type:
Tvariable,
sdoc:
["Indicates whether or not this object can recieve the focus."],
imember:1,
ldoc:
["The default calculation requires the object must be visible, not disabled, and have a tabIndex value defined\nin order to receive the focus."],
flags:
[Froattr],
loc: [180,2,206,3],
types:
[["boolean",
["true if this widget can receive the focus; false otherwise."]]]}
,"bd.widget.radioGroup.disabled":{
type:
Tvariable,
sdoc:
["Overrides the bd.focusabe.disabled setter to provide for causes all contained radio buttons to be disabled."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [159,2,178,3],
types:
[["boolean",
["true if the widget is disabled; false otherwise."]]]}
,"bd.widget.radioGroup.bStyle":{
type:
Tvariable,
sdoc:
["Gives the the descriptor to use to create individual radio buttons."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [148,2,157,3],
types:
[["bd.descriptor, optional, bd.widget.radioGroup.type1",
["Gives the the descriptor to use to create individual radio buttons."]]]}
,"bd.widget.radioGroup.buttons":{
type:
Tvariable,
sdoc:
["An ordered set of (label, value) that gives the label and value for each button."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [137,2,146,3],
types:
[["array of [string, any]",
["Gives the ordered set of (value, label) for each radio button."]]]}
,"bd.widget.radioGroup.labelClass":{
type:
Tvariable,
sdoc:
["The value of the DOM class attribute for the label DOM node. "],
imember:1,
ldoc:
["The value of the DOM class attribute for the label DOM node. The label\nnode will unconditionally contain the class \"bdLabel\"."],
flags:
[Fattr],
loc: [109,2,135,3],
types:
[["string, optional, \"\"",
["The value of the DOM class attribute for the label DOM node."]]]}
,"bd.widget.radioGroup.labelRefBox":{
type:
Tvariable,
sdoc:
["The reference box to use when positioning the label."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [88,2,107,3],
types:
[["bd.css.abbreviatedBox",
["The reference box to use when positioning the label."]],
["falsy, default",
["Use the margin box for `this.domNode` for the reference box to use when positioning the label."]]]}
,"bd.widget.radioGroup.labelPosit":{
type:
Tvariable,
sdoc:
["The position of the label with respect to the box given by the attribute `labelRefBox`."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [68,2,86,3],
types:
[["bd.css.cornerPosit, optional, \"tl-tl\"",
["The position of the label with respect to the box given by the attribute `labelRefBox`."]]]}
,"bd.widget.radioGroup.label":{
type:
Tvariable,
sdoc:
["The text of the label."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [45,2,66,3],
types:
[["string, optional, \"\"",
["The text of the label."]]]}
,"bd.widget.radioGroup.loadChildren":{
type:
Tfunction,
sdoc:
["Creates all radio buttons mentioned in the `buttons` attibute."],
imember:1,
ldoc:
[],
params:
[["onCreates",[]]],
loc: [285,2,326,3]}
,"bd.widget.radioGroup.onFocus":{
type:
Tfunction,
sdoc:
["Connection point for receiving the focus. "],
imember:1,
ldoc:
["Connection point for receiving the focus. Nontrivial handler that simple passes focus to the first focusable radio button."],
params:
[["by",[]]],
loc: [345,2,355,3]}
,"bd.widget.radioGroup.focus":{
type:
Tfunction,
sdoc:
["Sets the focus to the first focusable radio button iff `this.get(\"focusable\")` returns true."],
imember:1,
ldoc:
[[WARN,"In general, focus is set asynchronously. This ensures focus will be set correctly under all circumstances\n(e.g., from a blur event handler); however, the focus will not have moved before this\nfunction returns."]],
loc: [357,2,370,3]}
,"bd.widget.radioGroup.onKeyPress":{
type:
Tfunction,
sdoc:
["Connection point for keypress event. "],
imember:1,
ldoc:
["Connection point for keypress event. Nontrivial connection point that cycles the focus among the\nfocusable radio buttons if the arrow keys are pressed."],
params:
[["e",[]]],
loc: [372,2,409,3]}
,"bd.widget.radioGroup.layout":{
type:
Tfunction,
sdoc:
["Positions all contained buttons and the label iff a valid `format` attribute exists. "],
imember:1,
ldoc:
["Positions all contained buttons and the label iff a valid `format` attribute exists. The label\nis positioned and the available content box of the top DOM node is clipped to remove the area occupied\nby the label as given by the `format` attribute. The radio buttons are then arranged in a single column (if the `arrangement`\nattribute is \"column\"), a single row otherwise."],
params:
[["height",[]],
["width",[]]],
loc: [422,2,496,3]}
,"modules.bd/widget/radioGroup":{
type:
Tmodule,
sdoc:
["Defines the bd.widget.radioGroup class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dijit",[]]],
src:
"bd/widget/radioGroup",
loc: [0,0,499,2]}
,"resources.bd/widget/root":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/root"],
src:
"bd/widget/root",
modules:
["bd/widget/root"],
code:
["dojo.def(\"bd/widget/root\", [",
"  \"bd\", \"dojo\",",
"  \"bd/stateful\",",
"  \"bd/connectable\",",
"  \"bd/container\",",
"  \"bd/async\"",
"], function(bd, dojo) {",
"///",
"// Defines the bd.widget.root class.",
"",
"return bd.declare(",
"  ///",
"  // A container that attaches to the body element that can hold and manager a set of children widgets. //Typically, a single instance of",
"  // bd.widget.root functions as the top-level container for a Backdraft application. ",
"  // ",
"  // The class calls layout on all of its children whenever it detects a document resize event.",
"  // ",
"  // The class includes the method bd.widget.root.destroyLoadingMessage that removes the subtree rooted at the element with the DOM `id` attribute \"bdLoading\". ",
"  // Such a subtree can be used to hold a user pacifier while an application is loading.",
"  // ",
"  // Notice that since this widget class always attaches to the `body` element, there will be at most one instance of this class",
"  // present in an application. By default, the `id` attribute is set to \"root\", but this may be set changed by providing an",
"  // `id` property in the creating descriptor.",
"  // ",
"  // Upon construction, the DOM document resize event is watched and any resize events are delegated to all children (via the method `layout`) as well",
"  // as published to the topic \"bd/viewportResize\". See bd.widget.root.onResize.",
"  //",
"  \"bd:widget.root\",",
"",
"  [bd.stateful, bd.connectable, bd.container], ",
"",
"  {",
"  constructor: function(",
"    kwargs",
"  ) {",
"    // this widget does not include bd.createable; therefore, it must orchestrate its own initialization...",
"    this.kwargs= kwargs;",
"    bd.mix(this, kwargs);",
"    bd.mix(this, kwargs.descriptor);",
"    this.id= this.id || \"root\";",
"    bd.object.set(this);     ",
"    this.domNode= this.containerNode= dojo.body();",
"    this.domNode.id= this.id;",
"    //required for bd.connectable",
"    this.postcreateDom();",
"    bd.connect(bd.global, \'onresize\', \'resize\', this);",
"    this.started= true;",
"  },",
"",
"  destroyLoadingMessage:function() {",
"    dojo._destroyElement(dojo.byId(\"bdLoading\"));",
"  },",
"",
"  resize: function() {",
"    bd.async.schedule(\"last\", \"onResize\", this);",
"  },",
"",
"  onResize: function() {",
"    ///",
"    // Nontrivial connection point that watches the DOM resize event on the document. //Queries the body node for",
"    // its margin box and passes the new size to all children as well as publishes the topic \"bd/viewportResize\" with",
"    // a single object argument that contains the height and width of the new viewport size in pixels at`h` and `w`.",
"    var mb= dojo.marginBox(this.domNode);",
"    bd.forEach(this.children, function(child) {",
"      child.layout(mb.h, mb.w);",
"    });",
"    dojo.publish(\"bd/viewportResize\", [mb]);",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.widget.root":{
type:
Tclass,
sdoc:
["A container that attaches to the body element that can hold and manager a set of children widgets. "],
ldoc:
["A container that attaches to the body element that can hold and manager a set of children widgets. Typically, a single instance of\nbd.widget.root functions as the top-level container for a Backdraft application.\n\nThe class calls layout on all of its children whenever it detects a document resize event.\n\nThe class includes the method bd.widget.root.destroyLoadingMessage that removes the subtree rooted at the element with the DOM `id` attribute \"bdLoading\".\nSuch a subtree can be used to hold a user pacifier while an application is loading.\n\nNotice that since this widget class always attaches to the `body` element, there will be at most one instance of this class\npresent in an application. By default, the `id` attribute is set to \"root\", but this may be set changed by providing an\n`id` property in the creating descriptor.\n\nUpon construction, the DOM document resize event is watched and any resize events are delegated to all children (via the method `layout`) as well\nas published to the topic \"bd/viewportResize\". See bd.widget.root.onResize."],
src:
"bd/widget/root",
loc: [10,7,68,2],
supers:
["bd.stateful","bd.connectable","bd.container"],
module:"bd/widget/root"}
,"bd.widget.root.onResize":{
type:
Tfunction,
sdoc:
["Nontrivial connection point that watches the DOM resize event on the document. "],
imember:1,
ldoc:
["Nontrivial connection point that watches the DOM resize event on the document. Queries the body node for\nits margin box and passes the new size to all children as well as publishes the topic \"bd/viewportResize\" with\na single object argument that contains the height and width of the new viewport size in pixels at`h` and `w`."],
loc: [57,2,67,3]}
,"modules.bd/widget/root":{
type:
Tmodule,
sdoc:
["Defines the bd.widget.root class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/widget/root",
loc: [0,0,70,2]}
,"resources.bd/widget/stateButton":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/stateButton"],
src:
"bd/widget/stateButton",
modules:
["bd/widget/stateButton"],
docLocs:
[[24,41]],
code:
["dojo.def(\"bd/widget/stateButton\", [",
"  \"bd\",",
"  \"dojo\", ",
"  \"bd/widget/staticText\",",
"  \"bd/mouseable\",",
"  \"bd/focusable\"",
"], function(bd, dojo) {",
"///",
"// Defines the bd.widget.stateButton class.",
"",
"",
"bd.widget.stateButton= {};",
"",
"bd.widget.stateButton.advance= ",
"  ///const",
"  // Unique object with no properties that may be used with bd.widget.stateButton.keys to signal advance one state.",
"  {};",
"",
"bd.widget.stateButton.reset= ",
"  ///const",
"  // Unique object with no properties that may be used with bd.widget.stateButton.keys to set the value to the first state.",
"  {};",
"",
"",
"bd.docGen(\"bd.widget.stateButton\", {",
"  \"info\":",
"    ///type",
"    // An array of one, two, or three elements or a single non-array that gives value and display information for a single state",
"    // in a bd.widget.stateButton instance.",
"    ///",
"    // The first element in the array always gives the value of a state.",
"    // ",
"    // The second element in the array, a string, gives the text to display for the state. If this element is missing (i.e., the",
"    // array has length of one), then the empty string is assumed.",
"    // ",
"    // The third element in the array, a string, gives the CSS class to add to the DOM class attribute of the widget\'s DOM node for",
"    // the state. If this element is missing (i.e., the array has length less than three), then it is assumed to be the string",
"    // `\"state\"``i``` for the i\'th state.",
"    //",
"    // See bd.widget.stateButton.sequence",
"    0",
"});",
"",
"",
"bd.declare(",
"  ///",
"  // An interactive widget that cycles among an ordered set of values. //The legal set of values, their",
"  // order, a string associated with each value (termed the \"value-text\"), and a CSS string to add to the",
"  // DOM class attribute for each value is given by the attribute `sequence`. The",
"  // value-text associated with each value need not be unique and may be empty.",
"  // ",
"  // Typically, the value is changed by clicking on the widget or pressing the space bar while the widget has",
"  // the focus. ",
"  // ",
"  // Since the widget is connected to bd.cssStateful and further since `cssStatefulWatch`",
"  // includes the `cssState` attribute, it is a simple matter to configure a CSS style sheet",
"  // that changes the appearance of a widget instance based on its value. Typical examples are ",
"  // changing the background image (e.g., a checked or unchecked image), changing",
"  // the background color, or changing the text.",
"  // ",
"  // Notice that the class is derived from bd.widget.staticText. If the current value has",
"  // a non-empty value-text as per the `sequence` attribute, then the `text` attribute",
"  // is set accordingly.",
"  // ",
"  // Finally, the attribute `keys` gives a map from character codes as received from DOM keyboard ",
"  // `keypress` events to values. These may be viewed as accelerators to particular values",
"  // when a particular instance has the focus.",
"",
"  //class name",
"  \"bd:widget.stateButton\",",
"",
"  //superclasses",
"  [bd.widget.staticText, bd.focusable, bd.mouseable],",
"",
"  //members",
"  bd.attr(",
"    ///",
"    // The ordered set of possible values and optional display information.",
"    ///",
"    //(array of bd.widget.stateButton.info, optional, [[false, \"\", \"unchecked\"], [true, \"\", \"checked\"]]) Gives the",
"    // set of possible (value, value-text, CSS-text) in the order they transition.",
"    //",
"    \"sequence\",",
"",
"    [[false, \"\"], [true, \"\"]], //default value ",
"",
"    function( //setter",
"      value",
"    ) {",
"      var oldValue= this.sequence;",
"      this.sequence= bd.map(value, function(item) {",
"        if (bd.isArray(item)) {",
"          return [item[0], (item[1] ? item[1]+\"\" : \"\"), (item[2] ? item[2]+\"\" : 0)];",
"        } else {",
"          return [item, \"\", 0];",
"        }",
"      });",
"      this.set(\"value\", this.value);",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // Maps charCodes as received from a keypress event to a value. //Mapping to bd.widget.stateButton.reset",
"    // causes the key to set the value to the first state; mapping to bd.widget.stateButton.advance causes ",
"    // the key to behave like a mouse click and transition the state to the next state.",
"    ///",
"    // (map:charCode --> value, optional, see code for default) Maps charCodes as received from a DOM `keypress` event to a value.",
"",
"    \"keys\",",
"",
"    (function() { //default value",
"      var result= [];",
"      result[dojo.keys.ESCAPE]= bd.widget.stateButton.reset;",
"      result[dojo.keys.SPACE]= bd.widget.stateButton.advance;",
"      return result;",
"    })()",
"  ),",
"",
"  bd.attr(",
"    ///",
"    // The current value of the widget. Must be a value from the `sequence` attribute or undefined; attempting to set",
"    // an illegal value is equivalent to setting the value to undefined.",
"    //",
"    //(value from the `sequence` attribute, optional, undefined) The current value of the widget.",
"",
"    \"value\",",
"",
"    undefined, //default value",
"",
"    function( //setter",
"      value",
"    ) {",
"      var ",
"        oldValue= this.value,",
"        oldCssState= this.cssState;",
"      for (var sequence= this.sequence, i= 0, end= sequence.length; i<end; i++) {",
"        if (value===sequence[i][0]) {",
"          this.value= value;",
"          this.domNode && (this.domNode.innerHTML= sequence[i][1]);",
"          this.cssState= sequence[i][2] || \"state\"+i;",
"          break;",
"        }",
"      }",
"      if (i==end) {",
"        //never found value",
"        this.value= sequence[0][0];",
"        this.domNode && (this.domNode.innerHTML= sequence[0][1]);",
"        this.cssState= sequence[0][2] || \"state0\";",
"      }",
"      if (this.cssState!==oldCssState) {",
"        this.adviseWatchers(\"cssState\", oldCssState, this.cssState);",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  bd.constAttr(",
"    ///",
"    // The current string to add to the DOM class attibute that reflects the current value. //By separating",
"    // the value domain from the domain of strings that reflect the value in the DOM class attribute, the widget",
"    // can accept values on any domain (e.g., {true, false} or some set of objects) while still using CSS class",
"    // to paint the visual presentation of the state button as a function of value. For example, by default,",
"    // checkbox defines the values {true, false} and reflects these values in the DOM class attribute as {\"checked\",",
"    // \"unchecked\"} via bd.cssStateful.",
"",
"    \"cssState\",",
"",
"    bd.noValue, // The value is always calculated, never stored.",
"",
"    function() { //getter",
"      return this.cssState;",
"    }",
"  ),",
"",
"  bd.makeDeferredConnects(",
"    ///",
"    // Declares connection points.",
"    {},",
"    bd.visual, bd.focusable, bd.mouseable",
"  ),",
"",
"  {",
"  initAttrs:",
"    {dir:1, lang:1, \"class\":1, style:1, title:1, tabIndex:1},",
"",
"  cssStatefulBases: ",
"    {bdStateButton:1},",
"",
"  cssStatefulWatch: ",
"    {visible:0, disabled:0, focused:0, hover:0, cssState:0},",
"",
"  createDom: function() {",
"    this.inherited(arguments);",
"    this.focusNode= this.domNode;",
"    if (this.set(\"value\", this.value)===bd.failed) {",
"      this.set(\"value\", this.sequence[0][0]);",
"    }",
"  },",
"",
"  moveState: function() {",
"    var sequence= this.sequence, i= 0, end= sequence.length;",
"    while (i<end && sequence[i][0]!==this.value) {",
"      i++;",
"    }",
"    if (i==end || i==end-1 || end<2) {",
"      this.set(\"value\", sequence[0][0]);",
"    } else {",
"      this.set(\"value\", sequence[i+1][0]);",
"    }",
"  },",
"",
"  onClick: function(e) {",
"    ///",
"    // Nontrivial connection point that causes the state to move one position upon detecting a user click.",
"    if (this.disabled) {",
"      return;",
"    }",
"    this.moveState();",
"    this.domNode.focus();",
"  },",
"",
"  onKeyPress: function(e) {",
"    ///",
"    // Nontrivial connection point that inspects a keypress for possible action as given by the",
"    // `keys` attribute.",
"    if (this.disabled) {",
"      return;",
"    }",
"    var code= e.charCode;",
"    if (this.keys[code]===bd.widget.stateButton.advance) {",
"      this.moveState();",
"    } else if (this.keys[code]===bd.widget.stateButton.reset) {",
"      this.set(\"value\", sequence[0][0]);",
"    } else if (this.keys[code]!==undefined) {",
"      this.set(\"value\", this.keys[code]);",
"    }",
"  }",
"});",
"",
"return bd.widget.stateButton;",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.widget.stateButton.advance":{
type:
Tconst,
sdoc:
["Unique object with no properties that may be used with bd.widget.stateButton.keys to signal advance one state."],
ldoc:
[],
src:
"bd/widget/stateButton",
loc: [13,0,16,4],
module:"bd/widget/stateButton"}
,"bd.widget.stateButton.reset":{
type:
Tconst,
sdoc:
["Unique object with no properties that may be used with bd.widget.stateButton.keys to set the value to the first state."],
ldoc:
[],
src:
"bd/widget/stateButton",
loc: [18,0,21,4],
module:"bd/widget/stateButton"}
,"bd.widget.stateButton.info":{
type:
Ttype,
sdoc:
["An array of one, two, or three elements or a single non-array that gives value and display information for a single state\nin a bd.widget.stateButton instance."],
ldoc:
["The first element in the array always gives the value of a state.\n\nThe second element in the array, a string, gives the text to display for the state. If this element is missing (i.e., the\narray has length of one), then the empty string is assumed.\n\nThe third element in the array, a string, gives the CSS class to add to the DOM class attribute of the widget\'s DOM node for\nthe state. If this element is missing (i.e., the array has length less than three), then it is assumed to be the string\n`\"state\"``i``` for the i\'th state.\n\nSee bd.widget.stateButton.sequence"],
src:
"bd/widget/stateButton",
loc: [25,2,40,5],
module:"bd/widget/stateButton"}
,"bd.widget.stateButton":{
type:
Tclass,
sdoc:
["An interactive widget that cycles among an ordered set of values. "],
ldoc:
["An interactive widget that cycles among an ordered set of values. The legal set of values, their\norder, a string associated with each value (termed the \"value-text\"), and a CSS string to add to the\nDOM class attribute for each value is given by the attribute `sequence`. The\nvalue-text associated with each value need not be unique and may be empty.\n\nTypically, the value is changed by clicking on the widget or pressing the space bar while the widget has\nthe focus.\n\nSince the widget is connected to bd.cssStateful and further since `cssStatefulWatch`\nincludes the `cssState` attribute, it is a simple matter to configure a CSS style sheet\nthat changes the appearance of a widget instance based on its value. Typical examples are\nchanging the background image (e.g., a checked or unchecked image), changing\nthe background color, or changing the text.\n\nNotice that the class is derived from bd.widget.staticText. If the current value has\na non-empty value-text as per the `sequence` attribute, then the `text` attribute\nis set accordingly.\n\nFinally, the attribute `keys` gives a map from character codes as received from DOM keyboard\n`keypress` events to values. These may be viewed as accelerators to particular values\nwhen a particular instance has the focus."],
src:
"bd/widget/stateButton",
loc: [44,0,239,2],
supers:
["bd.widget.staticText","bd.focusable","bd.mouseable"],
module:"bd/widget/stateButton"}
,"bd.widget.stateButton.deferredConnects":{
type:
Tvariable,
sdoc:
["Declares connection points."],
imember:1,
ldoc:
[],
loc: [176,2,181,3]}
,"bd.widget.stateButton.cssState":{
type:
Tvariable,
sdoc:
["The current string to add to the DOM class attibute that reflects the current value. "],
imember:1,
ldoc:
["The current string to add to the DOM class attibute that reflects the current value. By separating\nthe value domain from the domain of strings that reflect the value in the DOM class attribute, the widget\ncan accept values on any domain (e.g., {true, false} or some set of objects) while still using CSS class\nto paint the visual presentation of the state button as a function of value. For example, by default,\ncheckbox defines the values {true, false} and reflects these values in the DOM class attribute as {\"checked\",\n\"unchecked\"} via bd.cssStateful."],
flags:
[Froattr],
loc: [158,2,174,3]}
,"bd.widget.stateButton.value":{
type:
Tvariable,
sdoc:
["The current value of the widget. Must be a value from the `sequence` attribute or undefined; attempting to set\nan illegal value is equivalent to setting the value to undefined."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [120,2,156,3],
types:
[["value from the `sequence` attribute, optional, undefined",
["The current value of the widget."]]]}
,"bd.widget.stateButton.keys":{
type:
Tvariable,
sdoc:
["Maps charCodes as received from a keypress event to a value. "],
imember:1,
ldoc:
["Maps charCodes as received from a keypress event to a value. Mapping to bd.widget.stateButton.reset\ncauses the key to set the value to the first state; mapping to bd.widget.stateButton.advance causes\nthe key to behave like a mouse click and transition the state to the next state.",
"(map:charCode --> value, optional, see code for default) Maps charCodes as received from a DOM `keypress` event to a value."],
flags:
[Fattr],
loc: [102,2,118,3]}
,"bd.widget.stateButton.sequence":{
type:
Tvariable,
sdoc:
["The ordered set of possible values and optional display information."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [75,2,100,3],
types:
[["array of bd.widget.stateButton.info, optional, [[false, \"\", \"unchecked\"], [true, \"\", \"checked\"]]",
["Gives the\n set of possible (value, value-text, CSS-text) in the order they transition."]]]}
,"bd.widget.stateButton.onClick":{
type:
Tfunction,
sdoc:
["Nontrivial connection point that causes the state to move one position upon detecting a user click."],
imember:1,
ldoc:
[],
params:
[["e",[]]],
loc: [213,2,221,3]}
,"bd.widget.stateButton.onKeyPress":{
type:
Tfunction,
sdoc:
["Nontrivial connection point that inspects a keypress for possible action as given by the\n`keys` attribute."],
imember:1,
ldoc:
[],
params:
[["e",[]]],
loc: [223,2,238,3]}
,"modules.bd/widget/stateButton":{
type:
Tmodule,
sdoc:
["Defines the bd.widget.stateButton class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/widget/stateButton",
loc: [0,0,243,2]}
,"resources.bd/widget/staticText":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/staticText"],
src:
"bd/widget/staticText",
modules:
["bd/widget/staticText"],
code:
["dojo.def(\"bd/widget/staticText\", [",
"  \"bd\",",
"  \"dojo\", ",
"  \"bd/visual\",",
"  \"bd/lang\"",
"], function(bd, dojo) {",
"///",
"// Defines the bd.widget.staticText class.",
"",
"return bd.declare(",
"  ///",
"  // A block of text.",
"",
"  //class name",
"  \"bd:widget.staticText\",",
"",
"  //superclasses",
"  [bd.visual], ",
"",
"  //members",
"  bd.attr(",
"    ///",
"    // The contents of the text block.",
"    ///",
"    //(string, optional, \"\") The contents of the text block.",
"",
"    \"value\",",
"",
"    \"\", //initial value",
"",
"    function(value) {",
"      var oldValue= this.value;",
"      if (oldValue!==value) {",
"        this.value= value;",
"        this.domNode && (this.domNode.innerHTML= value);",
"      }",
"      return oldValue;",
"    }",
"  ),",
"",
"  {",
"  cssStatefulBases: {},",
"",
"  cssStatefulWatch: {visible:0},",
"",
"  createDom: function() {",
"    this.inherited(arguments);",
"    this.domNode.innerHTML= this.value;",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license."]}
,"bd.widget.staticText":{
type:
Tclass,
sdoc:
["A block of text."],
ldoc:
[],
src:
"bd/widget/staticText",
loc: [9,7,49,2],
supers:
["bd.visual"],
module:"bd/widget/staticText"}
,"bd.widget.staticText.value":{
type:
Tvariable,
sdoc:
["The contents of the text block."],
imember:1,
ldoc:
[],
flags:
[Fattr],
loc: [20,2,38,3],
types:
[["string, optional, \"\"",
["The contents of the text block."]]]}
,"modules.bd/widget/staticText":{
type:
Tmodule,
sdoc:
["Defines the bd.widget.staticText class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/widget/staticText",
loc: [0,0,51,2]}
,"resources.bd/widget/statusbar":{
type:
Tresource,
sdoc:
["Defines the module bd/widget/statusbar"],
src:
"bd/widget/statusbar",
modules:
["bd/widget/statusbar"],
code:
["dojo.def(\"bd/widget/statusbar\", [",
"  \"bd\",",
"  \"dojo\",",
"  \"bd/visual\",",
"  \"bd/container\"",
"], function(bd, dojo) {",
"///",
"// Defines the bd.widget.statusbar class.",
"",
"return bd.declare(",
"  ///",
"  // A container the can hold, manage, and layout a set of children widgets that are displayed as a single horizontal line of sizeable items.",
"",
"  //class name",
"  \"bd:widget.statusbar\",",
" ",
"  //superclasses",
"  [bd.visual, bd.container],",
"",
"  //members",
"  {",
"  cssStatefulBases: {dijitReset: 0, bdStatusbar:0},",
"",
"  cssStatefulWatch: {visible:0},",
"",
"  constructor: function() {",
"    this.panes= [];",
"  },",
"",
"  addChild: function(",
"    child, ///(widget) The widget to add to this container.",
"    order  ///(integer) The position within the other children at which to add this child.",
"  ){",
"    ///",
"    // Adds a child at location `order`. //Replaces and returns pre-existing child at that location, if any; ",
"    // place child in the DOM tree relative to siblings as given by order.",
"",
"    order= order || this.panes.length;",
"    var result= this.panes[order] ? this.removeChild(this.panes[order]) : null;",
"    for (var i= this.panes.length; i<=order; i++) this.panes.push(null);",
"    this.panes[order]= child;",
"    i= order - 1;",
"    while (i>=0 && !this.panes[i]) i--;",
"    if (i>=0) {",
"      this.inherited(arguments, [child, this.panes[i].domNode, \"after\"]);",
"    } else {",
"      this.inherited(arguments, [child, this.domNode, \"first\"]);",
"    }",
"    return result;",
"  },",
"",
"  removeChild: function(",
"    child",
"  ) {",
"    child= this.inherited(arguments);",
"    for (var i= 0, end= this.panes.length; i<end; i++) {",
"      if (this.panes[i]===child) {",
"        if (i==end-1) {",
"          //removing the last pane...",
"          this.panes.pop();",
"        } else {",
"          this.panes[i]= null;",
"        }",
"        break;",
"      }",
"    }",
"    return child;",
"  },",
"",
"  layout: function() {",
"    ///",
"    // Positions the children. //If the `dir` attribute is \"ltr\" then all of the children but the first child",
"    // are positioned for the last child to the second child, one after another starting from the right edge. Finally,",
"    // the first child is positioned as the left edge and given all the remaining horizontal space. The analogous",
"    // algorithm is used if `dir` is \"rtl\".",
"",
"    if (!this.started) {",
"      return 0;",
"    }",
"    ",
"    var i, end, right, left, marginBox, child, panes= [];",
"",
"    //get a pane vector with no holes",
"    for (i= 0, end= this.panes.length; i<end; i++) {",
"      child= this.panes[i];",
"      child && panes.push(child);",
"    }",
"",
"    if (this.get(\"dir\")==\"ltr\") {",
"      for (right= 0, i= panes.length-1; i>0; i--) {",
"        child= panes[i];",
"        dojo.style(child.domNode, {top:0, right:right});",
"        marginBox= dojo.marginBox(child.domNode);",
"        right+= marginBox.w;",
"        child.layout && child.layout(marginBox);",
"      }",
"      child= panes[0];",
"      if (child) {",
"        dojo.style(child.domNode, {top:0, left:0, right:right});",
"        marginBox= dojo.marginBox(child.domNode);",
"        child.layout && child.layout(marginBox);",
"      }",
"    } else {",
"      for (left= 0, i= 0, end= panes.length-1; i<end; i++) {",
"        child= panes[i];",
"        dojo.style(child.domNode, {top:0, left:left});",
"        marginBox= dojo.marginBox(child.domNode);",
"        left+= marginBox.w;",
"        child.layout && child.layout(marginBox);",
"      }",
"      child= panes[i];",
"      if (child) {",
"        dojo.style(child.domNode, {top:0, left:left, right:0});",
"        marginBox= dojo.marginBox(child.domNode);",
"        child.layout && child.layout(marginBox);",
"      }",
"    }",
"    return dojo.marginBox(this.domNode);",
"  },",
"",
"  setPaneValue: function(",
"    value, ///(any) The value to pass to the target pane.",
"    pane   ///(integer or name) Indentifies the target pane.",
"  ) {",
"    ///",
"    // Sets the `value` attribute of the target pane.",
"    var child= (dojo.isString(pane) ? this.getChild(pane) : this.panes[pane]);",
"    child && child.set(\"value\", value);",
"  }",
"});",
"",
"});",
"// Copyright (c) 2000-2009, Altoviso, Inc. (www.altoviso.com). Use, modification, and distribution subject to terms of license.",
""]}
,"bd.widget.statusbar":{
type:
Tclass,
sdoc:
["A container the can hold, manage, and layout a set of children widgets that are displayed as a single horizontal line of sizeable items."],
ldoc:
[],
src:
"bd/widget/statusbar",
loc: [9,7,129,2],
supers:
["bd.visual","bd.container"],
module:"bd/widget/statusbar"}
,"bd.widget.statusbar.addChild":{
type:
Tfunction,
sdoc:
["Adds a child at location `order`. "],
imember:1,
ldoc:
["Adds a child at location `order`. Replaces and returns pre-existing child at that location, if any;\nplace child in the DOM tree relative to siblings as given by order."],
params:
[["child",[["widget",
["The widget to add to this container."]]]],
["order",[["integer",
["The position within the other children at which to add this child."]]]]],
loc: [29,2,49,3]}
,"bd.widget.statusbar.layout":{
type:
Tfunction,
sdoc:
["Positions the children. "],
imember:1,
ldoc:
["Positions the children. If the `dir` attribute is \"ltr\" then all of the children but the first child\nare positioned for the last child to the second child, one after another starting from the right edge. Finally,\nthe first child is positioned as the left edge and given all the remaining horizontal space. The analogous\nalgorithm is used if `dir` is \"rtl\"."],
loc: [69,2,118,3]}
,"bd.widget.statusbar.setPaneValue":{
type:
Tfunction,
sdoc:
["Sets the `value` attribute of the target pane."],
imember:1,
ldoc:
[],
params:
[["value",[["any",
["The value to pass to the target pane."]]]],
["pane",[["integer or name",
["Indentifies the target pane."]]]]],
loc: [120,2,128,3]}
,"modules.bd/widget/statusbar":{
type:
Tmodule,
sdoc:
["Defines the bd.widget.statusbar class."],
ldoc:
[],
flags:
[Fmodule],
params:
[["bd",[]],
["dojo",[]]],
src:
"bd/widget/statusbar",
loc: [0,0,131,2]}

}]);
});
